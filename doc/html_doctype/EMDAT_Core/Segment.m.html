<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>Segment API documentation</title>
    <meta name="description" content="UBC Eye Movement Data Analysis Toolkit (EMDAT), Version 3
Created on 2011-08-26

Segment class: smal..." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">


    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#Segment.Segment">Segment</a></span>
        
          
  <ul>
    <li class="mono"><a href="#Segment.Segment.__init__">__init__</a></li>
    <li class="mono"><a href="#Segment.Segment.calc_abs_angles">calc_abs_angles</a></li>
    <li class="mono"><a href="#Segment.Segment.calc_blink_features">calc_blink_features</a></li>
    <li class="mono"><a href="#Segment.Segment.calc_blink_validity_gaps">calc_blink_validity_gaps</a></li>
    <li class="mono"><a href="#Segment.Segment.calc_distance_features">calc_distance_features</a></li>
    <li class="mono"><a href="#Segment.Segment.calc_distances">calc_distances</a></li>
    <li class="mono"><a href="#Segment.Segment.calc_event_features">calc_event_features</a></li>
    <li class="mono"><a href="#Segment.Segment.calc_fix_ang_path_features">calc_fix_ang_path_features</a></li>
    <li class="mono"><a href="#Segment.Segment.calc_largest_validity_gap">calc_largest_validity_gap</a></li>
    <li class="mono"><a href="#Segment.Segment.calc_num_samples">calc_num_samples</a></li>
    <li class="mono"><a href="#Segment.Segment.calc_pupil_features">calc_pupil_features</a></li>
    <li class="mono"><a href="#Segment.Segment.calc_rel_angles">calc_rel_angles</a></li>
    <li class="mono"><a href="#Segment.Segment.calc_saccade_features">calc_saccade_features</a></li>
    <li class="mono"><a href="#Segment.Segment.calc_validity1">calc_validity1</a></li>
    <li class="mono"><a href="#Segment.Segment.calc_validity2">calc_validity2</a></li>
    <li class="mono"><a href="#Segment.Segment.calc_validity3">calc_validity3</a></li>
    <li class="mono"><a href="#Segment.Segment.calc_validity_fixation">calc_validity_fixation</a></li>
    <li class="mono"><a href="#Segment.Segment.calc_validity_proportion">calc_validity_proportion</a></li>
    <li class="mono"><a href="#Segment.Segment.generate_aoi_sequence">generate_aoi_sequence</a></li>
    <li class="mono"><a href="#Segment.Segment.get_features">get_features</a></li>
    <li class="mono"><a href="#Segment.Segment.get_indices">get_indices</a></li>
    <li class="mono"><a href="#Segment.Segment.get_length_invalid">get_length_invalid</a></li>
    <li class="mono"><a href="#Segment.Segment.get_validity">get_validity</a></li>
    <li class="mono"><a href="#Segment.Segment.getallgaps">getallgaps</a></li>
    <li class="mono"><a href="#Segment.Segment.getgaps">getgaps</a></li>
    <li class="mono"><a href="#Segment.Segment.getid">getid</a></li>
    <li class="mono"><a href="#Segment.Segment.print_">print_</a></li>
    <li class="mono"><a href="#Segment.Segment.set_aois">set_aois</a></li>
    <li class="mono"><a href="#Segment.Segment.set_indices">set_indices</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">Segment</span> module</h1>
  <p>UBC Eye Movement Data Analysis Toolkit (EMDAT), Version 3
Created on 2011-08-26</p>
<p>Segment class: smallest unit of aggregated eye data samples that has conceptual meaning.
A segment is always assigned to a scene.</p>
<p>Authors: Samad Kardan (creator), Sebastien Lalle.
Institution: The University of British Columbia.</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Segment', this);">Show source &equiv;</a></p>
  <div id="source-Segment" class="source">
    <pre><code>"""
UBC Eye Movement Data Analysis Toolkit (EMDAT), Version 3
Created on 2011-08-26

Segment class: smallest unit of aggregated eye data samples that has conceptual meaning.
A segment is always assigned to a scene.

Authors: Samad Kardan (creator), Sebastien Lalle.
Institution: The University of British Columbia.
"""
import sys
sys.path.append('.')
sys.path.append('./EMDAT_core')
import params
from EMDAT_core import geometry
from EMDAT_core.AOI import *
from warnings import warn
from math import isnan
from EMDAT_core.AOI import _fixation_inside_aoi

class Segment():
    """A Segment is a class that represents the smallest unit of aggregated eye data samples with a conceptual meaning.

    A segment is the smallest unit of aggregated eye data samples that has conceptual meaning. This class is the equivalent
    of segments as defined in Tobii studio.

    Attributes:
        segid: A string containing the id of the Segment.
        alldata: A list of "Datapoint"s for this Segment
        features: A dict with feature names as its keys and feature values as its values
        completion_time: An integer indicating total duration of the Segment in milliseconds
            minimum is 16 ms (length of one sample with 60Hz sampling rate (ms))
        start: An integer indicating the Segment's start time in milliseconds
        end: An integer indicating the Segment's end time in milliseconds
        sample_start_ind: An integer indicating the index of the first Datapoint for this Segment in the Participant's list of all "Datapoint"s (all_data)
        sample_end_ind: An integer indicating the index of the last Datapoint for this Segment in the Participant's list of all "Datapoint"s (all_data)
        fixation_start_ind: An integer indicating the index of the first Fixation for this Segment in the Participant's list of all "Fixation"s (fixation_data)
        fixation_end_ind: An integer indicating the index of the last Fixation for this Segment in the Participant's list of all "Fixation"s (fixation_data)
        numfixations: An integer indicating the number of "Fixation"s in this Segment
        time_gaps: a list of tuples of the form (start, end) indicating the start and end of the gaps of invalid samples in the Segment's samples
        all_invalid_gaps: a list of tuples of the form (start, end) indicating the start and the end of all the gaps of invalid samples
        largest_data_gap: An integer indicating the length of largest invalid gap for this Segment in milliseconds
        proportion_valid: A float indicating the proportion of valid samples over all the samples in this Segment
        proportion_valid_fix: A float indicating the proportion of (valid + restored) samples over all the samples in this Segment
        validity1: a boolean indicating whether this Segment is valid using proportion of valid samples threshold
        validity2: a boolean indicating whether this Segment is valid using largest acceptable gap threshold
        validity3: a boolean indicating whether this Segment is valid using proportion of (valid + restored) samples threshold
        is_valid: a boolean indicating whether this Segment is considered valid by the validity method indicated by params.VALIDITY_METHOD
        length_invalid: An integer indicating total duration of invalid gaps in the segment in milliseconds
        length: An integer indicating total duration of the Segment in milliseconds
        numsamples: An integer indicating total number of samples in the Segment
        fixation_data: A list of "Fixation"s for this Segment
        fixation_start: timestamp of the first entry from list of "Fixation"s for this Segment
        fixation_end: timestamp of the last entry from list of "Fixation"s for this Segment
        aoi_data: A list of AOI_Stat objects for relevant "AOI"s for this Segment
        has_aois: A boolean indicating if this Segment has AOI features calculated for it
    """
    def __init__(self, segid, all_data, fixation_data, saccade_data = None, event_data = None, aois = None, prune_length = None, rest_pupil_size = 0, export_pupilinfo = False):
        """
        Args:
            segid: A string containing the id of the Segment.

            all_data: a list of "Datapoint"s which make up this Segment.

            fixation_data: a list of "Fixation"s which make up this Segment.

            saccade_data: a list of "Saccade"s which make up this Segment (None if no saccades).

            event_data: a list of "Event"s which make up this Segment (None if no events).

            aois: a list of "AOI"s relevant to this Segment.

            prune_length: If not None, an integer that specifies the time interval (in ms) from the beginning of each segment in which
                samples are considered in calculations.  This can be used if, for example, you only wish to consider data in the first
                1000 ms of each segment. In this case (prune_length = 1000), all data beyond the first 1000ms of the start of the segments
                will be disregarded.

            rest_pupil_size: rest pupil size for this segment, used to adjust pupil size.

            export_pupilinfo: True to export raw pupil data in EMDAT output (False by default).

        Yields:
            a Segment object
        """
        self.segid = segid
        #self.all_data = all_data
        #self.fixation_data = fixation_data
        #self.saccade_data = saccade_data
        #self.event_data = event_data
        self.features = {}

        """ If prune_length specified, keep only data from start to start + prune_length
            of the segment
        """
        if prune_length:
            all_data = filter(lambda x: x.timestamp <= self.start + prune_length, all_data)
            fixation_data = filter(lambda x: x.timestamp <= self.start + prune_length, fixation_data)
            if event_data != None:
                event_data = filter(lambda x: x.timestamp <= self.start + prune_length, event_data)
            if saccade_data != None:
                saccade_data = filter(lambda x: x.timestamp <= self.start + prune_length, saccade_data)
                
        self.completion_time = all_data[-1].timestamp - all_data[0].timestamp
        if self.completion_time == 0:
            raise Exception("Zero length segment")

        self.features['completion_time'] = self.completion_time
        self.start = all_data[0].timestamp
        self.numfixations = len(fixation_data)

        """ Validity-related features, determining if the segment is valid """
        self.time_gaps = []
        self.all_invalid_gaps = []
        self.largest_data_gap = self.calc_largest_validity_gap(all_data)
        self.proportion_valid = self.calc_validity_proportion(all_data)
        self.proportion_valid_fix = self.calc_validity_fixation(all_data)
        self.validity1 = self.calc_validity1()
        self.validity2 = self.calc_validity2()
        self.validity3 = self.calc_validity3()
        self.is_valid = self.get_validity()
        self.length_invalid = self.get_length_invalid()

        self.end = all_data[-1].timestamp
        self.length = self.end - self.start
        self.features['length'] = self.end - self.start
        self.features['length_invalid'] = self.length_invalid
        self.numsamples = self.calc_num_samples(all_data)
        self.features['numsamples'] = self.numsamples
        self.numfixations = len(fixation_data)
        self.features['numfixations'] = self.numfixations
        self.features['fixationrate'] = float(self.numfixations) / (self.length - self.length_invalid)

        """ calculate blink features (no rest pupil size adjustments yet)"""
        self.calc_blink_features(all_data)

        """ calculate pupil dilation features (no rest pupil size adjustments yet)"""
        self.calc_pupil_features(all_data, export_pupilinfo, rest_pupil_size)

        """ calculate distance from screen features"""
        self.calc_distance_features(all_data)

        """ calculate fixations, angles and path features"""
        self.calc_fix_ang_path_features(fixation_data)

        """ calculate saccades features if available """
        self.calc_saccade_features(saccade_data)

        """ calculate event features if available """
        self.calc_event_features(event_data)

        """ calculate AOIs features """
        self.has_aois = False
        if aois:
            self.set_aois(aois, all_data, fixation_data, event_data, rest_pupil_size, export_pupilinfo)
            self.features['aoisequence'] = self.generate_aoi_sequence(fixation_data, aois)


    def set_indices(self,sample_st,sample_end,fix_st,fix_end,sac_st=None,sac_end=None,event_st=None,event_end=None):
        """Sets the index features

        Args:
            sample_st: An integer indicating the index of the first Datapoint for this Segment in the Participant's list of all "Datapoint"s (all_data)
            sample_end: An integer indicating the index of the last Datapoint for this Segment in the Participant's list of all "Datapoint"s (all_data)
            fix_st: An integer indicating the index of the first Fixation for this Segment in the Participant's list of all "Fixation"s (fixation_data)
            fix_end: An integer indicating the index of the last Fixation for this Segment in the Participant's list of all "Fixation"s (fixation_data)
            sac_st: An integer indicating the index of the first Saccade for this Segment in the Participant's list of all "Saccade"s (saccade_data)
            sac_end: An integer indicating the index of the last Saccade for this Segment in the Participant's list of all "Saccade"s (saccade_data)
            event_st: An integer indicating the index of the first Event for this Segment in the Participant's list of all "Event"s (event_data)
            event_end: An integer indicating the index of the last Event for this Segment in the Participant's list of all "Event"s (event_data)
        """
        self.sample_start_ind = sample_st
        self.sample_end_ind = sample_end
        self.fixation_start_ind = fix_st
        self.fixation_end_ind = fix_end
        self.saccade_start_ind = sac_st
        self.saccade_end_ind = sac_end
        self.event_start_ind = event_st
        self.event_end_ind = event_end


    def get_indices(self):
        """Returns the index features

        Returns:
            An integer indicating the index of the first Datapoint for this Segment in the Participant's list of all "Datapoint"s (all_data)
            An integer indicating the index of the last Datapoint for this Segment in the Participant's list of all "Datapoint"s (all_data)
            An integer indicating the index of the first Fixation for this Segment in the Participant's list of all "Fixation"s (fixation_data)
            An integer indicating the index of the last Fixation for this Segment in the Participant's list of all "Fixation"s (fixation_data)
            An integer indicating the index of the first Saccade for this Segment in the Participant's list of all "Saccade"s (saccade_data). None if no saccade.
            An integer indicating the index of the last Saccade for this Segment in the Participant's list of all "Saccade"s (saccade_data). None if no saccade.
            An integer indicating the index of the first Event for this Segment in the Participant's list of all "Event"s (event_data). None if no saccade.
            An integer indicating the index of the last Event for this Segment in the Participant's list of all "Event"s (event_data). None if no saccade.
        Raises:
            Exception: An exception is thrown if the values are read before initialization
        """
        if self.sample_start_ind != None:
            return self.sample_start_ind, self.sample_end_ind, self.fixation_start_ind, \
                self.fixation_end_ind, self.saccade_start_ind, self.saccade_end_ind, self.event_start_ind, self.event_end_ind
        raise Exception ('The indices values are accessed before setting the initial value in segement:'+self.segid+'!')


    def set_aois(self, aois, all_data, fixation_data, event_data = None, rest_pupil_size = 0, export_pupilinfo = False):
        """Sets the relevant "AOI"s for this Segment

        Args:
            all_data: a list of "Datapoint"s which make up this Segment
            fixation_data: The list of "Fixation"s which make up this Segment
            aois: a list of "AOI"s relevant to this Segment
            rest_pupil_size:
        """

        if len(aois) == 0:
            warn("No AOIs passed to segment:"+self.segid)
        active_aois=[]
        self.aoi_data = {}
        for aoi in aois:
            #print "checking:",aoi.aid
            print("Generating features for %s AOI in segment %s" % (aoi.aid, self.segid))
            aoistat = AOI_Stat(aoi, all_data, fixation_data, self.start, self.end, self.length_invalid, aois, event_data, rest_pupil_size, export_pupilinfo)
            self.aoi_data[aoi.aid] = aoistat

            act, _ = aoi.is_active_partition(self.fixation_start, self.fixation_end)
            if act:
                active_aois.append(aoi)
                self.has_aois = True
        print("SEGMENT: active aois in this segment: %d" % len(active_aois))
        if not(active_aois):
            msg = "No active AOIs passed to segment:%s start:%d end:%d" %(self.segid,self.start,self.end)
            warn(msg)

    def calc_blink_features(self, all_data):
        """ Calculates blink features such as
                blink_num:                 number of blinks on the in the segment
                blink_duration_total:       sum of the blink durations for this segment
                blink_duration_mean:        mean of the blink durations for this segment
                blink_duration_std:         standard deviation of blink durations for this segment
                blink_duration_max:         maximal blink duration for this segment
                blink_duration_min:         minimal blink duration for this segment
                blink_rate:                 rate of blinks for this segment
                blink_time_distance_mean:   mean time difference between consequtive blinks
                blink_time_distance_std:    std time difference between consequtive blinks
                blink_time_distance_min:    minimal time difference between consequtive blinks
                blink_time_distance_max:    maximal time difference between consequtive blinks
            Args:
                all_data: The list of "Datapoint"s which make up this Segment
        """
        blink_durations = []
        blink_intervals = []
        last_blink_detected = -1
        self.features['blinknum']               = 0
        self.features['blinkdurationtotal']     = 0
        self.features['blinkdurationmean']      = 0
        self.features['blinkdurationstd']       = 0
        self.features['blinkdurationmin']       = -1
        self.features['blinkdurationmax']       = -1
        self.features['blinkrate']              = -1
        self.features['blinktimedistancemean']  = -1
        self.features['blinktimedistancestd']   = -1
        self.features['blinktimedistancemin']   = -1
        self.features['blinktimedistancemax']   = -1
        lower_bound, upper_bould = params.blink_threshold
        ### File operations are for testing
        #file = open('outputfolder/blinks/blinks_%s.txt' % all_data[0].participant_name, 'w
        blinks_validity_gaps = self.calc_blink_validity_gaps(all_data)
        if params.EYETRACKERTYPE == "SMI":
            for i in range(len(blinks_validity_gaps)):
                blink_length = blinks_validity_gaps[i][1] - blinks_validity_gaps[i][0]
                blink_durations.append(blink_length)
                #file.write('Blink start, end: %d %d\n' % (self.time_gaps[i][0], self.time_gaps[i][1]))
                if last_blink_detected != -1:
                    # Calculate time difference between start of current blink and end of previous blink
                    blink_intervals.append(blinks_validity_gaps[i][0] - blinks_validity_gaps[last_blink_detected][1])
                last_blink_detected = i
        else:
            for i in range(len(blinks_validity_gaps)):
                blink_length = blinks_validity_gaps[i][1] - blinks_validity_gaps[i][0]
                if blink_length <= upper_bould and blink_length >= lower_bound:
                    blink_durations.append(blink_length)
                    #file.write('Blink start, end: %d %d\n' % (self.time_gaps[i][0], self.time_gaps[i][1]))
                    if last_blink_detected != -1:
                        # Calculate time difference between start of current blink and end of previous blink
                        blink_intervals.append(blinks_validity_gaps[i][0] - blinks_validity_gaps[last_blink_detected][1])
                    last_blink_detected = i

        #file.close()
        if len(blink_durations) > 0:
            self.features['blinknum']               = len(blink_durations)
            self.features['blinkdurationtotal']     = sum(blink_durations)
            self.features['blinkdurationmean']      = mean(blink_durations)
            self.features['blinkdurationstd']       = stddev(blink_durations)
            self.features['blinkdurationmin']       = min(blink_durations)
            self.features['blinkdurationmax']       = max(blink_durations)
            self.features['blinkrate']              = float(self.features['blinknum']) / (self.length - self.length_invalid)
        if len(blink_intervals) > 0:
            self.features['blinktimedistancemean']  = mean(blink_intervals)
            self.features['blinktimedistancestd']   = stddev(blink_intervals)
            self.features['blinktimedistancemin']   = min(blink_intervals)
            self.features['blinktimedistancemax']   = max(blink_intervals)


    def calc_pupil_features(self, all_data, export_pupilinfo, rest_pupil_size):
        """ Calculates pupil features such as
                mean_pupil_size:            mean of pupil sizes
                stddev_pupil_size:          standard deviation of pupil sizes
                min_pupil_size:             smallest pupil size in this segment
                max_pupil_size:             largest pupil size in this segment
                mean_pupil_velocity:        mean of pupil velocities
                stddev_pupil_velocity:      standard deviation of pupil velocities
                min_pupil_velocity:         smallest pupil velocity in this segment
                max_pupil_velocity:         largest pupil velocity in this segment

            Args:
                all_data: The list of "Datapoint"s which make up this Segment
        """
        # check if pupil sizes are available for all missing points
        pupil_invalid_data = filter(lambda x: x.pupilsize == -1 and x.gazepointx > 0, all_data)
        if len(pupil_invalid_data) > 0:
            if params.DEBUG:
                raise Exception("Pupil size is unavailable for a valid data sample. \
                        Number of missing points: " + str(len(pupil_invalid_data)))
            else:
                warn("Pupil size is unavailable for a valid data sample. Number of missing points: " + str(len(pupil_invalid_data)) )

		#get all pupil sizes (valid + invalid)
        #pupilsizes = map(lambda x: x.pupilsize, all_data)
        #get all datapoints where pupil size is available
        valid_pupil_data = filter(lambda x: x.pupilsize > 0, all_data)
        valid_pupil_velocity = filter(lambda x: x.pupilvelocity != -1, all_data)

        #number of valid pupil sizes
        self.features['meanpupilsize']       = -1
        self.features['stddevpupilsize']     = -1
        self.features['maxpupilsize']        = -1
        self.features['minpupilsize']        = -1
        self.features['startpupilsize']      = -1
        self.features['endpupilsize']        = -1
        self.features['meanpupilvelocity']   = -1
        self.features['stddevpupilvelocity'] = -1
        self.features['maxpupilvelocity']    = -1
        self.features['minpupilvelocity']    = -1
        self.numpupilsizes                   = len(valid_pupil_data)
        self.numpupilvelocity                = len(valid_pupil_velocity)

        if self.numpupilsizes > 0: #check if the current segment has pupil data available
            if params.PUPIL_ADJUSTMENT == "rpscenter":
                adjvalidpupilsizes = map(lambda x: x.pupilsize - rest_pupil_size, valid_pupil_data)
            elif params.PUPIL_ADJUSTMENT == "PCPS":
                adjvalidpupilsizes = map(lambda x: (x.pupilsize - rest_pupil_size) / (1.0 * rest_pupil_size), valid_pupil_data)
            else:
                adjvalidpupilsizes = map(lambda x: x.pupilsize, valid_pupil_data)#valid_pupil_data

            valid_pupil_velocity = map(lambda x: x.pupilvelocity, valid_pupil_velocity)#valid_pupil_data

            if export_pupilinfo:
                self.pupilinfo_for_export = map(lambda x: [x.timestamp, x.pupilsize, rest_pupil_size], valid_pupil_data)
            self.features['meanpupilsize']           = mean(adjvalidpupilsizes)
            self.features['stddevpupilsize']         = stddev(adjvalidpupilsizes)
            self.features['maxpupilsize']            = max(adjvalidpupilsizes)
            self.features['minpupilsize']            = min(adjvalidpupilsizes)
            self.features['startpupilsize']          = adjvalidpupilsizes[0]
            self.features['endpupilsize']            = adjvalidpupilsizes[-1]

            if len(valid_pupil_velocity) > 0:
                self.features['meanpupilvelocity']   = mean(valid_pupil_velocity)
                self.features['stddevpupilvelocity'] = stddev(valid_pupil_velocity)
                self.features['maxpupilvelocity']    = max(valid_pupil_velocity)
                self.features['minpupilvelocity']    = min(valid_pupil_velocity)

    def calc_distance_features(self, all_data):
        """ Calculates distance features such as
                mean_distance:            mean of distances from the screen
                stddev_distance:          standard deviation of distances from the screen
                min_distance:             smallest distance from the screen in this segment
                max_distance:             largest distance from the screen in this segment
                start_distance:           distance from the screen in the beginning of this segment
                end_distance:             distance from the screen in the end of this segment

            Args:
                all_data: The list of "Datapoint"s which make up this Segment
        """
        # check if distances are available for all missing points
        invalid_distance_data = filter(lambda x: x.distance <= 0 and x.gazepointx >= 0, all_data)
        if len(invalid_distance_data) > 0:
            warn("Distance from screen is unavailable for a valid data sample. \
                        Number of missing points: " + str(len(invalid_distance_data)))

        #get all datapoints where distance is available
        valid_distance_data = filter(lambda x: x.distance > 0, all_data)

        #number of valid distance datapoints
        self.numdistancedata = len(valid_distance_data)
        if self.numdistancedata > 0: #check if the current segment has pupil data available
            distances_from_screen               = map(lambda x: x.distance, valid_distance_data)
            self.features['meandistance']       = mean(distances_from_screen)
            self.features['stddevdistance']     = stddev(distances_from_screen)
            self.features['maxdistance']        = max(distances_from_screen)
            self.features['mindistance']        = min(distances_from_screen)
            self.features['startdistance']      = distances_from_screen[0]
            self.features['enddistance']        = distances_from_screen[-1]
        else:
            self.features['meandistance']       = -1
            self.features['stddevdistance']     = -1
            self.features['maxdistance']        = -1
            self.features['mindistance']        = -1
            self.features['startdistance']      = -1
            self.features['enddistance']        = -1


    def calc_saccade_features(self, saccade_data):
        """ Calculates saccade features such as
                numsaccades:              number of saccades in the segment
                sumsaccadedistance:       sum of distances during each saccade
                meansaccadedistance:      mean of distances during each saccade
                stddevsaccadedistance:    standard deviation of distances during each saccade
                longestsaccadedistance:   distance of longest saccade
                sumsaccadeduration:       total time spent on saccades in this segment
                meansaccadeduration:      average saccade duration
                stddevsaccadeduration:    standard deviation of saccade durations
                longestsaccadeduration:   longest duration of saccades in this segment
                meansaccadespeed:         average speed of saccades in this segment
                stddevsaccadespeed:       standard deviation of speed of saccades in this segment
                maxsaccadespeed:          highest saccade speed in this segment
                minsaccadespeed:          lowest saccade speed in this  segment
                fixationsaccadetimeratio: fixation to saccade time ratio for this segment
            Args:
                saccade_data: The list of saccade datapoints for this Segment
        """
        if saccade_data != None and len(saccade_data) > 0:
            self.numsaccades = len(saccade_data)
            self.features['numsaccades'] = self.numsaccades
            self.features['sumsaccadedistance'] = sum(map(lambda x: float(x.saccadedistance), saccade_data))
            self.features['meansaccadedistance'] = mean(map(lambda x: float(x.saccadedistance), saccade_data))
            self.features['stddevsaccadedistance'] = stddev(map(lambda x: float(x.saccadedistance), saccade_data))
            self.features['longestsaccadedistance'] = max(map(lambda x: float(x.saccadedistance), saccade_data))
            self.features['sumsaccadeduration'] = sum(map(lambda x: float(x.saccadeduration), saccade_data))
            self.features['meansaccadeduration'] = mean(map(lambda x: float(x.saccadeduration), saccade_data))
            self.features['stddevsaccadeduration'] = stddev(map(lambda x: float(x.saccadeduration), saccade_data))
            self.features['longestsaccadeduration'] = max(map(lambda x: float(x.saccadeduration), saccade_data))
            self.features['meansaccadespeed'] = mean(map(lambda x: float(x.saccadespeed), saccade_data))
            self.features['stddevsaccadespeed'] = stddev(map(lambda x: float(x.saccadespeed), saccade_data))
            self.features['maxsaccadespeed'] = max(map(lambda x: float(x.saccadespeed), saccade_data))
            self.features['minsaccadespeed'] = min(map(lambda x: float(x.saccadespeed), saccade_data))
            self.features['fixationsaccadetimeratio'] = float(self.features['sumfixationduration']) / self.features['sumsaccadeduration']
        else:
            self.numsaccades = 0
            self.features['numsaccades'] = 0
            self.features['sumsaccadedistance'] = -1
            self.features['meansaccadedistance'] = -1
            self.features['stddevsaccadedistance'] = -1
            self.features['longestsaccadedistance'] = -1
            self.features['sumsaccadeduration'] = -1
            self.features['meansaccadeduration'] = -1
            self.features['stddevsaccadeduration'] = -1
            self.features['longestsaccadeduration'] = -1
            self.features['meansaccadespeed'] = -1
            self.features['stddevsaccadespeed'] = -1
            self.features['maxsaccadespeed'] = -1
            self.features['minsaccadespeed'] = -1
            self.features['fixationsaccadetimeratio'] = -1


    def calc_fix_ang_path_features(self, fixation_data):
        """ Calculates fixation, angle and path features such as
                meanfixationduration:     mean duration of fixations in the segment
                stddevfixationduration    standard deviation of duration of fixations in the segment
                sumfixationduration:      sum of durations of fixations in the segment
                fixationrate:             rate of fixation datapoints relative to all datapoints in this segment
                meanpathdistance:         mean of path distances for this segment
                sumpathdistance:          sum of path distances for this segment
                eyemovementvelocity:      average eye movement velocity for this segment
                sumabspathangles:         sum of absolute path angles for this segment
                abspathanglesrate:        ratio of absolute path angles relative to all datapoints in this segment
                stddevabspathangles:      standard deviation of absolute path angles for this segment
                sumrelpathangles:         sum of relative path angles for this segment
                relpathanglesrate:        ratio of relative path angles relative to all datapoints in this segment
                stddevrelpathangles:      standard deviation of relative path angles for this segment
            Args:
                saccade_data: The list of saccade datapoints for this Segment
        """
        if self.numfixations > 0:
            self.fixation_start = fixation_data[0].timestamp
            self.fixation_end = fixation_data[-1].timestamp
            self.features['meanfixationduration'] = mean(map(lambda x: float(x.fixationduration), fixation_data))
            self.features['stddevfixationduration'] = stddev(map(lambda x: float(x.fixationduration), fixation_data))
            self.features['sumfixationduration'] = sum(map(lambda x: x.fixationduration, fixation_data))
            self.features['fixationrate'] = float(self.numfixations) / (self.length - self.length_invalid)
            distances = self.calc_distances(fixation_data)
            abs_angles = self.calc_abs_angles(fixation_data)
            rel_angles = self.calc_rel_angles(fixation_data)
        else:
            self.fixation_start = -1
            self.fixation_end = -1
            self.features['meanfixationduration'] = -1
            self.features['stddevfixationduration'] = -1
            self.features['sumfixationduration'] = -1
            self.features['fixationrate'] = -1

        self.numfixdistances = len(distances)
        self.numabsangles = len(abs_angles)
        self.numrelangles = len(rel_angles)
        if len(distances) > 0:
            self.features['meanpathdistance'] = mean(distances)
            self.features['sumpathdistance'] = sum(distances)
            self.features['stddevpathdistance'] = stddev(distances)
            self.features['eyemovementvelocity'] = self.features['sumpathdistance']/(self.length - self.length_invalid)
            self.features['sumabspathangles'] = sum(abs_angles)
            self.features['abspathanglesrate'] = sum(abs_angles)/(self.length - self.length_invalid)
            self.features['meanabspathangles'] = mean(abs_angles)
            self.features['stddevabspathangles'] = stddev(abs_angles)
            self.features['sumrelpathangles'] = sum(rel_angles)
            self.features['relpathanglesrate'] = sum(rel_angles)/(self.length - self.length_invalid)
            self.features['meanrelpathangles'] = mean(rel_angles)
            self.features['stddevrelpathangles'] = stddev(rel_angles)
        else:
            self.features['meanpathdistance'] = -1
            self.features['sumpathdistance'] = -1
            self.features['stddevpathdistance'] = -1
            self.features['eyemovementvelocity'] = -1
            self.features['sumabspathangles'] = -1
            self.features['abspathanglesrate'] = -1
            self.features['meanabspathangles'] = -1
            self.features['stddevabspathangles'] = -1
            self.features['sumrelpathangles'] = -1
            self.features['relpathanglesrate'] = -1
            self.features['meanrelpathangles'] = -1
            self.features['stddevrelpathangles'] = -1


    def calc_event_features(self, event_data):
        """ Calculates event features such as
                numevents:                number of events in the segment
                numleftclic:              number of left clinks in the segment
                numrightclic:             number of right clinks in the segment
                numdoubleclic:            number of double clinks in the segment
                numkeypressed:            number of times a key was pressed in the segment
                leftclicrate:             the rate of left clicks (relative to all datapoints) in this segment
                rightclicrate:            the rate of right clicks (relative to all datapoints) in this segment
                doubleclicrate:           the rate of double clicks (relative to all datapoints) in this segment
                keypressedrate:           the rate of key presses (relative to all datapoints) in this segment
                timetofirstleftclic:      time until the first left click in this segment
                timetofirstrightclic:     time until the first right click in this segment
                timetofirstdoubleclic:    time until the first double click in this segment
                timetofirstkeypressed:    time until the first key pressed in this segment
            Args:
                event_data: The list of events for this Segment
        """
        if event_data != None:
            (leftc, rightc, doublec, keyp) = generate_event_lists(event_data)

            self.numevents = len(leftc)+len(rightc)+len(doublec)+len(keyp)
            self.features['numevents'] = self.numevents
            self.features['numleftclic'] = len(leftc)
            self.features['numrightclic'] = len(rightc)
            self.features['numdoubleclic'] = len(doublec)
            self.features['numkeypressed'] = len(keyp)
            self.features['leftclicrate'] = float(len(leftc))/(self.length - self.length_invalid)
            self.features['rightclicrate'] = float(len(rightc))/(self.length - self.length_invalid)
            self.features['doubleclicrate'] = float(len(doublec))/(self.length - self.length_invalid)
            self.features['keypressedrate'] = float(len(keyp))/(self.length - self.length_invalid)
            self.features['timetofirstleftclic'] = leftc[0].timestamp if len(leftc) > 0 else -1
            self.features['timetofirstrightclic'] = rightc[0].timestamp if len(rightc) > 0 else -1
            self.features['timetofirstdoubleclic'] = doublec[0].timestamp if len(doublec) > 0 else -1
            self.features['timetofirstkeypressed'] = keyp[0].timestamp if len(keyp) > 0 else -1
        else:
            self.features['numevents'] = 0
            self.features['numleftclic'] = 0
            self.features['numrightclic'] = 0
            self.features['numdoubleclic'] = 0
            self.features['numkeypressed'] = 0
            self.features['leftclicrate'] = -1
            self.features['rightclicrate'] = -1
            self.features['doubleclicrate'] = -1
            self.features['keypressedrate'] = -1
            self.features['timetofirstleftclic'] = -1
            self.features['timetofirstrightclic'] = -1
            self.features['timetofirstdoubleclic'] = -1
            self.features['timetofirstkeypressed'] = -1


    def calc_validity_proportion(self, all_data):
        """Calculates the proportion of "Datapoint"s which are valid.

        Args:
            all_data: The list of "Datapoint"s which make up this Segment

        Returns:
            A float indicating the proportion of valid samples over all the samples in this Segment
        """
        num_valid = float(0)
        num = 0

        for d in all_data:
            #if d.stimuliname == 'ScreenRec':
            #if d.stimuliname == 'Screen Recordings (1)'
            if d.stimuliname != '':
                num += 1
                if d.is_valid:
                    num_valid += 1
#            else:
#                print "###",d.event, d.data1
        if num == 0:
            return 0.0
        else:
            return num_valid / num


    def calc_largest_validity_gap(self, all_data):
        """Calculates the largest gap of invalid samples in the "Datapoint"s for this Segment.

        Args:
            all_data: The list of "Datapoint"s which make up this Segement

        Returns:
            An integer indicating the length of largest invalid gap for this Segment in milliseconds
        """
        if self.numfixations == 0:
            return all_data[-1].timestamp - all_data[0].timestamp
        self.time_gaps = []
        self.all_invalid_gaps = []
        max_size = 0
        dindex = 0
        datalen = len(all_data)
        while dindex < datalen:
            d = all_data[dindex]
            while d.is_valid and (dindex < datalen - 1):
                dindex += 1
                d = all_data[dindex]
            if not (d.is_valid):
                gap_start = d.timestamp
                while not (d.is_valid) and (dindex < datalen - 1):
                    dindex += 1
                    d = all_data[dindex]
                if d.timestamp - gap_start > max_size:
                    max_size = d.timestamp - gap_start
                if d.timestamp - gap_start > params.MAX_SEG_TIMEGAP:
                    self.time_gaps.append((gap_start, d.timestamp))
            dindex += 1
        return max_size


    def calc_blink_validity_gaps(self, all_data):
        """Calculates the blink validity gaps for this segment

        Args:
            all_data: The list of "Datapoint"s which make up this Segement

        Returns:
            An array for tuples (int, int) indicating beginning and end timestamps for each contiguous invalid group of rows
        """

        blinks_validity_gaps = []
        dindex = 0
        datalen = len(all_data)
        while dindex < datalen:
            d = all_data[dindex]
            while d.is_valid_blink and (dindex < datalen - 1):
                dindex += 1
                d = all_data[dindex]
            if not (d.is_valid_blink):
                gap_start = d.timestamp
                while not (d.is_valid_blink) and (dindex < datalen - 1):
                    dindex += 1
                    d = all_data[dindex]
                blinks_validity_gaps.append((gap_start, d.timestamp))
            dindex += 1
        return blinks_validity_gaps

    def getgaps(self):
        """Returns the list of invalid gaps > params.MAX_SEG_TIMEGAP for this Segment

        Args:
            a list of invalid gaps for this Segment
        """
        return self.time_gaps

    def getallgaps(self):
        """Returns the total length of all invalid gaps for this Segment

        Args:
            an integer: the length in ms of invalid points for this Segment
        """
        return self.all_invalid_gaps

    def get_length_invalid(self):
        """Returns the sum of the length of the invalid gaps > params.MAX_SEG_TIMEGAP

        Args:
            an integer, the length in milliseconds
        """
        length = 0
        for gap in self.getgaps():
            length += gap[1] - gap[0]
        return length

    def calc_validity_fixation(self, all_data):
        """Calculates the proportion of (valid + restored) "Datapoint"s over all "Datapoint"s of the Segment.

        Restored samples are the samples which are not valid but they are part of a Fixation.
        The idea is that if the user was looking at a certain point and then we loose the eye data for
        a short period of time and afterwards the user is looking at the same point we can assume that user
        was looking at that same point during that period.

        Args:
            all_data: The list of "Datapoint"s which make up this Segement

        Returns:
            A float indicating the proportion of (valid + restored) samples over all the samples in this Segment
        """
        if self.numfixations == 0:
            return 0.0
        num_valid = float(0)
        num = 0

        for d in all_data:
            #if d.stimuliname == 'ScreenRec':
            if d.stimuliname != '':
                num += 1
                if d.is_valid or d.fixationindex!=None:
                    num_valid += 1.0
#            else:
#                print "###",d.event, d.data1
        if num == 0:
            return 0.0
        else:
            return num_valid / num

    def calc_validity1(self, threshold = params.VALID_PROP_THRESH):
        """Returns a boolean indicating whether this Segment is valid using proportion of valid samples threshold

        Args:
            threshold: the minimum proportion of valid samples for a Segment or Scene to be
                considered valid. By default set to value VALID_PROP_THRESH from module params.py
        """
        return self.proportion_valid > threshold

    def calc_validity2(self, threshold = params.VALID_TIME_THRESH):
        """Returns a boolean indicating whether this Segment is valid using largest acceptable gap threshold
        """
        return self.largest_data_gap <= threshold


    def calc_validity3(self, threshold = params.VALID_PROP_THRESH):
        """Returns a boolean indicating whether this Segment is valid using proportion of (valid + restored) samples threshold
        """
        return self.proportion_valid_fix > threshold

    def get_validity(self):
        """Determines if this Segment is valid with the given validity method set in params.VALIDITY_METHOD

        Returns:
            A boolean indicating whether this Segment is valid
        """
        if params.VALIDITY_METHOD == 1:
            return self.validity1
        elif params.VALIDITY_METHOD == 2:
            return self.validity2
        elif params.VALIDITY_METHOD == 3:
            return self.validity3

    def calc_distances(self, fixdata):
        """returns the Euclidean distances between a sequence of "Fixation"s

        Args:
            fixdata: a list of "Fixation"s
        """
        distances = []
        lastx = fixdata[0].mappedfixationpointx
        lasty = fixdata[0].mappedfixationpointy

        for i in xrange(1, len(fixdata)):
            x = fixdata[i].mappedfixationpointx
            y = fixdata[i].mappedfixationpointy
            dist = math.sqrt((x - lastx)**2 + (y - lasty)**2)
            distances.append(dist)
            lastx = x
            lasty = y

        return distances

    def calc_abs_angles(self, fixdata):
        """returns the absolute angles between a sequence of "Fixation"s that build a scan path.

        Abosolute angle for each saccade is the angle between that saccade and the horizental axis

        Args:
            fixdata: a list of "Fixation"s

        Returns:
            a list of absolute angles for the saccades formed by the given sequence of "Fixation"s in Radiant
        """
        abs_angles = []
        lastx = fixdata[0].mappedfixationpointx
        lasty = fixdata[0].mappedfixationpointy

        for i in xrange(1,len(fixdata)):
            x = fixdata[i].mappedfixationpointx
            y = fixdata[i].mappedfixationpointy
            (dist, theta) = geometry.vector_difference((lastx,lasty), (x, y))
            abs_angles.append(abs(theta))
            lastx=x
            lasty=y

        return abs_angles

    def calc_rel_angles(self, fixdata):
        """returns the relative angles between a sequence of "Fixation"s that build a scan path in Radiant

        Relative angle for each saccade is the angle between that saccade and the previous saccade.

        Defined as: angle = acos(v1 dot v2)  such that v1 and v2 are normalized vector2coord

        Args:
            fixdata: a list of "Fixation"s

        Returns:
            a list of relative angles for the saccades formed by the given sequence of "Fixation"s in Radiant
        """
        rel_angles = []
        lastx = fixdata[0].mappedfixationpointx
        lasty = fixdata[0].mappedfixationpointy

        for i in xrange(1, len(fixdata) - 1):
            x = fixdata[i].mappedfixationpointx
            y = fixdata[i].mappedfixationpointy
            nextx = fixdata[i + 1].mappedfixationpointx
            nexty = fixdata[i + 1].mappedfixationpointy
            v1 = (lastx - x, lasty - y)
            v2 = (nextx - x, nexty - y)

            if v1 != (0.0, 0.0) and v2 != (0.0, 0.0):
                v1_dot = math.sqrt(geometry.simpledotproduct(v1, v1))
                v2_dot = math.sqrt(geometry.simpledotproduct(v2, v2))
                normv1 = ((lastx - x) / v1_dot, (lasty - y) / v1_dot)
                normv2 = ((nextx - x) / v2_dot, (nexty - y) / v2_dot)
                dotproduct = geometry.simpledotproduct(normv1, normv2)
                if dotproduct < -1:
                    dotproduct = -1.0
                if dotproduct > 1:
                    dotproduct = 1.0
                theta = math.acos(dotproduct)
                rel_angles.append(theta)
            else:
                rel_angles.append(0.0)
            lastx = x
            lasty = y

        return rel_angles

    def calc_num_samples(self, all_data):
        """Returns the number of samples in the Segment

        Args:
            all_data: a list of "Datapoint"s which make up this Segment.

        Returns:
            An integer determining the number of samples in the Segment

        """
        num = 0
        for d in all_data:
            if d.stimuliname != '':
                num += 1
        return num

    def generate_aoi_sequence(self, fixdata, aois):
        """returns the sequence of AOI's where "Fixation"s occurred
        Args:
            fixdata: a list of "Fixation"s
        Returns:
            a list of AOI names that correspond to the sequence of "Fixation" locations
        """
        sequence = []
        for fix in fixdata:
            for aoi in aois:
                if _fixation_inside_aoi(fix, aoi.polyin, aoi.polyout) and aoi.is_active(fix.timestamp, fix.timestamp) :
                    sequence.append(aoi.aid)
        return sequence

    def getid(self):
        """Returns the segid for this Segment

        Returns: a string conataining the segid for this Segment
        """
        return self.segid

    def get_features(self, featurelist = None, aoifeaturelist = None, aoifeaturelabels = None):
        """Returns feature names and their values for this Segment

        Args:
            featurelist: if not None, a list containing the name of features to be returned. If this is None all features will be returned
            aoifeaturelist: if not None, a list of features to be returned for each of the "AOI"s relevant to this Segment.
            aoifeaturelabels: if not None, a list of AOI related features to be returned.
            *Note: while aoifeaturelist is a subset of features that will be returned for all relevant "AOI"s, aoifeaturelabels contains
            the exact AOI feature name, i.e., a feature of the form: [AOI name]_[feature name]
            For example if an AOI called 'graph' is releveant to this Segment, aoifeaturelabels may contain 'graph_fixationrate'

        Returns:
            featnames: a list of feature names sorted alphabetically
            featvals: a corrsponding list of feature values
            e.g.
            featnames = ['fixationrate', 'length', 'meanabspathangles']
            featvals  = [0.00268522882294', '1529851', '1.60354714212']

        """
        if featurelist == []:
            featnames = []
        elif not featurelist:       #include all features
            featnames = self.features.keys()
        else:                       #a list of features was given
            featnames = []
            for name in featurelist:
                if name in self.features.keys():
                    featnames.append(name)
                else:
                    raise Exception('Segment %s has no such feature: %s'%(self.getid(),name))

        featnames.sort()

        featvals = map(lambda x: self.features[x], featnames)

        if self.has_aois:
            for aid, aoi in self.aoi_data.iteritems():
                if aoifeaturelabels:    #an exact list of aoifeatures was given
                    anames, avals = aoi.get_features()
                    anames = map(lambda x: '%s_%s'%(aid, x), anames)
                    featval = zip(anames,avals)
                    newfeatval = filter(lambda x: x[0] in aoifeaturelabels,featval)
                    anames = []
                    avals = []
                    for fn,fv in newfeatval:
                        anames.append(fn)
                        avals.append(fv)
                    if featnames:
                        featnames += anames
                        featvals += avals
                else:                   #a list of features for each AIO was given
                    anames, avals = aoi.get_features(aoifeaturelist)
                    anames = map(lambda x: '%s_%s'%(aid, x), anames)

                    featnames += anames
                    featvals += avals

        return featnames, featvals

    def print_(self):
        """Ourputs all feature names and their values for this Segment on the console
        """
        print("ID", self.getid())
        print("start",self.start)
        print("end",self.end)
        print("is_valid",self.is_valid)
        print
#        featurelist =["completion_time","numfixations","length","numsamples"]
#        if self.features['numfixations'] > 0:
#            featurelist.extend(["meanfixationduration","stddevfixationduration","sumfixationduration","fixationrate"])
#
#        featurelist.extend(["meanpathdistance","sumpathdistance","stddevpathdistance","sumabspathangles","meanabspathangles","stddevabspathangles","sumrelpathangles","meanrelpathangles","stddevrelpathangles"])

        fn,fv = self.get_features()
        for i in xrange(len(fn)):
            print(fn[i],':',fv[i])
        print
</code></pre>
  </div>

  </header>

  <section id="section-items">


    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="Segment.Segment" class="name">class <span class="ident">Segment</span></p>
      
  
    <div class="desc"><p>A Segment is a class that represents the smallest unit of aggregated eye data samples with a conceptual meaning.</p>
<p>A segment is the smallest unit of aggregated eye data samples that has conceptual meaning. This class is the equivalent
of segments as defined in Tobii studio.</p>
<p>Attributes:
    segid: A string containing the id of the Segment.
    alldata: A list of "Datapoint"s for this Segment
    features: A dict with feature names as its keys and feature values as its values
    completion_time: An integer indicating total duration of the Segment in milliseconds
        minimum is 16 ms (length of one sample with 60Hz sampling rate (ms))
    start: An integer indicating the Segment's start time in milliseconds
    end: An integer indicating the Segment's end time in milliseconds
    sample_start_ind: An integer indicating the index of the first Datapoint for this Segment in the Participant's list of all "Datapoint"s (all_data)
    sample_end_ind: An integer indicating the index of the last Datapoint for this Segment in the Participant's list of all "Datapoint"s (all_data)
    fixation_start_ind: An integer indicating the index of the first Fixation for this Segment in the Participant's list of all "Fixation"s (fixation_data)
    fixation_end_ind: An integer indicating the index of the last Fixation for this Segment in the Participant's list of all "Fixation"s (fixation_data)
    numfixations: An integer indicating the number of "Fixation"s in this Segment
    time_gaps: a list of tuples of the form (start, end) indicating the start and end of the gaps of invalid samples in the Segment's samples
    all_invalid_gaps: a list of tuples of the form (start, end) indicating the start and the end of all the gaps of invalid samples
    largest_data_gap: An integer indicating the length of largest invalid gap for this Segment in milliseconds
    proportion_valid: A float indicating the proportion of valid samples over all the samples in this Segment
    proportion_valid_fix: A float indicating the proportion of (valid + restored) samples over all the samples in this Segment
    validity1: a boolean indicating whether this Segment is valid using proportion of valid samples threshold
    validity2: a boolean indicating whether this Segment is valid using largest acceptable gap threshold
    validity3: a boolean indicating whether this Segment is valid using proportion of (valid + restored) samples threshold
    is_valid: a boolean indicating whether this Segment is considered valid by the validity method indicated by params.VALIDITY_METHOD
    length_invalid: An integer indicating total duration of invalid gaps in the segment in milliseconds
    length: An integer indicating total duration of the Segment in milliseconds
    numsamples: An integer indicating total number of samples in the Segment
    fixation_data: A list of "Fixation"s for this Segment
    fixation_start: timestamp of the first entry from list of "Fixation"s for this Segment
    fixation_end: timestamp of the last entry from list of "Fixation"s for this Segment
    aoi_data: A list of AOI_Stat objects for relevant "AOI"s for this Segment
    has_aois: A boolean indicating if this Segment has AOI features calculated for it</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Segment.Segment', this);">Show source &equiv;</a></p>
  <div id="source-Segment.Segment" class="source">
    <pre><code>class Segment():
    """A Segment is a class that represents the smallest unit of aggregated eye data samples with a conceptual meaning.

    A segment is the smallest unit of aggregated eye data samples that has conceptual meaning. This class is the equivalent
    of segments as defined in Tobii studio.

    Attributes:
        segid: A string containing the id of the Segment.
        alldata: A list of "Datapoint"s for this Segment
        features: A dict with feature names as its keys and feature values as its values
        completion_time: An integer indicating total duration of the Segment in milliseconds
            minimum is 16 ms (length of one sample with 60Hz sampling rate (ms))
        start: An integer indicating the Segment's start time in milliseconds
        end: An integer indicating the Segment's end time in milliseconds
        sample_start_ind: An integer indicating the index of the first Datapoint for this Segment in the Participant's list of all "Datapoint"s (all_data)
        sample_end_ind: An integer indicating the index of the last Datapoint for this Segment in the Participant's list of all "Datapoint"s (all_data)
        fixation_start_ind: An integer indicating the index of the first Fixation for this Segment in the Participant's list of all "Fixation"s (fixation_data)
        fixation_end_ind: An integer indicating the index of the last Fixation for this Segment in the Participant's list of all "Fixation"s (fixation_data)
        numfixations: An integer indicating the number of "Fixation"s in this Segment
        time_gaps: a list of tuples of the form (start, end) indicating the start and end of the gaps of invalid samples in the Segment's samples
        all_invalid_gaps: a list of tuples of the form (start, end) indicating the start and the end of all the gaps of invalid samples
        largest_data_gap: An integer indicating the length of largest invalid gap for this Segment in milliseconds
        proportion_valid: A float indicating the proportion of valid samples over all the samples in this Segment
        proportion_valid_fix: A float indicating the proportion of (valid + restored) samples over all the samples in this Segment
        validity1: a boolean indicating whether this Segment is valid using proportion of valid samples threshold
        validity2: a boolean indicating whether this Segment is valid using largest acceptable gap threshold
        validity3: a boolean indicating whether this Segment is valid using proportion of (valid + restored) samples threshold
        is_valid: a boolean indicating whether this Segment is considered valid by the validity method indicated by params.VALIDITY_METHOD
        length_invalid: An integer indicating total duration of invalid gaps in the segment in milliseconds
        length: An integer indicating total duration of the Segment in milliseconds
        numsamples: An integer indicating total number of samples in the Segment
        fixation_data: A list of "Fixation"s for this Segment
        fixation_start: timestamp of the first entry from list of "Fixation"s for this Segment
        fixation_end: timestamp of the last entry from list of "Fixation"s for this Segment
        aoi_data: A list of AOI_Stat objects for relevant "AOI"s for this Segment
        has_aois: A boolean indicating if this Segment has AOI features calculated for it
    """
    def __init__(self, segid, all_data, fixation_data, saccade_data = None, event_data = None, aois = None, prune_length = None, rest_pupil_size = 0, export_pupilinfo = False):
        """
        Args:
            segid: A string containing the id of the Segment.

            all_data: a list of "Datapoint"s which make up this Segment.

            fixation_data: a list of "Fixation"s which make up this Segment.

            saccade_data: a list of "Saccade"s which make up this Segment (None if no saccades).

            event_data: a list of "Event"s which make up this Segment (None if no events).

            aois: a list of "AOI"s relevant to this Segment.

            prune_length: If not None, an integer that specifies the time interval (in ms) from the beginning of each segment in which
                samples are considered in calculations.  This can be used if, for example, you only wish to consider data in the first
                1000 ms of each segment. In this case (prune_length = 1000), all data beyond the first 1000ms of the start of the segments
                will be disregarded.

            rest_pupil_size: rest pupil size for this segment, used to adjust pupil size.

            export_pupilinfo: True to export raw pupil data in EMDAT output (False by default).

        Yields:
            a Segment object
        """
        self.segid = segid
        #self.all_data = all_data
        #self.fixation_data = fixation_data
        #self.saccade_data = saccade_data
        #self.event_data = event_data
        self.features = {}

        """ If prune_length specified, keep only data from start to start + prune_length
            of the segment
        """
        if prune_length:
            all_data = filter(lambda x: x.timestamp <= self.start + prune_length, all_data)
            fixation_data = filter(lambda x: x.timestamp <= self.start + prune_length, fixation_data)
            if event_data != None:
                event_data = filter(lambda x: x.timestamp <= self.start + prune_length, event_data)
            if saccade_data != None:
                saccade_data = filter(lambda x: x.timestamp <= self.start + prune_length, saccade_data)
                
        self.completion_time = all_data[-1].timestamp - all_data[0].timestamp
        if self.completion_time == 0:
            raise Exception("Zero length segment")

        self.features['completion_time'] = self.completion_time
        self.start = all_data[0].timestamp
        self.numfixations = len(fixation_data)

        """ Validity-related features, determining if the segment is valid """
        self.time_gaps = []
        self.all_invalid_gaps = []
        self.largest_data_gap = self.calc_largest_validity_gap(all_data)
        self.proportion_valid = self.calc_validity_proportion(all_data)
        self.proportion_valid_fix = self.calc_validity_fixation(all_data)
        self.validity1 = self.calc_validity1()
        self.validity2 = self.calc_validity2()
        self.validity3 = self.calc_validity3()
        self.is_valid = self.get_validity()
        self.length_invalid = self.get_length_invalid()

        self.end = all_data[-1].timestamp
        self.length = self.end - self.start
        self.features['length'] = self.end - self.start
        self.features['length_invalid'] = self.length_invalid
        self.numsamples = self.calc_num_samples(all_data)
        self.features['numsamples'] = self.numsamples
        self.numfixations = len(fixation_data)
        self.features['numfixations'] = self.numfixations
        self.features['fixationrate'] = float(self.numfixations) / (self.length - self.length_invalid)

        """ calculate blink features (no rest pupil size adjustments yet)"""
        self.calc_blink_features(all_data)

        """ calculate pupil dilation features (no rest pupil size adjustments yet)"""
        self.calc_pupil_features(all_data, export_pupilinfo, rest_pupil_size)

        """ calculate distance from screen features"""
        self.calc_distance_features(all_data)

        """ calculate fixations, angles and path features"""
        self.calc_fix_ang_path_features(fixation_data)

        """ calculate saccades features if available """
        self.calc_saccade_features(saccade_data)

        """ calculate event features if available """
        self.calc_event_features(event_data)

        """ calculate AOIs features """
        self.has_aois = False
        if aois:
            self.set_aois(aois, all_data, fixation_data, event_data, rest_pupil_size, export_pupilinfo)
            self.features['aoisequence'] = self.generate_aoi_sequence(fixation_data, aois)


    def set_indices(self,sample_st,sample_end,fix_st,fix_end,sac_st=None,sac_end=None,event_st=None,event_end=None):
        """Sets the index features

        Args:
            sample_st: An integer indicating the index of the first Datapoint for this Segment in the Participant's list of all "Datapoint"s (all_data)
            sample_end: An integer indicating the index of the last Datapoint for this Segment in the Participant's list of all "Datapoint"s (all_data)
            fix_st: An integer indicating the index of the first Fixation for this Segment in the Participant's list of all "Fixation"s (fixation_data)
            fix_end: An integer indicating the index of the last Fixation for this Segment in the Participant's list of all "Fixation"s (fixation_data)
            sac_st: An integer indicating the index of the first Saccade for this Segment in the Participant's list of all "Saccade"s (saccade_data)
            sac_end: An integer indicating the index of the last Saccade for this Segment in the Participant's list of all "Saccade"s (saccade_data)
            event_st: An integer indicating the index of the first Event for this Segment in the Participant's list of all "Event"s (event_data)
            event_end: An integer indicating the index of the last Event for this Segment in the Participant's list of all "Event"s (event_data)
        """
        self.sample_start_ind = sample_st
        self.sample_end_ind = sample_end
        self.fixation_start_ind = fix_st
        self.fixation_end_ind = fix_end
        self.saccade_start_ind = sac_st
        self.saccade_end_ind = sac_end
        self.event_start_ind = event_st
        self.event_end_ind = event_end


    def get_indices(self):
        """Returns the index features

        Returns:
            An integer indicating the index of the first Datapoint for this Segment in the Participant's list of all "Datapoint"s (all_data)
            An integer indicating the index of the last Datapoint for this Segment in the Participant's list of all "Datapoint"s (all_data)
            An integer indicating the index of the first Fixation for this Segment in the Participant's list of all "Fixation"s (fixation_data)
            An integer indicating the index of the last Fixation for this Segment in the Participant's list of all "Fixation"s (fixation_data)
            An integer indicating the index of the first Saccade for this Segment in the Participant's list of all "Saccade"s (saccade_data). None if no saccade.
            An integer indicating the index of the last Saccade for this Segment in the Participant's list of all "Saccade"s (saccade_data). None if no saccade.
            An integer indicating the index of the first Event for this Segment in the Participant's list of all "Event"s (event_data). None if no saccade.
            An integer indicating the index of the last Event for this Segment in the Participant's list of all "Event"s (event_data). None if no saccade.
        Raises:
            Exception: An exception is thrown if the values are read before initialization
        """
        if self.sample_start_ind != None:
            return self.sample_start_ind, self.sample_end_ind, self.fixation_start_ind, \
                self.fixation_end_ind, self.saccade_start_ind, self.saccade_end_ind, self.event_start_ind, self.event_end_ind
        raise Exception ('The indices values are accessed before setting the initial value in segement:'+self.segid+'!')


    def set_aois(self, aois, all_data, fixation_data, event_data = None, rest_pupil_size = 0, export_pupilinfo = False):
        """Sets the relevant "AOI"s for this Segment

        Args:
            all_data: a list of "Datapoint"s which make up this Segment
            fixation_data: The list of "Fixation"s which make up this Segment
            aois: a list of "AOI"s relevant to this Segment
            rest_pupil_size:
        """

        if len(aois) == 0:
            warn("No AOIs passed to segment:"+self.segid)
        active_aois=[]
        self.aoi_data = {}
        for aoi in aois:
            #print "checking:",aoi.aid
            print("Generating features for %s AOI in segment %s" % (aoi.aid, self.segid))
            aoistat = AOI_Stat(aoi, all_data, fixation_data, self.start, self.end, self.length_invalid, aois, event_data, rest_pupil_size, export_pupilinfo)
            self.aoi_data[aoi.aid] = aoistat

            act, _ = aoi.is_active_partition(self.fixation_start, self.fixation_end)
            if act:
                active_aois.append(aoi)
                self.has_aois = True
        print("SEGMENT: active aois in this segment: %d" % len(active_aois))
        if not(active_aois):
            msg = "No active AOIs passed to segment:%s start:%d end:%d" %(self.segid,self.start,self.end)
            warn(msg)

    def calc_blink_features(self, all_data):
        """ Calculates blink features such as
                blink_num:                 number of blinks on the in the segment
                blink_duration_total:       sum of the blink durations for this segment
                blink_duration_mean:        mean of the blink durations for this segment
                blink_duration_std:         standard deviation of blink durations for this segment
                blink_duration_max:         maximal blink duration for this segment
                blink_duration_min:         minimal blink duration for this segment
                blink_rate:                 rate of blinks for this segment
                blink_time_distance_mean:   mean time difference between consequtive blinks
                blink_time_distance_std:    std time difference between consequtive blinks
                blink_time_distance_min:    minimal time difference between consequtive blinks
                blink_time_distance_max:    maximal time difference between consequtive blinks
            Args:
                all_data: The list of "Datapoint"s which make up this Segment
        """
        blink_durations = []
        blink_intervals = []
        last_blink_detected = -1
        self.features['blinknum']               = 0
        self.features['blinkdurationtotal']     = 0
        self.features['blinkdurationmean']      = 0
        self.features['blinkdurationstd']       = 0
        self.features['blinkdurationmin']       = -1
        self.features['blinkdurationmax']       = -1
        self.features['blinkrate']              = -1
        self.features['blinktimedistancemean']  = -1
        self.features['blinktimedistancestd']   = -1
        self.features['blinktimedistancemin']   = -1
        self.features['blinktimedistancemax']   = -1
        lower_bound, upper_bould = params.blink_threshold
        ### File operations are for testing
        #file = open('outputfolder/blinks/blinks_%s.txt' % all_data[0].participant_name, 'w
        blinks_validity_gaps = self.calc_blink_validity_gaps(all_data)
        if params.EYETRACKERTYPE == "SMI":
            for i in range(len(blinks_validity_gaps)):
                blink_length = blinks_validity_gaps[i][1] - blinks_validity_gaps[i][0]
                blink_durations.append(blink_length)
                #file.write('Blink start, end: %d %d\n' % (self.time_gaps[i][0], self.time_gaps[i][1]))
                if last_blink_detected != -1:
                    # Calculate time difference between start of current blink and end of previous blink
                    blink_intervals.append(blinks_validity_gaps[i][0] - blinks_validity_gaps[last_blink_detected][1])
                last_blink_detected = i
        else:
            for i in range(len(blinks_validity_gaps)):
                blink_length = blinks_validity_gaps[i][1] - blinks_validity_gaps[i][0]
                if blink_length <= upper_bould and blink_length >= lower_bound:
                    blink_durations.append(blink_length)
                    #file.write('Blink start, end: %d %d\n' % (self.time_gaps[i][0], self.time_gaps[i][1]))
                    if last_blink_detected != -1:
                        # Calculate time difference between start of current blink and end of previous blink
                        blink_intervals.append(blinks_validity_gaps[i][0] - blinks_validity_gaps[last_blink_detected][1])
                    last_blink_detected = i

        #file.close()
        if len(blink_durations) > 0:
            self.features['blinknum']               = len(blink_durations)
            self.features['blinkdurationtotal']     = sum(blink_durations)
            self.features['blinkdurationmean']      = mean(blink_durations)
            self.features['blinkdurationstd']       = stddev(blink_durations)
            self.features['blinkdurationmin']       = min(blink_durations)
            self.features['blinkdurationmax']       = max(blink_durations)
            self.features['blinkrate']              = float(self.features['blinknum']) / (self.length - self.length_invalid)
        if len(blink_intervals) > 0:
            self.features['blinktimedistancemean']  = mean(blink_intervals)
            self.features['blinktimedistancestd']   = stddev(blink_intervals)
            self.features['blinktimedistancemin']   = min(blink_intervals)
            self.features['blinktimedistancemax']   = max(blink_intervals)


    def calc_pupil_features(self, all_data, export_pupilinfo, rest_pupil_size):
        """ Calculates pupil features such as
                mean_pupil_size:            mean of pupil sizes
                stddev_pupil_size:          standard deviation of pupil sizes
                min_pupil_size:             smallest pupil size in this segment
                max_pupil_size:             largest pupil size in this segment
                mean_pupil_velocity:        mean of pupil velocities
                stddev_pupil_velocity:      standard deviation of pupil velocities
                min_pupil_velocity:         smallest pupil velocity in this segment
                max_pupil_velocity:         largest pupil velocity in this segment

            Args:
                all_data: The list of "Datapoint"s which make up this Segment
        """
        # check if pupil sizes are available for all missing points
        pupil_invalid_data = filter(lambda x: x.pupilsize == -1 and x.gazepointx > 0, all_data)
        if len(pupil_invalid_data) > 0:
            if params.DEBUG:
                raise Exception("Pupil size is unavailable for a valid data sample. \
                        Number of missing points: " + str(len(pupil_invalid_data)))
            else:
                warn("Pupil size is unavailable for a valid data sample. Number of missing points: " + str(len(pupil_invalid_data)) )

		#get all pupil sizes (valid + invalid)
        #pupilsizes = map(lambda x: x.pupilsize, all_data)
        #get all datapoints where pupil size is available
        valid_pupil_data = filter(lambda x: x.pupilsize > 0, all_data)
        valid_pupil_velocity = filter(lambda x: x.pupilvelocity != -1, all_data)

        #number of valid pupil sizes
        self.features['meanpupilsize']       = -1
        self.features['stddevpupilsize']     = -1
        self.features['maxpupilsize']        = -1
        self.features['minpupilsize']        = -1
        self.features['startpupilsize']      = -1
        self.features['endpupilsize']        = -1
        self.features['meanpupilvelocity']   = -1
        self.features['stddevpupilvelocity'] = -1
        self.features['maxpupilvelocity']    = -1
        self.features['minpupilvelocity']    = -1
        self.numpupilsizes                   = len(valid_pupil_data)
        self.numpupilvelocity                = len(valid_pupil_velocity)

        if self.numpupilsizes > 0: #check if the current segment has pupil data available
            if params.PUPIL_ADJUSTMENT == "rpscenter":
                adjvalidpupilsizes = map(lambda x: x.pupilsize - rest_pupil_size, valid_pupil_data)
            elif params.PUPIL_ADJUSTMENT == "PCPS":
                adjvalidpupilsizes = map(lambda x: (x.pupilsize - rest_pupil_size) / (1.0 * rest_pupil_size), valid_pupil_data)
            else:
                adjvalidpupilsizes = map(lambda x: x.pupilsize, valid_pupil_data)#valid_pupil_data

            valid_pupil_velocity = map(lambda x: x.pupilvelocity, valid_pupil_velocity)#valid_pupil_data

            if export_pupilinfo:
                self.pupilinfo_for_export = map(lambda x: [x.timestamp, x.pupilsize, rest_pupil_size], valid_pupil_data)
            self.features['meanpupilsize']           = mean(adjvalidpupilsizes)
            self.features['stddevpupilsize']         = stddev(adjvalidpupilsizes)
            self.features['maxpupilsize']            = max(adjvalidpupilsizes)
            self.features['minpupilsize']            = min(adjvalidpupilsizes)
            self.features['startpupilsize']          = adjvalidpupilsizes[0]
            self.features['endpupilsize']            = adjvalidpupilsizes[-1]

            if len(valid_pupil_velocity) > 0:
                self.features['meanpupilvelocity']   = mean(valid_pupil_velocity)
                self.features['stddevpupilvelocity'] = stddev(valid_pupil_velocity)
                self.features['maxpupilvelocity']    = max(valid_pupil_velocity)
                self.features['minpupilvelocity']    = min(valid_pupil_velocity)

    def calc_distance_features(self, all_data):
        """ Calculates distance features such as
                mean_distance:            mean of distances from the screen
                stddev_distance:          standard deviation of distances from the screen
                min_distance:             smallest distance from the screen in this segment
                max_distance:             largest distance from the screen in this segment
                start_distance:           distance from the screen in the beginning of this segment
                end_distance:             distance from the screen in the end of this segment

            Args:
                all_data: The list of "Datapoint"s which make up this Segment
        """
        # check if distances are available for all missing points
        invalid_distance_data = filter(lambda x: x.distance <= 0 and x.gazepointx >= 0, all_data)
        if len(invalid_distance_data) > 0:
            warn("Distance from screen is unavailable for a valid data sample. \
                        Number of missing points: " + str(len(invalid_distance_data)))

        #get all datapoints where distance is available
        valid_distance_data = filter(lambda x: x.distance > 0, all_data)

        #number of valid distance datapoints
        self.numdistancedata = len(valid_distance_data)
        if self.numdistancedata > 0: #check if the current segment has pupil data available
            distances_from_screen               = map(lambda x: x.distance, valid_distance_data)
            self.features['meandistance']       = mean(distances_from_screen)
            self.features['stddevdistance']     = stddev(distances_from_screen)
            self.features['maxdistance']        = max(distances_from_screen)
            self.features['mindistance']        = min(distances_from_screen)
            self.features['startdistance']      = distances_from_screen[0]
            self.features['enddistance']        = distances_from_screen[-1]
        else:
            self.features['meandistance']       = -1
            self.features['stddevdistance']     = -1
            self.features['maxdistance']        = -1
            self.features['mindistance']        = -1
            self.features['startdistance']      = -1
            self.features['enddistance']        = -1


    def calc_saccade_features(self, saccade_data):
        """ Calculates saccade features such as
                numsaccades:              number of saccades in the segment
                sumsaccadedistance:       sum of distances during each saccade
                meansaccadedistance:      mean of distances during each saccade
                stddevsaccadedistance:    standard deviation of distances during each saccade
                longestsaccadedistance:   distance of longest saccade
                sumsaccadeduration:       total time spent on saccades in this segment
                meansaccadeduration:      average saccade duration
                stddevsaccadeduration:    standard deviation of saccade durations
                longestsaccadeduration:   longest duration of saccades in this segment
                meansaccadespeed:         average speed of saccades in this segment
                stddevsaccadespeed:       standard deviation of speed of saccades in this segment
                maxsaccadespeed:          highest saccade speed in this segment
                minsaccadespeed:          lowest saccade speed in this  segment
                fixationsaccadetimeratio: fixation to saccade time ratio for this segment
            Args:
                saccade_data: The list of saccade datapoints for this Segment
        """
        if saccade_data != None and len(saccade_data) > 0:
            self.numsaccades = len(saccade_data)
            self.features['numsaccades'] = self.numsaccades
            self.features['sumsaccadedistance'] = sum(map(lambda x: float(x.saccadedistance), saccade_data))
            self.features['meansaccadedistance'] = mean(map(lambda x: float(x.saccadedistance), saccade_data))
            self.features['stddevsaccadedistance'] = stddev(map(lambda x: float(x.saccadedistance), saccade_data))
            self.features['longestsaccadedistance'] = max(map(lambda x: float(x.saccadedistance), saccade_data))
            self.features['sumsaccadeduration'] = sum(map(lambda x: float(x.saccadeduration), saccade_data))
            self.features['meansaccadeduration'] = mean(map(lambda x: float(x.saccadeduration), saccade_data))
            self.features['stddevsaccadeduration'] = stddev(map(lambda x: float(x.saccadeduration), saccade_data))
            self.features['longestsaccadeduration'] = max(map(lambda x: float(x.saccadeduration), saccade_data))
            self.features['meansaccadespeed'] = mean(map(lambda x: float(x.saccadespeed), saccade_data))
            self.features['stddevsaccadespeed'] = stddev(map(lambda x: float(x.saccadespeed), saccade_data))
            self.features['maxsaccadespeed'] = max(map(lambda x: float(x.saccadespeed), saccade_data))
            self.features['minsaccadespeed'] = min(map(lambda x: float(x.saccadespeed), saccade_data))
            self.features['fixationsaccadetimeratio'] = float(self.features['sumfixationduration']) / self.features['sumsaccadeduration']
        else:
            self.numsaccades = 0
            self.features['numsaccades'] = 0
            self.features['sumsaccadedistance'] = -1
            self.features['meansaccadedistance'] = -1
            self.features['stddevsaccadedistance'] = -1
            self.features['longestsaccadedistance'] = -1
            self.features['sumsaccadeduration'] = -1
            self.features['meansaccadeduration'] = -1
            self.features['stddevsaccadeduration'] = -1
            self.features['longestsaccadeduration'] = -1
            self.features['meansaccadespeed'] = -1
            self.features['stddevsaccadespeed'] = -1
            self.features['maxsaccadespeed'] = -1
            self.features['minsaccadespeed'] = -1
            self.features['fixationsaccadetimeratio'] = -1


    def calc_fix_ang_path_features(self, fixation_data):
        """ Calculates fixation, angle and path features such as
                meanfixationduration:     mean duration of fixations in the segment
                stddevfixationduration    standard deviation of duration of fixations in the segment
                sumfixationduration:      sum of durations of fixations in the segment
                fixationrate:             rate of fixation datapoints relative to all datapoints in this segment
                meanpathdistance:         mean of path distances for this segment
                sumpathdistance:          sum of path distances for this segment
                eyemovementvelocity:      average eye movement velocity for this segment
                sumabspathangles:         sum of absolute path angles for this segment
                abspathanglesrate:        ratio of absolute path angles relative to all datapoints in this segment
                stddevabspathangles:      standard deviation of absolute path angles for this segment
                sumrelpathangles:         sum of relative path angles for this segment
                relpathanglesrate:        ratio of relative path angles relative to all datapoints in this segment
                stddevrelpathangles:      standard deviation of relative path angles for this segment
            Args:
                saccade_data: The list of saccade datapoints for this Segment
        """
        if self.numfixations > 0:
            self.fixation_start = fixation_data[0].timestamp
            self.fixation_end = fixation_data[-1].timestamp
            self.features['meanfixationduration'] = mean(map(lambda x: float(x.fixationduration), fixation_data))
            self.features['stddevfixationduration'] = stddev(map(lambda x: float(x.fixationduration), fixation_data))
            self.features['sumfixationduration'] = sum(map(lambda x: x.fixationduration, fixation_data))
            self.features['fixationrate'] = float(self.numfixations) / (self.length - self.length_invalid)
            distances = self.calc_distances(fixation_data)
            abs_angles = self.calc_abs_angles(fixation_data)
            rel_angles = self.calc_rel_angles(fixation_data)
        else:
            self.fixation_start = -1
            self.fixation_end = -1
            self.features['meanfixationduration'] = -1
            self.features['stddevfixationduration'] = -1
            self.features['sumfixationduration'] = -1
            self.features['fixationrate'] = -1

        self.numfixdistances = len(distances)
        self.numabsangles = len(abs_angles)
        self.numrelangles = len(rel_angles)
        if len(distances) > 0:
            self.features['meanpathdistance'] = mean(distances)
            self.features['sumpathdistance'] = sum(distances)
            self.features['stddevpathdistance'] = stddev(distances)
            self.features['eyemovementvelocity'] = self.features['sumpathdistance']/(self.length - self.length_invalid)
            self.features['sumabspathangles'] = sum(abs_angles)
            self.features['abspathanglesrate'] = sum(abs_angles)/(self.length - self.length_invalid)
            self.features['meanabspathangles'] = mean(abs_angles)
            self.features['stddevabspathangles'] = stddev(abs_angles)
            self.features['sumrelpathangles'] = sum(rel_angles)
            self.features['relpathanglesrate'] = sum(rel_angles)/(self.length - self.length_invalid)
            self.features['meanrelpathangles'] = mean(rel_angles)
            self.features['stddevrelpathangles'] = stddev(rel_angles)
        else:
            self.features['meanpathdistance'] = -1
            self.features['sumpathdistance'] = -1
            self.features['stddevpathdistance'] = -1
            self.features['eyemovementvelocity'] = -1
            self.features['sumabspathangles'] = -1
            self.features['abspathanglesrate'] = -1
            self.features['meanabspathangles'] = -1
            self.features['stddevabspathangles'] = -1
            self.features['sumrelpathangles'] = -1
            self.features['relpathanglesrate'] = -1
            self.features['meanrelpathangles'] = -1
            self.features['stddevrelpathangles'] = -1


    def calc_event_features(self, event_data):
        """ Calculates event features such as
                numevents:                number of events in the segment
                numleftclic:              number of left clinks in the segment
                numrightclic:             number of right clinks in the segment
                numdoubleclic:            number of double clinks in the segment
                numkeypressed:            number of times a key was pressed in the segment
                leftclicrate:             the rate of left clicks (relative to all datapoints) in this segment
                rightclicrate:            the rate of right clicks (relative to all datapoints) in this segment
                doubleclicrate:           the rate of double clicks (relative to all datapoints) in this segment
                keypressedrate:           the rate of key presses (relative to all datapoints) in this segment
                timetofirstleftclic:      time until the first left click in this segment
                timetofirstrightclic:     time until the first right click in this segment
                timetofirstdoubleclic:    time until the first double click in this segment
                timetofirstkeypressed:    time until the first key pressed in this segment
            Args:
                event_data: The list of events for this Segment
        """
        if event_data != None:
            (leftc, rightc, doublec, keyp) = generate_event_lists(event_data)

            self.numevents = len(leftc)+len(rightc)+len(doublec)+len(keyp)
            self.features['numevents'] = self.numevents
            self.features['numleftclic'] = len(leftc)
            self.features['numrightclic'] = len(rightc)
            self.features['numdoubleclic'] = len(doublec)
            self.features['numkeypressed'] = len(keyp)
            self.features['leftclicrate'] = float(len(leftc))/(self.length - self.length_invalid)
            self.features['rightclicrate'] = float(len(rightc))/(self.length - self.length_invalid)
            self.features['doubleclicrate'] = float(len(doublec))/(self.length - self.length_invalid)
            self.features['keypressedrate'] = float(len(keyp))/(self.length - self.length_invalid)
            self.features['timetofirstleftclic'] = leftc[0].timestamp if len(leftc) > 0 else -1
            self.features['timetofirstrightclic'] = rightc[0].timestamp if len(rightc) > 0 else -1
            self.features['timetofirstdoubleclic'] = doublec[0].timestamp if len(doublec) > 0 else -1
            self.features['timetofirstkeypressed'] = keyp[0].timestamp if len(keyp) > 0 else -1
        else:
            self.features['numevents'] = 0
            self.features['numleftclic'] = 0
            self.features['numrightclic'] = 0
            self.features['numdoubleclic'] = 0
            self.features['numkeypressed'] = 0
            self.features['leftclicrate'] = -1
            self.features['rightclicrate'] = -1
            self.features['doubleclicrate'] = -1
            self.features['keypressedrate'] = -1
            self.features['timetofirstleftclic'] = -1
            self.features['timetofirstrightclic'] = -1
            self.features['timetofirstdoubleclic'] = -1
            self.features['timetofirstkeypressed'] = -1


    def calc_validity_proportion(self, all_data):
        """Calculates the proportion of "Datapoint"s which are valid.

        Args:
            all_data: The list of "Datapoint"s which make up this Segment

        Returns:
            A float indicating the proportion of valid samples over all the samples in this Segment
        """
        num_valid = float(0)
        num = 0

        for d in all_data:
            #if d.stimuliname == 'ScreenRec':
            #if d.stimuliname == 'Screen Recordings (1)'
            if d.stimuliname != '':
                num += 1
                if d.is_valid:
                    num_valid += 1
#            else:
#                print "###",d.event, d.data1
        if num == 0:
            return 0.0
        else:
            return num_valid / num


    def calc_largest_validity_gap(self, all_data):
        """Calculates the largest gap of invalid samples in the "Datapoint"s for this Segment.

        Args:
            all_data: The list of "Datapoint"s which make up this Segement

        Returns:
            An integer indicating the length of largest invalid gap for this Segment in milliseconds
        """
        if self.numfixations == 0:
            return all_data[-1].timestamp - all_data[0].timestamp
        self.time_gaps = []
        self.all_invalid_gaps = []
        max_size = 0
        dindex = 0
        datalen = len(all_data)
        while dindex < datalen:
            d = all_data[dindex]
            while d.is_valid and (dindex < datalen - 1):
                dindex += 1
                d = all_data[dindex]
            if not (d.is_valid):
                gap_start = d.timestamp
                while not (d.is_valid) and (dindex < datalen - 1):
                    dindex += 1
                    d = all_data[dindex]
                if d.timestamp - gap_start > max_size:
                    max_size = d.timestamp - gap_start
                if d.timestamp - gap_start > params.MAX_SEG_TIMEGAP:
                    self.time_gaps.append((gap_start, d.timestamp))
            dindex += 1
        return max_size


    def calc_blink_validity_gaps(self, all_data):
        """Calculates the blink validity gaps for this segment

        Args:
            all_data: The list of "Datapoint"s which make up this Segement

        Returns:
            An array for tuples (int, int) indicating beginning and end timestamps for each contiguous invalid group of rows
        """

        blinks_validity_gaps = []
        dindex = 0
        datalen = len(all_data)
        while dindex < datalen:
            d = all_data[dindex]
            while d.is_valid_blink and (dindex < datalen - 1):
                dindex += 1
                d = all_data[dindex]
            if not (d.is_valid_blink):
                gap_start = d.timestamp
                while not (d.is_valid_blink) and (dindex < datalen - 1):
                    dindex += 1
                    d = all_data[dindex]
                blinks_validity_gaps.append((gap_start, d.timestamp))
            dindex += 1
        return blinks_validity_gaps

    def getgaps(self):
        """Returns the list of invalid gaps > params.MAX_SEG_TIMEGAP for this Segment

        Args:
            a list of invalid gaps for this Segment
        """
        return self.time_gaps

    def getallgaps(self):
        """Returns the total length of all invalid gaps for this Segment

        Args:
            an integer: the length in ms of invalid points for this Segment
        """
        return self.all_invalid_gaps

    def get_length_invalid(self):
        """Returns the sum of the length of the invalid gaps > params.MAX_SEG_TIMEGAP

        Args:
            an integer, the length in milliseconds
        """
        length = 0
        for gap in self.getgaps():
            length += gap[1] - gap[0]
        return length

    def calc_validity_fixation(self, all_data):
        """Calculates the proportion of (valid + restored) "Datapoint"s over all "Datapoint"s of the Segment.

        Restored samples are the samples which are not valid but they are part of a Fixation.
        The idea is that if the user was looking at a certain point and then we loose the eye data for
        a short period of time and afterwards the user is looking at the same point we can assume that user
        was looking at that same point during that period.

        Args:
            all_data: The list of "Datapoint"s which make up this Segement

        Returns:
            A float indicating the proportion of (valid + restored) samples over all the samples in this Segment
        """
        if self.numfixations == 0:
            return 0.0
        num_valid = float(0)
        num = 0

        for d in all_data:
            #if d.stimuliname == 'ScreenRec':
            if d.stimuliname != '':
                num += 1
                if d.is_valid or d.fixationindex!=None:
                    num_valid += 1.0
#            else:
#                print "###",d.event, d.data1
        if num == 0:
            return 0.0
        else:
            return num_valid / num

    def calc_validity1(self, threshold = params.VALID_PROP_THRESH):
        """Returns a boolean indicating whether this Segment is valid using proportion of valid samples threshold

        Args:
            threshold: the minimum proportion of valid samples for a Segment or Scene to be
                considered valid. By default set to value VALID_PROP_THRESH from module params.py
        """
        return self.proportion_valid > threshold

    def calc_validity2(self, threshold = params.VALID_TIME_THRESH):
        """Returns a boolean indicating whether this Segment is valid using largest acceptable gap threshold
        """
        return self.largest_data_gap <= threshold


    def calc_validity3(self, threshold = params.VALID_PROP_THRESH):
        """Returns a boolean indicating whether this Segment is valid using proportion of (valid + restored) samples threshold
        """
        return self.proportion_valid_fix > threshold

    def get_validity(self):
        """Determines if this Segment is valid with the given validity method set in params.VALIDITY_METHOD

        Returns:
            A boolean indicating whether this Segment is valid
        """
        if params.VALIDITY_METHOD == 1:
            return self.validity1
        elif params.VALIDITY_METHOD == 2:
            return self.validity2
        elif params.VALIDITY_METHOD == 3:
            return self.validity3

    def calc_distances(self, fixdata):
        """returns the Euclidean distances between a sequence of "Fixation"s

        Args:
            fixdata: a list of "Fixation"s
        """
        distances = []
        lastx = fixdata[0].mappedfixationpointx
        lasty = fixdata[0].mappedfixationpointy

        for i in xrange(1, len(fixdata)):
            x = fixdata[i].mappedfixationpointx
            y = fixdata[i].mappedfixationpointy
            dist = math.sqrt((x - lastx)**2 + (y - lasty)**2)
            distances.append(dist)
            lastx = x
            lasty = y

        return distances

    def calc_abs_angles(self, fixdata):
        """returns the absolute angles between a sequence of "Fixation"s that build a scan path.

        Abosolute angle for each saccade is the angle between that saccade and the horizental axis

        Args:
            fixdata: a list of "Fixation"s

        Returns:
            a list of absolute angles for the saccades formed by the given sequence of "Fixation"s in Radiant
        """
        abs_angles = []
        lastx = fixdata[0].mappedfixationpointx
        lasty = fixdata[0].mappedfixationpointy

        for i in xrange(1,len(fixdata)):
            x = fixdata[i].mappedfixationpointx
            y = fixdata[i].mappedfixationpointy
            (dist, theta) = geometry.vector_difference((lastx,lasty), (x, y))
            abs_angles.append(abs(theta))
            lastx=x
            lasty=y

        return abs_angles

    def calc_rel_angles(self, fixdata):
        """returns the relative angles between a sequence of "Fixation"s that build a scan path in Radiant

        Relative angle for each saccade is the angle between that saccade and the previous saccade.

        Defined as: angle = acos(v1 dot v2)  such that v1 and v2 are normalized vector2coord

        Args:
            fixdata: a list of "Fixation"s

        Returns:
            a list of relative angles for the saccades formed by the given sequence of "Fixation"s in Radiant
        """
        rel_angles = []
        lastx = fixdata[0].mappedfixationpointx
        lasty = fixdata[0].mappedfixationpointy

        for i in xrange(1, len(fixdata) - 1):
            x = fixdata[i].mappedfixationpointx
            y = fixdata[i].mappedfixationpointy
            nextx = fixdata[i + 1].mappedfixationpointx
            nexty = fixdata[i + 1].mappedfixationpointy
            v1 = (lastx - x, lasty - y)
            v2 = (nextx - x, nexty - y)

            if v1 != (0.0, 0.0) and v2 != (0.0, 0.0):
                v1_dot = math.sqrt(geometry.simpledotproduct(v1, v1))
                v2_dot = math.sqrt(geometry.simpledotproduct(v2, v2))
                normv1 = ((lastx - x) / v1_dot, (lasty - y) / v1_dot)
                normv2 = ((nextx - x) / v2_dot, (nexty - y) / v2_dot)
                dotproduct = geometry.simpledotproduct(normv1, normv2)
                if dotproduct < -1:
                    dotproduct = -1.0
                if dotproduct > 1:
                    dotproduct = 1.0
                theta = math.acos(dotproduct)
                rel_angles.append(theta)
            else:
                rel_angles.append(0.0)
            lastx = x
            lasty = y

        return rel_angles

    def calc_num_samples(self, all_data):
        """Returns the number of samples in the Segment

        Args:
            all_data: a list of "Datapoint"s which make up this Segment.

        Returns:
            An integer determining the number of samples in the Segment

        """
        num = 0
        for d in all_data:
            if d.stimuliname != '':
                num += 1
        return num

    def generate_aoi_sequence(self, fixdata, aois):
        """returns the sequence of AOI's where "Fixation"s occurred
        Args:
            fixdata: a list of "Fixation"s
        Returns:
            a list of AOI names that correspond to the sequence of "Fixation" locations
        """
        sequence = []
        for fix in fixdata:
            for aoi in aois:
                if _fixation_inside_aoi(fix, aoi.polyin, aoi.polyout) and aoi.is_active(fix.timestamp, fix.timestamp) :
                    sequence.append(aoi.aid)
        return sequence

    def getid(self):
        """Returns the segid for this Segment

        Returns: a string conataining the segid for this Segment
        """
        return self.segid

    def get_features(self, featurelist = None, aoifeaturelist = None, aoifeaturelabels = None):
        """Returns feature names and their values for this Segment

        Args:
            featurelist: if not None, a list containing the name of features to be returned. If this is None all features will be returned
            aoifeaturelist: if not None, a list of features to be returned for each of the "AOI"s relevant to this Segment.
            aoifeaturelabels: if not None, a list of AOI related features to be returned.
            *Note: while aoifeaturelist is a subset of features that will be returned for all relevant "AOI"s, aoifeaturelabels contains
            the exact AOI feature name, i.e., a feature of the form: [AOI name]_[feature name]
            For example if an AOI called 'graph' is releveant to this Segment, aoifeaturelabels may contain 'graph_fixationrate'

        Returns:
            featnames: a list of feature names sorted alphabetically
            featvals: a corrsponding list of feature values
            e.g.
            featnames = ['fixationrate', 'length', 'meanabspathangles']
            featvals  = [0.00268522882294', '1529851', '1.60354714212']

        """
        if featurelist == []:
            featnames = []
        elif not featurelist:       #include all features
            featnames = self.features.keys()
        else:                       #a list of features was given
            featnames = []
            for name in featurelist:
                if name in self.features.keys():
                    featnames.append(name)
                else:
                    raise Exception('Segment %s has no such feature: %s'%(self.getid(),name))

        featnames.sort()

        featvals = map(lambda x: self.features[x], featnames)

        if self.has_aois:
            for aid, aoi in self.aoi_data.iteritems():
                if aoifeaturelabels:    #an exact list of aoifeatures was given
                    anames, avals = aoi.get_features()
                    anames = map(lambda x: '%s_%s'%(aid, x), anames)
                    featval = zip(anames,avals)
                    newfeatval = filter(lambda x: x[0] in aoifeaturelabels,featval)
                    anames = []
                    avals = []
                    for fn,fv in newfeatval:
                        anames.append(fn)
                        avals.append(fv)
                    if featnames:
                        featnames += anames
                        featvals += avals
                else:                   #a list of features for each AIO was given
                    anames, avals = aoi.get_features(aoifeaturelist)
                    anames = map(lambda x: '%s_%s'%(aid, x), anames)

                    featnames += anames
                    featvals += avals

        return featnames, featvals

    def print_(self):
        """Ourputs all feature names and their values for this Segment on the console
        """
        print("ID", self.getid())
        print("start",self.start)
        print("end",self.end)
        print("is_valid",self.is_valid)
        print
#        featurelist =["completion_time","numfixations","length","numsamples"]
#        if self.features['numfixations'] > 0:
#            featurelist.extend(["meanfixationduration","stddevfixationduration","sumfixationduration","fixationrate"])
#
#        featurelist.extend(["meanpathdistance","sumpathdistance","stddevpathdistance","sumabspathangles","meanabspathangles","stddevabspathangles","sumrelpathangles","meanrelpathangles","stddevrelpathangles"])

        fn,fv = self.get_features()
        for i in xrange(len(fn)):
            print(fn[i],':',fv[i])
        print
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#Segment.Segment">Segment</a></li>
          </ul>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="Segment.Segment.all_invalid_gaps" class="name">var <span class="ident">all_invalid_gaps</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="Segment.Segment.completion_time" class="name">var <span class="ident">completion_time</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="Segment.Segment.end" class="name">var <span class="ident">end</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="Segment.Segment.features" class="name">var <span class="ident">features</span></p>
            

            
  
    <div class="desc"><p>If prune_length specified, keep only data from start to start + prune_length
of the segment</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="Segment.Segment.has_aois" class="name">var <span class="ident">has_aois</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="Segment.Segment.is_valid" class="name">var <span class="ident">is_valid</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="Segment.Segment.largest_data_gap" class="name">var <span class="ident">largest_data_gap</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="Segment.Segment.length" class="name">var <span class="ident">length</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="Segment.Segment.length_invalid" class="name">var <span class="ident">length_invalid</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="Segment.Segment.numfixations" class="name">var <span class="ident">numfixations</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="Segment.Segment.numsamples" class="name">var <span class="ident">numsamples</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="Segment.Segment.proportion_valid" class="name">var <span class="ident">proportion_valid</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="Segment.Segment.proportion_valid_fix" class="name">var <span class="ident">proportion_valid_fix</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="Segment.Segment.segid" class="name">var <span class="ident">segid</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="Segment.Segment.start" class="name">var <span class="ident">start</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="Segment.Segment.time_gaps" class="name">var <span class="ident">time_gaps</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="Segment.Segment.validity1" class="name">var <span class="ident">validity1</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="Segment.Segment.validity2" class="name">var <span class="ident">validity2</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="Segment.Segment.validity3" class="name">var <span class="ident">validity3</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="Segment.Segment.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, segid, all_data, fixation_data, saccade_data=None, event_data=None, aois=None, prune_length=None, rest_pupil_size=0, export_pupilinfo=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Args:
    segid: A string containing the id of the Segment.</p>
<pre><code>all_data: a list of "Datapoint"s which make up this Segment.

fixation_data: a list of "Fixation"s which make up this Segment.

saccade_data: a list of "Saccade"s which make up this Segment (None if no saccades).

event_data: a list of "Event"s which make up this Segment (None if no events).

aois: a list of "AOI"s relevant to this Segment.

prune_length: If not None, an integer that specifies the time interval (in ms) from the beginning of each segment in which
    samples are considered in calculations.  This can be used if, for example, you only wish to consider data in the first
    1000 ms of each segment. In this case (prune_length = 1000), all data beyond the first 1000ms of the start of the segments
    will be disregarded.

rest_pupil_size: rest pupil size for this segment, used to adjust pupil size.

export_pupilinfo: True to export raw pupil data in EMDAT output (False by default).
</code></pre>
<p>Yields:
    a Segment object</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Segment.Segment.__init__', this);">Show source &equiv;</a></p>
  <div id="source-Segment.Segment.__init__" class="source">
    <pre><code>def __init__(self, segid, all_data, fixation_data, saccade_data = None, event_data = None, aois = None, prune_length = None, rest_pupil_size = 0, export_pupilinfo = False):
    """
    Args:
        segid: A string containing the id of the Segment.
        all_data: a list of "Datapoint"s which make up this Segment.
        fixation_data: a list of "Fixation"s which make up this Segment.
        saccade_data: a list of "Saccade"s which make up this Segment (None if no saccades).
        event_data: a list of "Event"s which make up this Segment (None if no events).
        aois: a list of "AOI"s relevant to this Segment.
        prune_length: If not None, an integer that specifies the time interval (in ms) from the beginning of each segment in which
            samples are considered in calculations.  This can be used if, for example, you only wish to consider data in the first
            1000 ms of each segment. In this case (prune_length = 1000), all data beyond the first 1000ms of the start of the segments
            will be disregarded.
        rest_pupil_size: rest pupil size for this segment, used to adjust pupil size.
        export_pupilinfo: True to export raw pupil data in EMDAT output (False by default).
    Yields:
        a Segment object
    """
    self.segid = segid
    #self.all_data = all_data
    #self.fixation_data = fixation_data
    #self.saccade_data = saccade_data
    #self.event_data = event_data
    self.features = {}
    """ If prune_length specified, keep only data from start to start + prune_length
        of the segment
    """
    if prune_length:
        all_data = filter(lambda x: x.timestamp <= self.start + prune_length, all_data)
        fixation_data = filter(lambda x: x.timestamp <= self.start + prune_length, fixation_data)
        if event_data != None:
            event_data = filter(lambda x: x.timestamp <= self.start + prune_length, event_data)
        if saccade_data != None:
            saccade_data = filter(lambda x: x.timestamp <= self.start + prune_length, saccade_data)
            
    self.completion_time = all_data[-1].timestamp - all_data[0].timestamp
    if self.completion_time == 0:
        raise Exception("Zero length segment")
    self.features['completion_time'] = self.completion_time
    self.start = all_data[0].timestamp
    self.numfixations = len(fixation_data)
    """ Validity-related features, determining if the segment is valid """
    self.time_gaps = []
    self.all_invalid_gaps = []
    self.largest_data_gap = self.calc_largest_validity_gap(all_data)
    self.proportion_valid = self.calc_validity_proportion(all_data)
    self.proportion_valid_fix = self.calc_validity_fixation(all_data)
    self.validity1 = self.calc_validity1()
    self.validity2 = self.calc_validity2()
    self.validity3 = self.calc_validity3()
    self.is_valid = self.get_validity()
    self.length_invalid = self.get_length_invalid()
    self.end = all_data[-1].timestamp
    self.length = self.end - self.start
    self.features['length'] = self.end - self.start
    self.features['length_invalid'] = self.length_invalid
    self.numsamples = self.calc_num_samples(all_data)
    self.features['numsamples'] = self.numsamples
    self.numfixations = len(fixation_data)
    self.features['numfixations'] = self.numfixations
    self.features['fixationrate'] = float(self.numfixations) / (self.length - self.length_invalid)
    """ calculate blink features (no rest pupil size adjustments yet)"""
    self.calc_blink_features(all_data)
    """ calculate pupil dilation features (no rest pupil size adjustments yet)"""
    self.calc_pupil_features(all_data, export_pupilinfo, rest_pupil_size)
    """ calculate distance from screen features"""
    self.calc_distance_features(all_data)
    """ calculate fixations, angles and path features"""
    self.calc_fix_ang_path_features(fixation_data)
    """ calculate saccades features if available """
    self.calc_saccade_features(saccade_data)
    """ calculate event features if available """
    self.calc_event_features(event_data)
    """ calculate AOIs features """
    self.has_aois = False
    if aois:
        self.set_aois(aois, all_data, fixation_data, event_data, rest_pupil_size, export_pupilinfo)
        self.features['aoisequence'] = self.generate_aoi_sequence(fixation_data, aois)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Segment.Segment.calc_abs_angles">
    <p>def <span class="ident">calc_abs_angles</span>(</p><p>self, fixdata)</p>
    </div>
    

    
  
    <div class="desc"><p>returns the absolute angles between a sequence of "Fixation"s that build a scan path.</p>
<p>Abosolute angle for each saccade is the angle between that saccade and the horizental axis</p>
<p>Args:
    fixdata: a list of "Fixation"s</p>
<p>Returns:
    a list of absolute angles for the saccades formed by the given sequence of "Fixation"s in Radiant</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Segment.Segment.calc_abs_angles', this);">Show source &equiv;</a></p>
  <div id="source-Segment.Segment.calc_abs_angles" class="source">
    <pre><code>def calc_abs_angles(self, fixdata):
    """returns the absolute angles between a sequence of "Fixation"s that build a scan path.
    Abosolute angle for each saccade is the angle between that saccade and the horizental axis
    Args:
        fixdata: a list of "Fixation"s
    Returns:
        a list of absolute angles for the saccades formed by the given sequence of "Fixation"s in Radiant
    """
    abs_angles = []
    lastx = fixdata[0].mappedfixationpointx
    lasty = fixdata[0].mappedfixationpointy
    for i in xrange(1,len(fixdata)):
        x = fixdata[i].mappedfixationpointx
        y = fixdata[i].mappedfixationpointy
        (dist, theta) = geometry.vector_difference((lastx,lasty), (x, y))
        abs_angles.append(abs(theta))
        lastx=x
        lasty=y
    return abs_angles
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Segment.Segment.calc_blink_features">
    <p>def <span class="ident">calc_blink_features</span>(</p><p>self, all_data)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculates blink features such as
    blink_num:                 number of blinks on the in the segment
    blink_duration_total:       sum of the blink durations for this segment
    blink_duration_mean:        mean of the blink durations for this segment
    blink_duration_std:         standard deviation of blink durations for this segment
    blink_duration_max:         maximal blink duration for this segment
    blink_duration_min:         minimal blink duration for this segment
    blink_rate:                 rate of blinks for this segment
    blink_time_distance_mean:   mean time difference between consequtive blinks
    blink_time_distance_std:    std time difference between consequtive blinks
    blink_time_distance_min:    minimal time difference between consequtive blinks
    blink_time_distance_max:    maximal time difference between consequtive blinks
Args:
    all_data: The list of "Datapoint"s which make up this Segment</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Segment.Segment.calc_blink_features', this);">Show source &equiv;</a></p>
  <div id="source-Segment.Segment.calc_blink_features" class="source">
    <pre><code>def calc_blink_features(self, all_data):
    """ Calculates blink features such as
            blink_num:                 number of blinks on the in the segment
            blink_duration_total:       sum of the blink durations for this segment
            blink_duration_mean:        mean of the blink durations for this segment
            blink_duration_std:         standard deviation of blink durations for this segment
            blink_duration_max:         maximal blink duration for this segment
            blink_duration_min:         minimal blink duration for this segment
            blink_rate:                 rate of blinks for this segment
            blink_time_distance_mean:   mean time difference between consequtive blinks
            blink_time_distance_std:    std time difference between consequtive blinks
            blink_time_distance_min:    minimal time difference between consequtive blinks
            blink_time_distance_max:    maximal time difference between consequtive blinks
        Args:
            all_data: The list of "Datapoint"s which make up this Segment
    """
    blink_durations = []
    blink_intervals = []
    last_blink_detected = -1
    self.features['blinknum']               = 0
    self.features['blinkdurationtotal']     = 0
    self.features['blinkdurationmean']      = 0
    self.features['blinkdurationstd']       = 0
    self.features['blinkdurationmin']       = -1
    self.features['blinkdurationmax']       = -1
    self.features['blinkrate']              = -1
    self.features['blinktimedistancemean']  = -1
    self.features['blinktimedistancestd']   = -1
    self.features['blinktimedistancemin']   = -1
    self.features['blinktimedistancemax']   = -1
    lower_bound, upper_bould = params.blink_threshold
    ### File operations are for testing
    #file = open('outputfolder/blinks/blinks_%s.txt' % all_data[0].participant_name, 'w
    blinks_validity_gaps = self.calc_blink_validity_gaps(all_data)
    if params.EYETRACKERTYPE == "SMI":
        for i in range(len(blinks_validity_gaps)):
            blink_length = blinks_validity_gaps[i][1] - blinks_validity_gaps[i][0]
            blink_durations.append(blink_length)
            #file.write('Blink start, end: %d %d\n' % (self.time_gaps[i][0], self.time_gaps[i][1]))
            if last_blink_detected != -1:
                # Calculate time difference between start of current blink and end of previous blink
                blink_intervals.append(blinks_validity_gaps[i][0] - blinks_validity_gaps[last_blink_detected][1])
            last_blink_detected = i
    else:
        for i in range(len(blinks_validity_gaps)):
            blink_length = blinks_validity_gaps[i][1] - blinks_validity_gaps[i][0]
            if blink_length <= upper_bould and blink_length >= lower_bound:
                blink_durations.append(blink_length)
                #file.write('Blink start, end: %d %d\n' % (self.time_gaps[i][0], self.time_gaps[i][1]))
                if last_blink_detected != -1:
                    # Calculate time difference between start of current blink and end of previous blink
                    blink_intervals.append(blinks_validity_gaps[i][0] - blinks_validity_gaps[last_blink_detected][1])
                last_blink_detected = i
    #file.close()
    if len(blink_durations) > 0:
        self.features['blinknum']               = len(blink_durations)
        self.features['blinkdurationtotal']     = sum(blink_durations)
        self.features['blinkdurationmean']      = mean(blink_durations)
        self.features['blinkdurationstd']       = stddev(blink_durations)
        self.features['blinkdurationmin']       = min(blink_durations)
        self.features['blinkdurationmax']       = max(blink_durations)
        self.features['blinkrate']              = float(self.features['blinknum']) / (self.length - self.length_invalid)
    if len(blink_intervals) > 0:
        self.features['blinktimedistancemean']  = mean(blink_intervals)
        self.features['blinktimedistancestd']   = stddev(blink_intervals)
        self.features['blinktimedistancemin']   = min(blink_intervals)
        self.features['blinktimedistancemax']   = max(blink_intervals)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Segment.Segment.calc_blink_validity_gaps">
    <p>def <span class="ident">calc_blink_validity_gaps</span>(</p><p>self, all_data)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculates the blink validity gaps for this segment</p>
<p>Args:
    all_data: The list of "Datapoint"s which make up this Segement</p>
<p>Returns:
    An array for tuples (int, int) indicating beginning and end timestamps for each contiguous invalid group of rows</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Segment.Segment.calc_blink_validity_gaps', this);">Show source &equiv;</a></p>
  <div id="source-Segment.Segment.calc_blink_validity_gaps" class="source">
    <pre><code>def calc_blink_validity_gaps(self, all_data):
    """Calculates the blink validity gaps for this segment
    Args:
        all_data: The list of "Datapoint"s which make up this Segement
    Returns:
        An array for tuples (int, int) indicating beginning and end timestamps for each contiguous invalid group of rows
    """
    blinks_validity_gaps = []
    dindex = 0
    datalen = len(all_data)
    while dindex < datalen:
        d = all_data[dindex]
        while d.is_valid_blink and (dindex < datalen - 1):
            dindex += 1
            d = all_data[dindex]
        if not (d.is_valid_blink):
            gap_start = d.timestamp
            while not (d.is_valid_blink) and (dindex < datalen - 1):
                dindex += 1
                d = all_data[dindex]
            blinks_validity_gaps.append((gap_start, d.timestamp))
        dindex += 1
    return blinks_validity_gaps
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Segment.Segment.calc_distance_features">
    <p>def <span class="ident">calc_distance_features</span>(</p><p>self, all_data)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculates distance features such as
    mean_distance:            mean of distances from the screen
    stddev_distance:          standard deviation of distances from the screen
    min_distance:             smallest distance from the screen in this segment
    max_distance:             largest distance from the screen in this segment
    start_distance:           distance from the screen in the beginning of this segment
    end_distance:             distance from the screen in the end of this segment</p>
<p>Args:
    all_data: The list of "Datapoint"s which make up this Segment</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Segment.Segment.calc_distance_features', this);">Show source &equiv;</a></p>
  <div id="source-Segment.Segment.calc_distance_features" class="source">
    <pre><code>def calc_distance_features(self, all_data):
    """ Calculates distance features such as
            mean_distance:            mean of distances from the screen
            stddev_distance:          standard deviation of distances from the screen
            min_distance:             smallest distance from the screen in this segment
            max_distance:             largest distance from the screen in this segment
            start_distance:           distance from the screen in the beginning of this segment
            end_distance:             distance from the screen in the end of this segment
        Args:
            all_data: The list of "Datapoint"s which make up this Segment
    """
    # check if distances are available for all missing points
    invalid_distance_data = filter(lambda x: x.distance <= 0 and x.gazepointx >= 0, all_data)
    if len(invalid_distance_data) > 0:
        warn("Distance from screen is unavailable for a valid data sample. \
                    Number of missing points: " + str(len(invalid_distance_data)))
    #get all datapoints where distance is available
    valid_distance_data = filter(lambda x: x.distance > 0, all_data)
    #number of valid distance datapoints
    self.numdistancedata = len(valid_distance_data)
    if self.numdistancedata > 0: #check if the current segment has pupil data available
        distances_from_screen               = map(lambda x: x.distance, valid_distance_data)
        self.features['meandistance']       = mean(distances_from_screen)
        self.features['stddevdistance']     = stddev(distances_from_screen)
        self.features['maxdistance']        = max(distances_from_screen)
        self.features['mindistance']        = min(distances_from_screen)
        self.features['startdistance']      = distances_from_screen[0]
        self.features['enddistance']        = distances_from_screen[-1]
    else:
        self.features['meandistance']       = -1
        self.features['stddevdistance']     = -1
        self.features['maxdistance']        = -1
        self.features['mindistance']        = -1
        self.features['startdistance']      = -1
        self.features['enddistance']        = -1
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Segment.Segment.calc_distances">
    <p>def <span class="ident">calc_distances</span>(</p><p>self, fixdata)</p>
    </div>
    

    
  
    <div class="desc"><p>returns the Euclidean distances between a sequence of "Fixation"s</p>
<p>Args:
    fixdata: a list of "Fixation"s</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Segment.Segment.calc_distances', this);">Show source &equiv;</a></p>
  <div id="source-Segment.Segment.calc_distances" class="source">
    <pre><code>def calc_distances(self, fixdata):
    """returns the Euclidean distances between a sequence of "Fixation"s
    Args:
        fixdata: a list of "Fixation"s
    """
    distances = []
    lastx = fixdata[0].mappedfixationpointx
    lasty = fixdata[0].mappedfixationpointy
    for i in xrange(1, len(fixdata)):
        x = fixdata[i].mappedfixationpointx
        y = fixdata[i].mappedfixationpointy
        dist = math.sqrt((x - lastx)**2 + (y - lasty)**2)
        distances.append(dist)
        lastx = x
        lasty = y
    return distances
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Segment.Segment.calc_event_features">
    <p>def <span class="ident">calc_event_features</span>(</p><p>self, event_data)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculates event features such as
    numevents:                number of events in the segment
    numleftclic:              number of left clinks in the segment
    numrightclic:             number of right clinks in the segment
    numdoubleclic:            number of double clinks in the segment
    numkeypressed:            number of times a key was pressed in the segment
    leftclicrate:             the rate of left clicks (relative to all datapoints) in this segment
    rightclicrate:            the rate of right clicks (relative to all datapoints) in this segment
    doubleclicrate:           the rate of double clicks (relative to all datapoints) in this segment
    keypressedrate:           the rate of key presses (relative to all datapoints) in this segment
    timetofirstleftclic:      time until the first left click in this segment
    timetofirstrightclic:     time until the first right click in this segment
    timetofirstdoubleclic:    time until the first double click in this segment
    timetofirstkeypressed:    time until the first key pressed in this segment
Args:
    event_data: The list of events for this Segment</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Segment.Segment.calc_event_features', this);">Show source &equiv;</a></p>
  <div id="source-Segment.Segment.calc_event_features" class="source">
    <pre><code>def calc_event_features(self, event_data):
    """ Calculates event features such as
            numevents:                number of events in the segment
            numleftclic:              number of left clinks in the segment
            numrightclic:             number of right clinks in the segment
            numdoubleclic:            number of double clinks in the segment
            numkeypressed:            number of times a key was pressed in the segment
            leftclicrate:             the rate of left clicks (relative to all datapoints) in this segment
            rightclicrate:            the rate of right clicks (relative to all datapoints) in this segment
            doubleclicrate:           the rate of double clicks (relative to all datapoints) in this segment
            keypressedrate:           the rate of key presses (relative to all datapoints) in this segment
            timetofirstleftclic:      time until the first left click in this segment
            timetofirstrightclic:     time until the first right click in this segment
            timetofirstdoubleclic:    time until the first double click in this segment
            timetofirstkeypressed:    time until the first key pressed in this segment
        Args:
            event_data: The list of events for this Segment
    """
    if event_data != None:
        (leftc, rightc, doublec, keyp) = generate_event_lists(event_data)
        self.numevents = len(leftc)+len(rightc)+len(doublec)+len(keyp)
        self.features['numevents'] = self.numevents
        self.features['numleftclic'] = len(leftc)
        self.features['numrightclic'] = len(rightc)
        self.features['numdoubleclic'] = len(doublec)
        self.features['numkeypressed'] = len(keyp)
        self.features['leftclicrate'] = float(len(leftc))/(self.length - self.length_invalid)
        self.features['rightclicrate'] = float(len(rightc))/(self.length - self.length_invalid)
        self.features['doubleclicrate'] = float(len(doublec))/(self.length - self.length_invalid)
        self.features['keypressedrate'] = float(len(keyp))/(self.length - self.length_invalid)
        self.features['timetofirstleftclic'] = leftc[0].timestamp if len(leftc) > 0 else -1
        self.features['timetofirstrightclic'] = rightc[0].timestamp if len(rightc) > 0 else -1
        self.features['timetofirstdoubleclic'] = doublec[0].timestamp if len(doublec) > 0 else -1
        self.features['timetofirstkeypressed'] = keyp[0].timestamp if len(keyp) > 0 else -1
    else:
        self.features['numevents'] = 0
        self.features['numleftclic'] = 0
        self.features['numrightclic'] = 0
        self.features['numdoubleclic'] = 0
        self.features['numkeypressed'] = 0
        self.features['leftclicrate'] = -1
        self.features['rightclicrate'] = -1
        self.features['doubleclicrate'] = -1
        self.features['keypressedrate'] = -1
        self.features['timetofirstleftclic'] = -1
        self.features['timetofirstrightclic'] = -1
        self.features['timetofirstdoubleclic'] = -1
        self.features['timetofirstkeypressed'] = -1
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Segment.Segment.calc_fix_ang_path_features">
    <p>def <span class="ident">calc_fix_ang_path_features</span>(</p><p>self, fixation_data)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculates fixation, angle and path features such as
    meanfixationduration:     mean duration of fixations in the segment
    stddevfixationduration    standard deviation of duration of fixations in the segment
    sumfixationduration:      sum of durations of fixations in the segment
    fixationrate:             rate of fixation datapoints relative to all datapoints in this segment
    meanpathdistance:         mean of path distances for this segment
    sumpathdistance:          sum of path distances for this segment
    eyemovementvelocity:      average eye movement velocity for this segment
    sumabspathangles:         sum of absolute path angles for this segment
    abspathanglesrate:        ratio of absolute path angles relative to all datapoints in this segment
    stddevabspathangles:      standard deviation of absolute path angles for this segment
    sumrelpathangles:         sum of relative path angles for this segment
    relpathanglesrate:        ratio of relative path angles relative to all datapoints in this segment
    stddevrelpathangles:      standard deviation of relative path angles for this segment
Args:
    saccade_data: The list of saccade datapoints for this Segment</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Segment.Segment.calc_fix_ang_path_features', this);">Show source &equiv;</a></p>
  <div id="source-Segment.Segment.calc_fix_ang_path_features" class="source">
    <pre><code>def calc_fix_ang_path_features(self, fixation_data):
    """ Calculates fixation, angle and path features such as
            meanfixationduration:     mean duration of fixations in the segment
            stddevfixationduration    standard deviation of duration of fixations in the segment
            sumfixationduration:      sum of durations of fixations in the segment
            fixationrate:             rate of fixation datapoints relative to all datapoints in this segment
            meanpathdistance:         mean of path distances for this segment
            sumpathdistance:          sum of path distances for this segment
            eyemovementvelocity:      average eye movement velocity for this segment
            sumabspathangles:         sum of absolute path angles for this segment
            abspathanglesrate:        ratio of absolute path angles relative to all datapoints in this segment
            stddevabspathangles:      standard deviation of absolute path angles for this segment
            sumrelpathangles:         sum of relative path angles for this segment
            relpathanglesrate:        ratio of relative path angles relative to all datapoints in this segment
            stddevrelpathangles:      standard deviation of relative path angles for this segment
        Args:
            saccade_data: The list of saccade datapoints for this Segment
    """
    if self.numfixations > 0:
        self.fixation_start = fixation_data[0].timestamp
        self.fixation_end = fixation_data[-1].timestamp
        self.features['meanfixationduration'] = mean(map(lambda x: float(x.fixationduration), fixation_data))
        self.features['stddevfixationduration'] = stddev(map(lambda x: float(x.fixationduration), fixation_data))
        self.features['sumfixationduration'] = sum(map(lambda x: x.fixationduration, fixation_data))
        self.features['fixationrate'] = float(self.numfixations) / (self.length - self.length_invalid)
        distances = self.calc_distances(fixation_data)
        abs_angles = self.calc_abs_angles(fixation_data)
        rel_angles = self.calc_rel_angles(fixation_data)
    else:
        self.fixation_start = -1
        self.fixation_end = -1
        self.features['meanfixationduration'] = -1
        self.features['stddevfixationduration'] = -1
        self.features['sumfixationduration'] = -1
        self.features['fixationrate'] = -1
    self.numfixdistances = len(distances)
    self.numabsangles = len(abs_angles)
    self.numrelangles = len(rel_angles)
    if len(distances) > 0:
        self.features['meanpathdistance'] = mean(distances)
        self.features['sumpathdistance'] = sum(distances)
        self.features['stddevpathdistance'] = stddev(distances)
        self.features['eyemovementvelocity'] = self.features['sumpathdistance']/(self.length - self.length_invalid)
        self.features['sumabspathangles'] = sum(abs_angles)
        self.features['abspathanglesrate'] = sum(abs_angles)/(self.length - self.length_invalid)
        self.features['meanabspathangles'] = mean(abs_angles)
        self.features['stddevabspathangles'] = stddev(abs_angles)
        self.features['sumrelpathangles'] = sum(rel_angles)
        self.features['relpathanglesrate'] = sum(rel_angles)/(self.length - self.length_invalid)
        self.features['meanrelpathangles'] = mean(rel_angles)
        self.features['stddevrelpathangles'] = stddev(rel_angles)
    else:
        self.features['meanpathdistance'] = -1
        self.features['sumpathdistance'] = -1
        self.features['stddevpathdistance'] = -1
        self.features['eyemovementvelocity'] = -1
        self.features['sumabspathangles'] = -1
        self.features['abspathanglesrate'] = -1
        self.features['meanabspathangles'] = -1
        self.features['stddevabspathangles'] = -1
        self.features['sumrelpathangles'] = -1
        self.features['relpathanglesrate'] = -1
        self.features['meanrelpathangles'] = -1
        self.features['stddevrelpathangles'] = -1
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Segment.Segment.calc_largest_validity_gap">
    <p>def <span class="ident">calc_largest_validity_gap</span>(</p><p>self, all_data)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculates the largest gap of invalid samples in the "Datapoint"s for this Segment.</p>
<p>Args:
    all_data: The list of "Datapoint"s which make up this Segement</p>
<p>Returns:
    An integer indicating the length of largest invalid gap for this Segment in milliseconds</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Segment.Segment.calc_largest_validity_gap', this);">Show source &equiv;</a></p>
  <div id="source-Segment.Segment.calc_largest_validity_gap" class="source">
    <pre><code>def calc_largest_validity_gap(self, all_data):
    """Calculates the largest gap of invalid samples in the "Datapoint"s for this Segment.
    Args:
        all_data: The list of "Datapoint"s which make up this Segement
    Returns:
        An integer indicating the length of largest invalid gap for this Segment in milliseconds
    """
    if self.numfixations == 0:
        return all_data[-1].timestamp - all_data[0].timestamp
    self.time_gaps = []
    self.all_invalid_gaps = []
    max_size = 0
    dindex = 0
    datalen = len(all_data)
    while dindex < datalen:
        d = all_data[dindex]
        while d.is_valid and (dindex < datalen - 1):
            dindex += 1
            d = all_data[dindex]
        if not (d.is_valid):
            gap_start = d.timestamp
            while not (d.is_valid) and (dindex < datalen - 1):
                dindex += 1
                d = all_data[dindex]
            if d.timestamp - gap_start > max_size:
                max_size = d.timestamp - gap_start
            if d.timestamp - gap_start > params.MAX_SEG_TIMEGAP:
                self.time_gaps.append((gap_start, d.timestamp))
        dindex += 1
    return max_size
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Segment.Segment.calc_num_samples">
    <p>def <span class="ident">calc_num_samples</span>(</p><p>self, all_data)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the number of samples in the Segment</p>
<p>Args:
    all_data: a list of "Datapoint"s which make up this Segment.</p>
<p>Returns:
    An integer determining the number of samples in the Segment</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Segment.Segment.calc_num_samples', this);">Show source &equiv;</a></p>
  <div id="source-Segment.Segment.calc_num_samples" class="source">
    <pre><code>def calc_num_samples(self, all_data):
    """Returns the number of samples in the Segment
    Args:
        all_data: a list of "Datapoint"s which make up this Segment.
    Returns:
        An integer determining the number of samples in the Segment
    """
    num = 0
    for d in all_data:
        if d.stimuliname != '':
            num += 1
    return num
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Segment.Segment.calc_pupil_features">
    <p>def <span class="ident">calc_pupil_features</span>(</p><p>self, all_data, export_pupilinfo, rest_pupil_size)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculates pupil features such as
    mean_pupil_size:            mean of pupil sizes
    stddev_pupil_size:          standard deviation of pupil sizes
    min_pupil_size:             smallest pupil size in this segment
    max_pupil_size:             largest pupil size in this segment
    mean_pupil_velocity:        mean of pupil velocities
    stddev_pupil_velocity:      standard deviation of pupil velocities
    min_pupil_velocity:         smallest pupil velocity in this segment
    max_pupil_velocity:         largest pupil velocity in this segment</p>
<p>Args:
    all_data: The list of "Datapoint"s which make up this Segment</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Segment.Segment.calc_pupil_features', this);">Show source &equiv;</a></p>
  <div id="source-Segment.Segment.calc_pupil_features" class="source">
    <pre><code>def calc_pupil_features(self, all_data, export_pupilinfo, rest_pupil_size):
    """ Calculates pupil features such as
            mean_pupil_size:            mean of pupil sizes
            stddev_pupil_size:          standard deviation of pupil sizes
            min_pupil_size:             smallest pupil size in this segment
            max_pupil_size:             largest pupil size in this segment
            mean_pupil_velocity:        mean of pupil velocities
            stddev_pupil_velocity:      standard deviation of pupil velocities
            min_pupil_velocity:         smallest pupil velocity in this segment
            max_pupil_velocity:         largest pupil velocity in this segment
        Args:
            all_data: The list of "Datapoint"s which make up this Segment
    """
    # check if pupil sizes are available for all missing points
    pupil_invalid_data = filter(lambda x: x.pupilsize == -1 and x.gazepointx > 0, all_data)
    if len(pupil_invalid_data) > 0:
        if params.DEBUG:
            raise Exception("Pupil size is unavailable for a valid data sample. \
                    Number of missing points: " + str(len(pupil_invalid_data)))
        else:
            warn("Pupil size is unavailable for a valid data sample. Number of missing points: " + str(len(pupil_invalid_data)) )
et all pupil sizes (valid + invalid)
    #pupilsizes = map(lambda x: x.pupilsize, all_data)
    #get all datapoints where pupil size is available
    valid_pupil_data = filter(lambda x: x.pupilsize > 0, all_data)
    valid_pupil_velocity = filter(lambda x: x.pupilvelocity != -1, all_data)
    #number of valid pupil sizes
    self.features['meanpupilsize']       = -1
    self.features['stddevpupilsize']     = -1
    self.features['maxpupilsize']        = -1
    self.features['minpupilsize']        = -1
    self.features['startpupilsize']      = -1
    self.features['endpupilsize']        = -1
    self.features['meanpupilvelocity']   = -1
    self.features['stddevpupilvelocity'] = -1
    self.features['maxpupilvelocity']    = -1
    self.features['minpupilvelocity']    = -1
    self.numpupilsizes                   = len(valid_pupil_data)
    self.numpupilvelocity                = len(valid_pupil_velocity)
    if self.numpupilsizes > 0: #check if the current segment has pupil data available
        if params.PUPIL_ADJUSTMENT == "rpscenter":
            adjvalidpupilsizes = map(lambda x: x.pupilsize - rest_pupil_size, valid_pupil_data)
        elif params.PUPIL_ADJUSTMENT == "PCPS":
            adjvalidpupilsizes = map(lambda x: (x.pupilsize - rest_pupil_size) / (1.0 * rest_pupil_size), valid_pupil_data)
        else:
            adjvalidpupilsizes = map(lambda x: x.pupilsize, valid_pupil_data)#valid_pupil_data
        valid_pupil_velocity = map(lambda x: x.pupilvelocity, valid_pupil_velocity)#valid_pupil_data
        if export_pupilinfo:
            self.pupilinfo_for_export = map(lambda x: [x.timestamp, x.pupilsize, rest_pupil_size], valid_pupil_data)
        self.features['meanpupilsize']           = mean(adjvalidpupilsizes)
        self.features['stddevpupilsize']         = stddev(adjvalidpupilsizes)
        self.features['maxpupilsize']            = max(adjvalidpupilsizes)
        self.features['minpupilsize']            = min(adjvalidpupilsizes)
        self.features['startpupilsize']          = adjvalidpupilsizes[0]
        self.features['endpupilsize']            = adjvalidpupilsizes[-1]
        if len(valid_pupil_velocity) > 0:
            self.features['meanpupilvelocity']   = mean(valid_pupil_velocity)
            self.features['stddevpupilvelocity'] = stddev(valid_pupil_velocity)
            self.features['maxpupilvelocity']    = max(valid_pupil_velocity)
            self.features['minpupilvelocity']    = min(valid_pupil_velocity)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Segment.Segment.calc_rel_angles">
    <p>def <span class="ident">calc_rel_angles</span>(</p><p>self, fixdata)</p>
    </div>
    

    
  
    <div class="desc"><p>returns the relative angles between a sequence of "Fixation"s that build a scan path in Radiant</p>
<p>Relative angle for each saccade is the angle between that saccade and the previous saccade.</p>
<p>Defined as: angle = acos(v1 dot v2)  such that v1 and v2 are normalized vector2coord</p>
<p>Args:
    fixdata: a list of "Fixation"s</p>
<p>Returns:
    a list of relative angles for the saccades formed by the given sequence of "Fixation"s in Radiant</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Segment.Segment.calc_rel_angles', this);">Show source &equiv;</a></p>
  <div id="source-Segment.Segment.calc_rel_angles" class="source">
    <pre><code>def calc_rel_angles(self, fixdata):
    """returns the relative angles between a sequence of "Fixation"s that build a scan path in Radiant
    Relative angle for each saccade is the angle between that saccade and the previous saccade.
    Defined as: angle = acos(v1 dot v2)  such that v1 and v2 are normalized vector2coord
    Args:
        fixdata: a list of "Fixation"s
    Returns:
        a list of relative angles for the saccades formed by the given sequence of "Fixation"s in Radiant
    """
    rel_angles = []
    lastx = fixdata[0].mappedfixationpointx
    lasty = fixdata[0].mappedfixationpointy
    for i in xrange(1, len(fixdata) - 1):
        x = fixdata[i].mappedfixationpointx
        y = fixdata[i].mappedfixationpointy
        nextx = fixdata[i + 1].mappedfixationpointx
        nexty = fixdata[i + 1].mappedfixationpointy
        v1 = (lastx - x, lasty - y)
        v2 = (nextx - x, nexty - y)
        if v1 != (0.0, 0.0) and v2 != (0.0, 0.0):
            v1_dot = math.sqrt(geometry.simpledotproduct(v1, v1))
            v2_dot = math.sqrt(geometry.simpledotproduct(v2, v2))
            normv1 = ((lastx - x) / v1_dot, (lasty - y) / v1_dot)
            normv2 = ((nextx - x) / v2_dot, (nexty - y) / v2_dot)
            dotproduct = geometry.simpledotproduct(normv1, normv2)
            if dotproduct < -1:
                dotproduct = -1.0
            if dotproduct > 1:
                dotproduct = 1.0
            theta = math.acos(dotproduct)
            rel_angles.append(theta)
        else:
            rel_angles.append(0.0)
        lastx = x
        lasty = y
    return rel_angles
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Segment.Segment.calc_saccade_features">
    <p>def <span class="ident">calc_saccade_features</span>(</p><p>self, saccade_data)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculates saccade features such as
    numsaccades:              number of saccades in the segment
    sumsaccadedistance:       sum of distances during each saccade
    meansaccadedistance:      mean of distances during each saccade
    stddevsaccadedistance:    standard deviation of distances during each saccade
    longestsaccadedistance:   distance of longest saccade
    sumsaccadeduration:       total time spent on saccades in this segment
    meansaccadeduration:      average saccade duration
    stddevsaccadeduration:    standard deviation of saccade durations
    longestsaccadeduration:   longest duration of saccades in this segment
    meansaccadespeed:         average speed of saccades in this segment
    stddevsaccadespeed:       standard deviation of speed of saccades in this segment
    maxsaccadespeed:          highest saccade speed in this segment
    minsaccadespeed:          lowest saccade speed in this  segment
    fixationsaccadetimeratio: fixation to saccade time ratio for this segment
Args:
    saccade_data: The list of saccade datapoints for this Segment</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Segment.Segment.calc_saccade_features', this);">Show source &equiv;</a></p>
  <div id="source-Segment.Segment.calc_saccade_features" class="source">
    <pre><code>def calc_saccade_features(self, saccade_data):
    """ Calculates saccade features such as
            numsaccades:              number of saccades in the segment
            sumsaccadedistance:       sum of distances during each saccade
            meansaccadedistance:      mean of distances during each saccade
            stddevsaccadedistance:    standard deviation of distances during each saccade
            longestsaccadedistance:   distance of longest saccade
            sumsaccadeduration:       total time spent on saccades in this segment
            meansaccadeduration:      average saccade duration
            stddevsaccadeduration:    standard deviation of saccade durations
            longestsaccadeduration:   longest duration of saccades in this segment
            meansaccadespeed:         average speed of saccades in this segment
            stddevsaccadespeed:       standard deviation of speed of saccades in this segment
            maxsaccadespeed:          highest saccade speed in this segment
            minsaccadespeed:          lowest saccade speed in this  segment
            fixationsaccadetimeratio: fixation to saccade time ratio for this segment
        Args:
            saccade_data: The list of saccade datapoints for this Segment
    """
    if saccade_data != None and len(saccade_data) > 0:
        self.numsaccades = len(saccade_data)
        self.features['numsaccades'] = self.numsaccades
        self.features['sumsaccadedistance'] = sum(map(lambda x: float(x.saccadedistance), saccade_data))
        self.features['meansaccadedistance'] = mean(map(lambda x: float(x.saccadedistance), saccade_data))
        self.features['stddevsaccadedistance'] = stddev(map(lambda x: float(x.saccadedistance), saccade_data))
        self.features['longestsaccadedistance'] = max(map(lambda x: float(x.saccadedistance), saccade_data))
        self.features['sumsaccadeduration'] = sum(map(lambda x: float(x.saccadeduration), saccade_data))
        self.features['meansaccadeduration'] = mean(map(lambda x: float(x.saccadeduration), saccade_data))
        self.features['stddevsaccadeduration'] = stddev(map(lambda x: float(x.saccadeduration), saccade_data))
        self.features['longestsaccadeduration'] = max(map(lambda x: float(x.saccadeduration), saccade_data))
        self.features['meansaccadespeed'] = mean(map(lambda x: float(x.saccadespeed), saccade_data))
        self.features['stddevsaccadespeed'] = stddev(map(lambda x: float(x.saccadespeed), saccade_data))
        self.features['maxsaccadespeed'] = max(map(lambda x: float(x.saccadespeed), saccade_data))
        self.features['minsaccadespeed'] = min(map(lambda x: float(x.saccadespeed), saccade_data))
        self.features['fixationsaccadetimeratio'] = float(self.features['sumfixationduration']) / self.features['sumsaccadeduration']
    else:
        self.numsaccades = 0
        self.features['numsaccades'] = 0
        self.features['sumsaccadedistance'] = -1
        self.features['meansaccadedistance'] = -1
        self.features['stddevsaccadedistance'] = -1
        self.features['longestsaccadedistance'] = -1
        self.features['sumsaccadeduration'] = -1
        self.features['meansaccadeduration'] = -1
        self.features['stddevsaccadeduration'] = -1
        self.features['longestsaccadeduration'] = -1
        self.features['meansaccadespeed'] = -1
        self.features['stddevsaccadespeed'] = -1
        self.features['maxsaccadespeed'] = -1
        self.features['minsaccadespeed'] = -1
        self.features['fixationsaccadetimeratio'] = -1
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Segment.Segment.calc_validity1">
    <p>def <span class="ident">calc_validity1</span>(</p><p>self, threshold=0.8)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns a boolean indicating whether this Segment is valid using proportion of valid samples threshold</p>
<p>Args:
    threshold: the minimum proportion of valid samples for a Segment or Scene to be
        considered valid. By default set to value VALID_PROP_THRESH from module params.py</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Segment.Segment.calc_validity1', this);">Show source &equiv;</a></p>
  <div id="source-Segment.Segment.calc_validity1" class="source">
    <pre><code>def calc_validity1(self, threshold = params.VALID_PROP_THRESH):
    """Returns a boolean indicating whether this Segment is valid using proportion of valid samples threshold
    Args:
        threshold: the minimum proportion of valid samples for a Segment or Scene to be
            considered valid. By default set to value VALID_PROP_THRESH from module params.py
    """
    return self.proportion_valid > threshold
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Segment.Segment.calc_validity2">
    <p>def <span class="ident">calc_validity2</span>(</p><p>self, threshold=3000)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns a boolean indicating whether this Segment is valid using largest acceptable gap threshold</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Segment.Segment.calc_validity2', this);">Show source &equiv;</a></p>
  <div id="source-Segment.Segment.calc_validity2" class="source">
    <pre><code>def calc_validity2(self, threshold = params.VALID_TIME_THRESH):
    """Returns a boolean indicating whether this Segment is valid using largest acceptable gap threshold
    """
    return self.largest_data_gap <= threshold
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Segment.Segment.calc_validity3">
    <p>def <span class="ident">calc_validity3</span>(</p><p>self, threshold=0.8)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns a boolean indicating whether this Segment is valid using proportion of (valid + restored) samples threshold</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Segment.Segment.calc_validity3', this);">Show source &equiv;</a></p>
  <div id="source-Segment.Segment.calc_validity3" class="source">
    <pre><code>def calc_validity3(self, threshold = params.VALID_PROP_THRESH):
    """Returns a boolean indicating whether this Segment is valid using proportion of (valid + restored) samples threshold
    """
    return self.proportion_valid_fix > threshold
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Segment.Segment.calc_validity_fixation">
    <p>def <span class="ident">calc_validity_fixation</span>(</p><p>self, all_data)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculates the proportion of (valid + restored) "Datapoint"s over all "Datapoint"s of the Segment.</p>
<p>Restored samples are the samples which are not valid but they are part of a Fixation.
The idea is that if the user was looking at a certain point and then we loose the eye data for
a short period of time and afterwards the user is looking at the same point we can assume that user
was looking at that same point during that period.</p>
<p>Args:
    all_data: The list of "Datapoint"s which make up this Segement</p>
<p>Returns:
    A float indicating the proportion of (valid + restored) samples over all the samples in this Segment</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Segment.Segment.calc_validity_fixation', this);">Show source &equiv;</a></p>
  <div id="source-Segment.Segment.calc_validity_fixation" class="source">
    <pre><code>def calc_validity_fixation(self, all_data):
    """Calculates the proportion of (valid + restored) "Datapoint"s over all "Datapoint"s of the Segment.
    Restored samples are the samples which are not valid but they are part of a Fixation.
    The idea is that if the user was looking at a certain point and then we loose the eye data for
    a short period of time and afterwards the user is looking at the same point we can assume that user
    was looking at that same point during that period.
    Args:
        all_data: The list of "Datapoint"s which make up this Segement
    Returns:
        A float indicating the proportion of (valid + restored) samples over all the samples in this Segment
    """
    if self.numfixations == 0:
        return 0.0
    num_valid = float(0)
    num = 0
    for d in all_data:
        #if d.stimuliname == 'ScreenRec':
        if d.stimuliname != '':
            num += 1
            if d.is_valid or d.fixationindex!=None:
                num_valid += 1.0
         else:
             print "###",d.event, d.data1
    if num == 0:
        return 0.0
    else:
        return num_valid / num
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Segment.Segment.calc_validity_proportion">
    <p>def <span class="ident">calc_validity_proportion</span>(</p><p>self, all_data)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculates the proportion of "Datapoint"s which are valid.</p>
<p>Args:
    all_data: The list of "Datapoint"s which make up this Segment</p>
<p>Returns:
    A float indicating the proportion of valid samples over all the samples in this Segment</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Segment.Segment.calc_validity_proportion', this);">Show source &equiv;</a></p>
  <div id="source-Segment.Segment.calc_validity_proportion" class="source">
    <pre><code>def calc_validity_proportion(self, all_data):
    """Calculates the proportion of "Datapoint"s which are valid.
    Args:
        all_data: The list of "Datapoint"s which make up this Segment
    Returns:
        A float indicating the proportion of valid samples over all the samples in this Segment
    """
    num_valid = float(0)
    num = 0
    for d in all_data:
        #if d.stimuliname == 'ScreenRec':
        #if d.stimuliname == 'Screen Recordings (1)'
        if d.stimuliname != '':
            num += 1
            if d.is_valid:
                num_valid += 1
         else:
             print "###",d.event, d.data1
    if num == 0:
        return 0.0
    else:
        return num_valid / num
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Segment.Segment.generate_aoi_sequence">
    <p>def <span class="ident">generate_aoi_sequence</span>(</p><p>self, fixdata, aois)</p>
    </div>
    

    
  
    <div class="desc"><p>returns the sequence of AOI's where "Fixation"s occurred
Args:
    fixdata: a list of "Fixation"s
Returns:
    a list of AOI names that correspond to the sequence of "Fixation" locations</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Segment.Segment.generate_aoi_sequence', this);">Show source &equiv;</a></p>
  <div id="source-Segment.Segment.generate_aoi_sequence" class="source">
    <pre><code>def generate_aoi_sequence(self, fixdata, aois):
    """returns the sequence of AOI's where "Fixation"s occurred
    Args:
        fixdata: a list of "Fixation"s
    Returns:
        a list of AOI names that correspond to the sequence of "Fixation" locations
    """
    sequence = []
    for fix in fixdata:
        for aoi in aois:
            if _fixation_inside_aoi(fix, aoi.polyin, aoi.polyout) and aoi.is_active(fix.timestamp, fix.timestamp) :
                sequence.append(aoi.aid)
    return sequence
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Segment.Segment.get_features">
    <p>def <span class="ident">get_features</span>(</p><p>self, featurelist=None, aoifeaturelist=None, aoifeaturelabels=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns feature names and their values for this Segment</p>
<p>Args:
    featurelist: if not None, a list containing the name of features to be returned. If this is None all features will be returned
    aoifeaturelist: if not None, a list of features to be returned for each of the "AOI"s relevant to this Segment.
    aoifeaturelabels: if not None, a list of AOI related features to be returned.
    *Note: while aoifeaturelist is a subset of features that will be returned for all relevant "AOI"s, aoifeaturelabels contains
    the exact AOI feature name, i.e., a feature of the form: [AOI name]_[feature name]
    For example if an AOI called 'graph' is releveant to this Segment, aoifeaturelabels may contain 'graph_fixationrate'</p>
<p>Returns:
    featnames: a list of feature names sorted alphabetically
    featvals: a corrsponding list of feature values
    e.g.
    featnames = ['fixationrate', 'length', 'meanabspathangles']
    featvals  = [0.00268522882294', '1529851', '1.60354714212']</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Segment.Segment.get_features', this);">Show source &equiv;</a></p>
  <div id="source-Segment.Segment.get_features" class="source">
    <pre><code>def get_features(self, featurelist = None, aoifeaturelist = None, aoifeaturelabels = None):
    """Returns feature names and their values for this Segment
    Args:
        featurelist: if not None, a list containing the name of features to be returned. If this is None all features will be returned
        aoifeaturelist: if not None, a list of features to be returned for each of the "AOI"s relevant to this Segment.
        aoifeaturelabels: if not None, a list of AOI related features to be returned.
        *Note: while aoifeaturelist is a subset of features that will be returned for all relevant "AOI"s, aoifeaturelabels contains
        the exact AOI feature name, i.e., a feature of the form: [AOI name]_[feature name]
        For example if an AOI called 'graph' is releveant to this Segment, aoifeaturelabels may contain 'graph_fixationrate'
    Returns:
        featnames: a list of feature names sorted alphabetically
        featvals: a corrsponding list of feature values
        e.g.
        featnames = ['fixationrate', 'length', 'meanabspathangles']
        featvals  = [0.00268522882294', '1529851', '1.60354714212']
    """
    if featurelist == []:
        featnames = []
    elif not featurelist:       #include all features
        featnames = self.features.keys()
    else:                       #a list of features was given
        featnames = []
        for name in featurelist:
            if name in self.features.keys():
                featnames.append(name)
            else:
                raise Exception('Segment %s has no such feature: %s'%(self.getid(),name))
    featnames.sort()
    featvals = map(lambda x: self.features[x], featnames)
    if self.has_aois:
        for aid, aoi in self.aoi_data.iteritems():
            if aoifeaturelabels:    #an exact list of aoifeatures was given
                anames, avals = aoi.get_features()
                anames = map(lambda x: '%s_%s'%(aid, x), anames)
                featval = zip(anames,avals)
                newfeatval = filter(lambda x: x[0] in aoifeaturelabels,featval)
                anames = []
                avals = []
                for fn,fv in newfeatval:
                    anames.append(fn)
                    avals.append(fv)
                if featnames:
                    featnames += anames
                    featvals += avals
            else:                   #a list of features for each AIO was given
                anames, avals = aoi.get_features(aoifeaturelist)
                anames = map(lambda x: '%s_%s'%(aid, x), anames)
                featnames += anames
                featvals += avals
    return featnames, featvals
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Segment.Segment.get_indices">
    <p>def <span class="ident">get_indices</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the index features</p>
<p>Returns:
    An integer indicating the index of the first Datapoint for this Segment in the Participant's list of all "Datapoint"s (all_data)
    An integer indicating the index of the last Datapoint for this Segment in the Participant's list of all "Datapoint"s (all_data)
    An integer indicating the index of the first Fixation for this Segment in the Participant's list of all "Fixation"s (fixation_data)
    An integer indicating the index of the last Fixation for this Segment in the Participant's list of all "Fixation"s (fixation_data)
    An integer indicating the index of the first Saccade for this Segment in the Participant's list of all "Saccade"s (saccade_data). None if no saccade.
    An integer indicating the index of the last Saccade for this Segment in the Participant's list of all "Saccade"s (saccade_data). None if no saccade.
    An integer indicating the index of the first Event for this Segment in the Participant's list of all "Event"s (event_data). None if no saccade.
    An integer indicating the index of the last Event for this Segment in the Participant's list of all "Event"s (event_data). None if no saccade.
Raises:
    Exception: An exception is thrown if the values are read before initialization</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Segment.Segment.get_indices', this);">Show source &equiv;</a></p>
  <div id="source-Segment.Segment.get_indices" class="source">
    <pre><code>def get_indices(self):
    """Returns the index features
    Returns:
        An integer indicating the index of the first Datapoint for this Segment in the Participant's list of all "Datapoint"s (all_data)
        An integer indicating the index of the last Datapoint for this Segment in the Participant's list of all "Datapoint"s (all_data)
        An integer indicating the index of the first Fixation for this Segment in the Participant's list of all "Fixation"s (fixation_data)
        An integer indicating the index of the last Fixation for this Segment in the Participant's list of all "Fixation"s (fixation_data)
        An integer indicating the index of the first Saccade for this Segment in the Participant's list of all "Saccade"s (saccade_data). None if no saccade.
        An integer indicating the index of the last Saccade for this Segment in the Participant's list of all "Saccade"s (saccade_data). None if no saccade.
        An integer indicating the index of the first Event for this Segment in the Participant's list of all "Event"s (event_data). None if no saccade.
        An integer indicating the index of the last Event for this Segment in the Participant's list of all "Event"s (event_data). None if no saccade.
    Raises:
        Exception: An exception is thrown if the values are read before initialization
    """
    if self.sample_start_ind != None:
        return self.sample_start_ind, self.sample_end_ind, self.fixation_start_ind, \
            self.fixation_end_ind, self.saccade_start_ind, self.saccade_end_ind, self.event_start_ind, self.event_end_ind
    raise Exception ('The indices values are accessed before setting the initial value in segement:'+self.segid+'!')
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Segment.Segment.get_length_invalid">
    <p>def <span class="ident">get_length_invalid</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the sum of the length of the invalid gaps &gt; params.MAX_SEG_TIMEGAP</p>
<p>Args:
    an integer, the length in milliseconds</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Segment.Segment.get_length_invalid', this);">Show source &equiv;</a></p>
  <div id="source-Segment.Segment.get_length_invalid" class="source">
    <pre><code>def get_length_invalid(self):
    """Returns the sum of the length of the invalid gaps > params.MAX_SEG_TIMEGAP
    Args:
        an integer, the length in milliseconds
    """
    length = 0
    for gap in self.getgaps():
        length += gap[1] - gap[0]
    return length
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Segment.Segment.get_validity">
    <p>def <span class="ident">get_validity</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Determines if this Segment is valid with the given validity method set in params.VALIDITY_METHOD</p>
<p>Returns:
    A boolean indicating whether this Segment is valid</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Segment.Segment.get_validity', this);">Show source &equiv;</a></p>
  <div id="source-Segment.Segment.get_validity" class="source">
    <pre><code>def get_validity(self):
    """Determines if this Segment is valid with the given validity method set in params.VALIDITY_METHOD
    Returns:
        A boolean indicating whether this Segment is valid
    """
    if params.VALIDITY_METHOD == 1:
        return self.validity1
    elif params.VALIDITY_METHOD == 2:
        return self.validity2
    elif params.VALIDITY_METHOD == 3:
        return self.validity3
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Segment.Segment.getallgaps">
    <p>def <span class="ident">getallgaps</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the total length of all invalid gaps for this Segment</p>
<p>Args:
    an integer: the length in ms of invalid points for this Segment</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Segment.Segment.getallgaps', this);">Show source &equiv;</a></p>
  <div id="source-Segment.Segment.getallgaps" class="source">
    <pre><code>def getallgaps(self):
    """Returns the total length of all invalid gaps for this Segment
    Args:
        an integer: the length in ms of invalid points for this Segment
    """
    return self.all_invalid_gaps
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Segment.Segment.getgaps">
    <p>def <span class="ident">getgaps</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the list of invalid gaps &gt; params.MAX_SEG_TIMEGAP for this Segment</p>
<p>Args:
    a list of invalid gaps for this Segment</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Segment.Segment.getgaps', this);">Show source &equiv;</a></p>
  <div id="source-Segment.Segment.getgaps" class="source">
    <pre><code>def getgaps(self):
    """Returns the list of invalid gaps > params.MAX_SEG_TIMEGAP for this Segment
    Args:
        a list of invalid gaps for this Segment
    """
    return self.time_gaps
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Segment.Segment.getid">
    <p>def <span class="ident">getid</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the segid for this Segment</p>
<p>Returns: a string conataining the segid for this Segment</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Segment.Segment.getid', this);">Show source &equiv;</a></p>
  <div id="source-Segment.Segment.getid" class="source">
    <pre><code>def getid(self):
    """Returns the segid for this Segment
    Returns: a string conataining the segid for this Segment
    """
    return self.segid
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Segment.Segment.print_">
    <p>def <span class="ident">print_</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Ourputs all feature names and their values for this Segment on the console</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Segment.Segment.print_', this);">Show source &equiv;</a></p>
  <div id="source-Segment.Segment.print_" class="source">
    <pre><code>def print_(self):
    """Ourputs all feature names and their values for this Segment on the console
    """
    print("ID", self.getid())
    print("start",self.start)
    print("end",self.end)
    print("is_valid",self.is_valid)
    print
     featurelist =["completion_time","numfixations","length","numsamples"]
     if self.features['numfixations'] > 0:
         featurelist.extend(["meanfixationduration","stddevfixationduration","sumfixationduration","fixationrate"])
     featurelist.extend(["meanpathdistance","sumpathdistance","stddevpathdistance","sumabspathangles","meanabspathangles","stddevabspathangles","sumrelpathangles","meanrelpathangles","stddevrelpathangles"])
    fn,fv = self.get_features()
    for i in xrange(len(fn)):
        print(fn[i],':',fv[i])
    print
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Segment.Segment.set_aois">
    <p>def <span class="ident">set_aois</span>(</p><p>self, aois, all_data, fixation_data, event_data=None, rest_pupil_size=0, export_pupilinfo=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Sets the relevant "AOI"s for this Segment</p>
<p>Args:
    all_data: a list of "Datapoint"s which make up this Segment
    fixation_data: The list of "Fixation"s which make up this Segment
    aois: a list of "AOI"s relevant to this Segment
    rest_pupil_size:</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Segment.Segment.set_aois', this);">Show source &equiv;</a></p>
  <div id="source-Segment.Segment.set_aois" class="source">
    <pre><code>def set_aois(self, aois, all_data, fixation_data, event_data = None, rest_pupil_size = 0, export_pupilinfo = False):
    """Sets the relevant "AOI"s for this Segment
    Args:
        all_data: a list of "Datapoint"s which make up this Segment
        fixation_data: The list of "Fixation"s which make up this Segment
        aois: a list of "AOI"s relevant to this Segment
        rest_pupil_size:
    """
    if len(aois) == 0:
        warn("No AOIs passed to segment:"+self.segid)
    active_aois=[]
    self.aoi_data = {}
    for aoi in aois:
        #print "checking:",aoi.aid
        print("Generating features for %s AOI in segment %s" % (aoi.aid, self.segid))
        aoistat = AOI_Stat(aoi, all_data, fixation_data, self.start, self.end, self.length_invalid, aois, event_data, rest_pupil_size, export_pupilinfo)
        self.aoi_data[aoi.aid] = aoistat
        act, _ = aoi.is_active_partition(self.fixation_start, self.fixation_end)
        if act:
            active_aois.append(aoi)
            self.has_aois = True
    print("SEGMENT: active aois in this segment: %d" % len(active_aois))
    if not(active_aois):
        msg = "No active AOIs passed to segment:%s start:%d end:%d" %(self.segid,self.start,self.end)
        warn(msg)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Segment.Segment.set_indices">
    <p>def <span class="ident">set_indices</span>(</p><p>self, sample_st, sample_end, fix_st, fix_end, sac_st=None, sac_end=None, event_st=None, event_end=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Sets the index features</p>
<p>Args:
    sample_st: An integer indicating the index of the first Datapoint for this Segment in the Participant's list of all "Datapoint"s (all_data)
    sample_end: An integer indicating the index of the last Datapoint for this Segment in the Participant's list of all "Datapoint"s (all_data)
    fix_st: An integer indicating the index of the first Fixation for this Segment in the Participant's list of all "Fixation"s (fixation_data)
    fix_end: An integer indicating the index of the last Fixation for this Segment in the Participant's list of all "Fixation"s (fixation_data)
    sac_st: An integer indicating the index of the first Saccade for this Segment in the Participant's list of all "Saccade"s (saccade_data)
    sac_end: An integer indicating the index of the last Saccade for this Segment in the Participant's list of all "Saccade"s (saccade_data)
    event_st: An integer indicating the index of the first Event for this Segment in the Participant's list of all "Event"s (event_data)
    event_end: An integer indicating the index of the last Event for this Segment in the Participant's list of all "Event"s (event_data)</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Segment.Segment.set_indices', this);">Show source &equiv;</a></p>
  <div id="source-Segment.Segment.set_indices" class="source">
    <pre><code>def set_indices(self,sample_st,sample_end,fix_st,fix_end,sac_st=None,sac_end=None,event_st=None,event_end=None):
    """Sets the index features
    Args:
        sample_st: An integer indicating the index of the first Datapoint for this Segment in the Participant's list of all "Datapoint"s (all_data)
        sample_end: An integer indicating the index of the last Datapoint for this Segment in the Participant's list of all "Datapoint"s (all_data)
        fix_st: An integer indicating the index of the first Fixation for this Segment in the Participant's list of all "Fixation"s (fixation_data)
        fix_end: An integer indicating the index of the last Fixation for this Segment in the Participant's list of all "Fixation"s (fixation_data)
        sac_st: An integer indicating the index of the first Saccade for this Segment in the Participant's list of all "Saccade"s (saccade_data)
        sac_end: An integer indicating the index of the last Saccade for this Segment in the Participant's list of all "Saccade"s (saccade_data)
        event_st: An integer indicating the index of the first Event for this Segment in the Participant's list of all "Event"s (event_data)
        event_end: An integer indicating the index of the last Event for this Segment in the Participant's list of all "Event"s (event_data)
    """
    self.sample_start_ind = sample_st
    self.sample_end_ind = sample_end
    self.fixation_start_ind = fix_st
    self.fixation_end_ind = fix_end
    self.saccade_start_ind = sac_st
    self.saccade_end_ind = sac_end
    self.event_start_ind = event_st
    self.event_end_ind = event_end
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
