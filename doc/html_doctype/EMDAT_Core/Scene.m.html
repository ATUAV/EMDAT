<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>Scene API documentation</title>
    <meta name="description" content="UBC Eye Movement Data Analysis Toolkit (EMDAT), Version 3
Created on 2011-09-30

Scene class: captur..." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#Scene.aggregatestddevfeat">aggregatestddevfeat</a></li>
    <li class="mono"><a href="#Scene.maxfeat">maxfeat</a></li>
    <li class="mono"><a href="#Scene.merge_aoi_distance">merge_aoi_distance</a></li>
    <li class="mono"><a href="#Scene.merge_aoi_events">merge_aoi_events</a></li>
    <li class="mono"><a href="#Scene.merge_aoi_fixations">merge_aoi_fixations</a></li>
    <li class="mono"><a href="#Scene.merge_aoi_pupil">merge_aoi_pupil</a></li>
    <li class="mono"><a href="#Scene.merge_aoistats">merge_aoistats</a></li>
    <li class="mono"><a href="#Scene.mergevalues">mergevalues</a></li>
    <li class="mono"><a href="#Scene.minfeat">minfeat</a></li>
    <li class="mono"><a href="#Scene.sumfeat">sumfeat</a></li>
    <li class="mono"><a href="#Scene.weightedmeanfeat">weightedmeanfeat</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#Scene.Scene">Scene</a></span>
        
          
  <ul>
    <li class="mono"><a href="#Scene.Scene.__init__">__init__</a></li>
    <li class="mono"><a href="#Scene.Scene.calc_abs_angles">calc_abs_angles</a></li>
    <li class="mono"><a href="#Scene.Scene.calc_blink_features">calc_blink_features</a></li>
    <li class="mono"><a href="#Scene.Scene.calc_blink_validity_gaps">calc_blink_validity_gaps</a></li>
    <li class="mono"><a href="#Scene.Scene.calc_distance_features">calc_distance_features</a></li>
    <li class="mono"><a href="#Scene.Scene.calc_distances">calc_distances</a></li>
    <li class="mono"><a href="#Scene.Scene.calc_event_features">calc_event_features</a></li>
    <li class="mono"><a href="#Scene.Scene.calc_fix_ang_path_features">calc_fix_ang_path_features</a></li>
    <li class="mono"><a href="#Scene.Scene.calc_largest_validity_gap">calc_largest_validity_gap</a></li>
    <li class="mono"><a href="#Scene.Scene.calc_num_samples">calc_num_samples</a></li>
    <li class="mono"><a href="#Scene.Scene.calc_pupil_features">calc_pupil_features</a></li>
    <li class="mono"><a href="#Scene.Scene.calc_rel_angles">calc_rel_angles</a></li>
    <li class="mono"><a href="#Scene.Scene.calc_saccade_features">calc_saccade_features</a></li>
    <li class="mono"><a href="#Scene.Scene.calc_validity1">calc_validity1</a></li>
    <li class="mono"><a href="#Scene.Scene.calc_validity2">calc_validity2</a></li>
    <li class="mono"><a href="#Scene.Scene.calc_validity3">calc_validity3</a></li>
    <li class="mono"><a href="#Scene.Scene.calc_validity_fixation">calc_validity_fixation</a></li>
    <li class="mono"><a href="#Scene.Scene.calc_validity_proportion">calc_validity_proportion</a></li>
    <li class="mono"><a href="#Scene.Scene.clean_memory">clean_memory</a></li>
    <li class="mono"><a href="#Scene.Scene.generate_aoi_sequence">generate_aoi_sequence</a></li>
    <li class="mono"><a href="#Scene.Scene.get_features">get_features</a></li>
    <li class="mono"><a href="#Scene.Scene.get_indices">get_indices</a></li>
    <li class="mono"><a href="#Scene.Scene.get_length_invalid">get_length_invalid</a></li>
    <li class="mono"><a href="#Scene.Scene.get_validity">get_validity</a></li>
    <li class="mono"><a href="#Scene.Scene.getallgaps">getallgaps</a></li>
    <li class="mono"><a href="#Scene.Scene.getgaps">getgaps</a></li>
    <li class="mono"><a href="#Scene.Scene.getid">getid</a></li>
    <li class="mono"><a href="#Scene.Scene.merge_aoisequences">merge_aoisequences</a></li>
    <li class="mono"><a href="#Scene.Scene.merge_blink_features">merge_blink_features</a></li>
    <li class="mono"><a href="#Scene.Scene.merge_distance_data">merge_distance_data</a></li>
    <li class="mono"><a href="#Scene.Scene.merge_event_data">merge_event_data</a></li>
    <li class="mono"><a href="#Scene.Scene.merge_fixation_features">merge_fixation_features</a></li>
    <li class="mono"><a href="#Scene.Scene.merge_path_angle_features">merge_path_angle_features</a></li>
    <li class="mono"><a href="#Scene.Scene.merge_pupil_features">merge_pupil_features</a></li>
    <li class="mono"><a href="#Scene.Scene.merge_saccade_data">merge_saccade_data</a></li>
    <li class="mono"><a href="#Scene.Scene.print_">print_</a></li>
    <li class="mono"><a href="#Scene.Scene.set_aois">set_aois</a></li>
    <li class="mono"><a href="#Scene.Scene.set_indices">set_indices</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">Scene</span> module</h1>
  <p>UBC Eye Movement Data Analysis Toolkit (EMDAT), Version 3
Created on 2011-09-30</p>
<p>Scene class: capture all "Datapoint"s related to a target
conceptual entity in the experiment.</p>
<p>Authors: Samad Kardan (creator), Sebastien Lalle.
Institution: The University of British Columbia.</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene', this);">Show source &equiv;</a></p>
  <div id="source-Scene" class="source">
    <pre><code>"""
UBC Eye Movement Data Analysis Toolkit (EMDAT), Version 3
Created on 2011-09-30

Scene class: capture all "Datapoint"s related to a target
conceptual entity in the experiment.

Authors: Samad Kardan (creator), Sebastien Lalle.
Institution: The University of British Columbia.
"""
import sys
sys.path.append('.')
sys.path.append('./EMDAT_core')
import math, EMDAT_core.geometry
from EMDAT_core.utils import *
from EMDAT_core.Segment import *
from copy import deepcopy


class Scene(Segment):
    """A Scene is a class that represent one scene in the experiment.

    A Scene is a class that represent one scene in the experiment. The Scene is designed to capture all "Datapoint"s related to a target
    conceptual entity in the experiment. A Scene should have at least one Segment assigned to it. The Scene class is also used to
    combine multiple "Segment"s and calculate the aggregated statistics for this new entity as a whole. This class is the equivalent
    of scenes as defined in Tobii studio.

    Attributes:
        scid: a string containing the Scene ids
        segments: a list of "Segment"s for this Scene

    Attributes inherited from Segment:
        alldata: A list of "Datapoint"s for this Scene
        features: A dict with feature names as its keys and feature values as its values
        completion_time: An integer indicating total duration of the Scene in milliseconds
            minimum is 16 ms (ength of one sample with 60Hz sampling rate (ms)
        start:An integer indicating the Scene's start time in milliseconds
        end: An integer indicating the Scene's end time in milliseconds
        sample_start_ind: An integer indicating the index of the first Datapoint for this Scene in the Participant's list of all "Datapoint"s (all_data)
        sample_end_ind: An integer indicating the index of the last Datapoint for this Scene in the Participant's list of all "Datapoint"s (all_data)
        fixation_start_ind: An integer indicating the index of the first Fixation for this Scene in the Participant's list of all "Fixation"s (fixation_data)
        fixation_end_ind: An integer indicating the index of the first Fixation for this Scene in the Participant's list of all "Fixation"s (fixation_data)
        numfixations: An integer indicating the number of "Fixation"s in this Scene
        time_gaps: a list of tuples of the form (start, end) indicating the start and end of the gaps of invalid samples in the Segement's samples
        largest_data_gap: An integer indicating the length of largest invalid gap for this Scene in milliseconds
        proportion_valid: A float indicating the proportion of valid samples over all the samples in this Scene
        proportion_valid_fix: A float indicating the proportion of (valid + restored) samples over all the samples in this Scene
        validity1: a boolean indicating whether this Scene is valid using proportion of valid samples threshold
        validity2: a boolean indicating whether this Scene is valid using largest acceptable gap threshold
        validity3: a boolean indicating whether this Scene is valid using proportion of (valid + restored) samples threshold
        is_valid: a boolean indicating whether this Scene is considered valid by the validity method indicated by params.VALIDITY_METHOD
        length: An integer indicating total duration of the Scene in milliseconds
        numsamples: An integer indicating total number of samples in the Scene
        fixation_data: A list of "Fixation"s for this Scene
        fixation_start = fixation_data[0].timestamp
        fixation_end = fixation_data[-1].timestamp
        aoi_data: A list of AOI_Stat objects for relevants "AOI"s for this Scene
        has_aois: A boolean indicating if this Scene has AOI features calculated for it

    """


    def __init__(self, scid, seglist, all_data, fixation_data, saccade_data = None, event_data = None, Segments = None, aoilist = None,
                  prune_length= None, require_valid = True, auto_partition = False, rest_pupil_size = 0, export_pupilinfo = False):
        """
        Args:
            scid: A string containing the id of the Scene.

            seglist: a list of tuples of the form (segid, start, end) defining the segments
            *Note: this method of defining segments is implemented to make batch processing of
            files defining segments easier

            all_data: a list of "Datapoint"s which make up this Scene.

            fixation_data: a list of "Fixation"s which make up this Scene.

            saccade_data: If not None, a list of "Saccade"s which make up this Scene.

            event_data: If not None, a list of "Event"s which make up this Scene.

            Segments: a list of "Segment"s which belong to this Scene.

            aoilist: If not None, a list of "AOI"s.

            prune_length: If not None, an integer that specifies the time
                interval (in ms) from the begining of each Segment of this Scene
                which samples are considered in calculations.  This can be used if,
                for example, you only wish to consider data in the first
                1000 ms of each Segment. In this case (prune_length = 1000),
                all data beyond the first 1000ms of the start of the "Segment"s
                will be disregarded.

            require_valid: a boolean determining whether invalid "Segment"s
                will be ignored when calculating the features or not. default = True

            auto_partition: a boolean flag determining whether
                EMDAT should automatically split the "Segment"s which have low sample quality
                into two new ssub "Segment"s discarding the largest invalid sample gap in
                the "Segment". default = False

            rest_pupil_size: rest pupil size for the current scene

        Yields:
            a Scene object
        """

        ########################################
        def partition_segment(new_seg, seg_start, seg_end, rest_pupil_size, export_pupilinfo):
            """ A helper method for splitting a Segment object into new Segments and removing gaps of invalid samples

            One way to deal with a low quality Segment is to find the gaps of invalid samples within its "Datapoint"s and
            splitting the Segment into two Segments one from the beginnning of the Segment to the gap and another from after
            the gap to the end of the Segment. This can be done multiple times resulting multiple "Segment"s with higher
            quality. For example if a Segment S1 started at s1 and ended at e1 and had two invalid gaps between gs1-ge1 and
            gs2-ge2 milliseconds, this method will generate the following three segments
                SS1: starting at s1 and ending at gs1
                SS2: starting at ge1 and ending at gs2
                SS3: starting at ge2 and ending at e1

            Args:
                new_seg: The Segment that is being split

                seg_start: An integer showing the start time of the segment in milliseconds

                seg_end: An integer showing the end time of the segment in milliseconds

                rest_pupil_size: rest pupil size for the current scene

            Returns:
                subsegments: a list of newly generated "Segment"s

                samp_inds: a list of tuples of the form (start, end) that detrmines the index of the start and end of each
                    new Segment in the old Segment's all_data field

                fix_inds: a list of tuples of the form (start, end) that detrmines the index of the start and end of each
                    new Segment in the old Segment's fixation_data field

                sac_inds: a list of tuples of the form (start, end) that detrmines the index of the start and end of each
                    new Segment in the old Segment's saccade_data field

                event_inds: a list of tuples of the form (start, end) that detrmines the index of the start and end of each
                    new Segment in the old Segment's event_data field
            """
            timegaps = new_seg.getgaps()
            subsegments = []
            sub_segid = 0
            samp_inds = []
            fix_inds = []
            saccade_inds = []
            event_inds = []
            last_samp_idx = 0
            last_fix_idx = 0
            last_sac_idx = 0
            last_event_idx = 0
            sub_seg_time_start = seg_start
            for timebounds in timegaps:
                sub_seg_time_end = timebounds[0] #end of this sub_seg is start of this gap
                last_samp_idx, all_start,all_end = get_chunk(all_data, last_samp_idx, sub_seg_time_start, sub_seg_time_end)
                last_fix_idx, fix_start, fix_end = get_chunk(fixation_data, last_fix_idx, sub_seg_time_start, sub_seg_time_end)
                if saccade_data != None:
                    last_sac_idx, sac_start, sac_end = get_chunk(saccade_data, last_sac_idx, sub_seg_time_start, sub_seg_time_end)
                    saccade_data_in_part = saccade_data[sac_start:sac_end]
                else:
                    saccade_data_in_part = None
                if event_data != None:
                    last_event_idx, event_start, event_end = get_chunk(event_data, last_event_idx, sub_seg_time_start, sub_seg_time_end)
                    event_data_in_part = event_data[event_start:event_end]
                else:
                    event_data_in_part = None

                sub_seg_time_start = timebounds[1] #beginning of the next sub_seg is end of this gap
                if fix_end - fix_start>0:
                    try:
                        new_sub_seg = Segment(segid+"_"+str(sub_segid), all_data[all_start:all_end], fixation_data[fix_start:fix_end], saccade_data=saccade_data_in_part,
                                      event_data=event_data_in_part, aois=aoilist, prune_length=prune_length, rest_pupil_size = rest_pupil_size, export_pupilinfo = export_pupilinfo)
                    except  Exception as e:
                        warn(str(e))
                        if params.DEBUG:
                            raise
                        else:
                            continue
                else:
                    continue
                subsegments.append(new_sub_seg)
                samp_inds.append((all_start,all_end))
                fix_inds.append((fix_start, fix_end))
                if saccade_data != None:
                    saccade_inds.append((sac_start, sac_end))
                if event_data != None:
                    event_inds.append((event_start, event_end))
                sub_segid +=1

            # handling the last sub_seg
            sub_seg_time_end = seg_end #end of last sub_seg is the end of seg
            last_samp_idx, all_start,all_end = get_chunk(all_data, last_samp_idx, sub_seg_time_start, sub_seg_time_end)
            last_fix_idx, fix_start, fix_end = get_chunk(fixation_data, last_fix_idx, sub_seg_time_start, sub_seg_time_end)
            if saccade_data != None:
                last_sac_idx, sac_start, sac_end = get_chunk(saccade_data, last_sac_idx, sub_seg_time_start, sub_seg_time_end)
                saccade_data_in_part = saccade_data[sac_start:sac_end]
            else:
                saccade_data_in_part = None
            if event_data != None:
                last_event_idx, event_start, event_end = get_chunk(event_data, last_event_idx, sub_seg_time_start, sub_seg_time_end)
                event_data_in_part = event_data[event_start:event_end]
            else:
                event_data_in_part = None
            if fix_end - fix_start>0: #add the last sub_seg
                try:
                    new_sub_seg = Segment(segid+"_"+str(sub_segid), all_data[all_start:all_end], fixation_data[fix_start:fix_end], saccade_data_in_part,
                                      event_data=event_data_in_part, aois=aoilist, prune_length=prune_length, rest_pupil_size = rest_pupil_size, export_pupilinfo = export_pupilinfo)
                except Exception as e:
                    warn(str(e))
                    if params.DEBUG:
                        raise
                    else:
                        new_sub_seg = None

                if new_sub_seg != None:
                    subsegments.append(new_sub_seg)
                    samp_inds.append((all_start,all_end))
                    fix_inds.append((fix_start, fix_end))
                    if saccade_data != None:
                        saccade_inds.append((sac_start, sac_end))
                    if event_data != None:
                        event_inds.append((event_start, event_end))
            #end of handling the last sub_seg

            return subsegments, samp_inds, fix_inds, saccade_inds, event_inds
        ######################################## end partition_segment()



        if len(all_data)<=0:
            raise Exception('A scene with no sample data!')
        if Segments == None:
            self.segments = []
#            print "seglist",seglist
            for (segid, start, end) in seglist:
                if params.VERBOSE != "QUIET":
                    print("segid, start, end:", segid, start, end)
                # Selecting subsets of points belonging only to the current segment
                if prune_length != None:
                    end = min(end, start+prune_length)
                _, all_start, all_end = get_chunk(all_data, 0, start, end)
                _, fix_start, fix_end = get_chunk(fixation_data, 0, start, end)
                if saccade_data != None:
                    _, sac_start, sac_end = get_chunk(saccade_data, 0, start, end)
                    saccade_data_in_seg = saccade_data[sac_start:sac_end]
                else:
                    sac_start = None
                    sac_end = None
                    saccade_data_in_seg = None
                if event_data != None:
                    _, event_start, event_end = get_chunk(event_data, 0, start, end)
                    event_data_in_seg = event_data[event_start:event_end]
                else:
                    event_start = None
                    event_end = None
                    event_data_in_seg = None

                if fix_end - fix_start>0:
                    try:
                        new_seg = Segment(segid, all_data[all_start:all_end], fixation_data[fix_start:fix_end], saccade_data = saccade_data_in_seg,
							        event_data=event_data_in_seg, aois=aoilist, prune_length=prune_length, rest_pupil_size = rest_pupil_size, export_pupilinfo = export_pupilinfo)
                    except  Exception as e:
                        warn(str(e))
                        if params.DEBUG:
                            raise
                        else:
                            continue
                else:
                    continue

                if (new_seg.largest_data_gap > params.MAX_SEG_TIMEGAP) and auto_partition: #low quality segment that needs to be partitioned!
                    try:
                        new_segs, samp_inds, fix_inds, sac_inds, event_inds = partition_segment(new_seg, start, end, rest_pupil_size, export_pupilinfo=export_pupilinfo)
                        if saccade_data != None and event_data != None:
                            for nseg,samp,fix,sac,eve in zip(new_segs, samp_inds, fix_inds, sac_inds, event_inds):
                                if nseg.length > params.MINSEGSIZE:
                                    nseg.set_indices(samp[0],samp[1],fix[0],fix[1],sac[0],sac[1],eve[0],eve[1])
                                    self.segments.append(nseg)
                        elif saccade_data != None and event_data == None:
                            for nseg,samp,fix,sac in zip(new_segs, samp_inds, fix_inds, sac_inds):
                                if nseg.length > params.MINSEGSIZE:
                                    nseg.set_indices(samp[0],samp[1],fix[0],fix[1],sac[0],sac[1])
                                    self.segments.append(nseg)
                        elif saccade_data == None and event_data != None:
                            for nseg,samp,fix,eve in zip(new_segs, samp_inds, fix_inds, event_inds):
                                if nseg.length > params.MINSEGSIZE:
                                    nseg.set_indices(samp[0],samp[1],fix[0],fix[1],event_st=eve[0],event_end=eve[1])
                                    self.segments.append(nseg)
                        else:
                            for nseg,samp,fix in zip(new_segs, samp_inds, fix_inds):
                                if nseg.length > params.MINSEGSIZE:
                                    nseg.set_indices(samp[0],samp[1],fix[0],fix[1])
                                    self.segments.append(nseg)
                    except Exception as e:
                        raise Exception("Error while partitioning scene. "+str(e))

                else:   #good quality segment OR no auto_partition
                    new_seg.set_indices(all_start,all_end,fix_start,fix_end,sac_start,sac_end,event_start,event_end)
                    self.segments.append(new_seg)
        else:
            self.segments = Segments #segments are already generated

        self.require_valid_Segments = require_valid
        if require_valid:   #filter out the invalid Segments

            segments = filter(lambda x:x.is_valid,self.segments)
        else:
            segments = self.segments
        if len(segments)==0:
            raise Exception('no segments in scene %s!' %(scid))

        fixationlist = []
        saccadelist = []
        totalfixations = 0
        firstsegtime = float('infinity')
        endsegtime = float(0)
        firstseg = None
        for seg in segments:
            sample_st,sample_end,fix_start,fix_end,sac_st,sac_end,event_st,event_end = seg.get_indices()
            if params.DEBUG or params.VERBOSE == "VERBOSE":
                print("sample_st,sample_end,fix_start,fix_end",sample_st,sample_end,fix_start,fix_end,sac_st,sac_end,event_st,event_end)
            fixationlist.append(fixation_data[fix_start:fix_end])
            totalfixations += len(fixationlist[-1])
            if seg.start < firstsegtime:
                firstsegtime = seg.start
                firstseg = seg
            if seg.end > endsegtime:
                endsegtime = seg.end
                endseg = seg
        fixationlist = []

        self.firstseg = firstseg
        self.endseg = endseg
        self.scid = scid
        self.features = {}
        self.largest_data_gap = maxfeat(self.segments,'largest_data_gap')   #self.segments is used to calculate validity of the scenes instead of segments which is only valid segments
        self.proportion_valid = weightedmeanfeat(self.segments,'numsamples','proportion_valid') #self.segments is used to calculate validity of the scenes instead of segments which is only valid segments
        self.proportion_valid_fix = weightedmeanfeat(self.segments,'numsamples','proportion_valid_fix') #self.segments is used to calculate validity of the scenes instead of segments which is only valid segments
        self.validity1 = self.calc_validity1()
        self.validity2 = self.calc_validity2()
        self.validity3 = self.calc_validity3()
        self.is_valid = self.get_validity()

        self.length = sumfeat(segments,"features['length']")
        if self.length == 0:
            raise Exception('Zero length segments!')

        self.length_invalid = self.get_length_invalid()

        self.features['numsegments'] = len(segments)
        self.features['length'] = self.length
        self.start = minfeat(segments,'start')
        self.numfixations = sumfeat(segments,'numfixations')
        self.end = maxfeat(segments,'end')
        self.numsamples = sumfeat(segments, 'numsamples')
        self.features['numsamples'] = self.numsamples

        if prune_length == None:
            if self.numfixations != totalfixations:
                if params.DEBUG:
                    raise Exception('Error in fixation count for scene: '+self.scid)
                else:
                    warn('Error in fixation count for scene: '+self.scid)

        self.merge_fixation_features(segments)

        self.merge_path_angle_features(segments)

        self.merge_blink_features(segments)

        self.merge_pupil_features(export_pupilinfo, segments)

        self.merge_distance_data(segments)

        self.merge_saccade_data(saccade_data, segments)

        self.merge_event_data(event_data, segments)

        self.has_aois = False

        if aoilist:
            self.set_aois(segments, aoilist)

        self.features['aoisequence'] = self.merge_aoisequences(segments)

    def getid(self):
        """Returns the scid for this Scene

        Returns: a string conataining the scid for this Scene
        """
        return self.scid

    def set_aois(self, segments, aois):
        """Sets the "AOI"s relevant to this Scene

        Args:
            segments: a list of "Segment"s which belong to this Scene.

            aois: a list of "AOI"s relevant to this Scene
        """
        if len(aois) == 0 and params.VERBOSE != "QUIET":
            print("No AOI in segment ", self.segid)

        self.aoi_data={}
        for seg in segments:
            for aid in seg.aoi_data.keys():
                    if aid in self.aoi_data:
                        if seg.aoi_data[aid].isActive:
                            self.aoi_data[aid] = merge_aoistats(self.aoi_data[aid],seg.aoi_data[aid], self.features['length'], self.numfixations, self.start)
                    else:
                        self.aoi_data[aid] = deepcopy(seg.aoi_data[aid])
                        if seg.aoi_data[aid].isActive:
                            self.aoi_data[aid].features['timetofirstfixation'] += self.aoi_data[aid].starttime - self.start
                            self.aoi_data[aid].features['timetolastfixation'] += self.aoi_data[aid].starttime - self.start

                            if self.firstseg.aoi_data[aid].features['timetofirstleftclic'] != -1:
                                self.aoi_data[aid].features['timetofirstleftclic'] += self.aoi_data[aid].starttime - self.start
                            if self.firstseg.aoi_data[aid].features['timetofirstrightclic'] != -1:
                                self.aoi_data[aid].features['timetofirstrightclic'] += self.aoi_data[aid].starttime - self.start
                            if self.firstseg.aoi_data[aid].features['timetofirstdoubleclic'] != -1:
                                self.aoi_data[aid].features['timetofirstdoubleclic'] += self.aoi_data[aid].starttime - self.start

                            if self.firstseg.aoi_data[aid].features['timetolastleftclic'] != -1:
                                self.aoi_data[aid].features['timetolastleftclic'] += self.aoi_data[aid].starttime - self.start
                            if self.firstseg.aoi_data[aid].features['timetolastrightclic'] != -1:
                                self.aoi_data[aid].features['timetolastrightclic'] += self.aoi_data[aid].starttime - self.start
                            if self.firstseg.aoi_data[aid].features['timetolastdoubleclic'] != -1:
                                self.aoi_data[aid].features['timetolastdoubleclic'] += self.aoi_data[aid].starttime - self.start
        #Merge stdev
        #For each seg, compute: T = [(numfix-1) * Variance + numfix * power( meanfixduration_in_seg - meanfixduration_in_scene, 2)]
        #At the Scene level: [ SQRT( SUM(T_seg1...Tsegn) / (numfix-1) ]
        for aid in self.aoi_data.keys():
            temp = 0
            numdata = 0
            for seg in segments:
                    temp += (seg.aoi_data[aid].features['numfixations']-1) * seg.aoi_data[aid].variance + seg.aoi_data[aid].features['numfixations'] * math.pow(seg.aoi_data[aid].features['meanfixationduration'] - self.aoi_data[aid].features['meanfixationduration'], 2)
                    numdata += seg.aoi_data[aid].features['numfixations']
            self.aoi_data[aid].features['stddevfixationduration'] = math.sqrt(temp / (numdata-1) ) if numdata > 1 else 0
        """
        firstsegaois = self.firstseg.aoi_data.keys()
        for aid in self.aoi_data.keys():
            if aid in firstsegaois:
                self.aoi_data[aid].features['timetofirstfixation'] = deepcopy(self.firstseg.aoi_data[aid].features['timetofirstfixation'])
                if self.firstseg.aoi_data[aid].features['timetofirstleftclic'] != -1:
                    self.aoi_data[aid].features['timetofirstleftclic'] = deepcopy(self.firstseg.aoi_data[aid].features['timetofirstleftclic'])
                    self.aoi_data[aid].features['timetofirstrightclic'] = deepcopy(self.firstseg.aoi_data[aid].features['timetofirstrightclic'])
                    self.aoi_data[aid].features['timetofirstdoubleclic'] = deepcopy(self.firstseg.aoi_data[aid].features['timetofirstdoubleclic'])
            else:
                self.aoi_data[aid].features['timetofirstfixation'] = float('inf')
                self.aoi_data[aid].features['timetofirstleftclic'] = float('inf')
                self.aoi_data[aid].features['timetofirstrightclic'] = float('inf')
                self.aoi_data[aid].features['timetofirstdoubleclic'] = float('inf')
        """
        if len(self.aoi_data) > 0:
            self.has_aois = True


    def merge_fixation_features(self, segments):
        """ Merge fixation features such as
                meanfixationduration:     mean duration of fixations
                stddevfixationduration    standard deviation of duration of fixations
                sumfixationduration:      sum of durations of fixations
                fixationrate:             rate of fixation datapoints relative to all datapoints
            Args:
                segments: The list of Segments for this Scene with pre-calculated features
        """
        self.numfixations = sumfeat(segments, 'numfixations')
        self.features['numfixations'] = self.numfixations
        self.features['fixationrate'] = float(self.numfixations) / (self.length - self.length_invalid)

        if self.numfixations > 0:
            self.features['meanfixationduration'] = weightedmeanfeat(segments,'numfixations',"features['meanfixationduration']")
            self.features['stddevfixationduration'] = aggregatestddevfeat(segments, 'numfixations', "features['stddevfixationduration']", "features['meanfixationduration']", self.features['meanfixationduration'])
            self.features['sumfixationduration'] = sumfeat(segments, "features['sumfixationduration']")
            self.features['fixationrate'] = float(self.numfixations)/(self.length - self.length_invalid)
        else:
            self.features['meanfixationduration'] = -1
            self.features['stddevfixationduration'] = -1
            self.features['sumfixationduration'] = -1
            self.features['fixationrate'] = -1


    def merge_path_angle_features(self, segments):
        """ Merge path and angle features such as
                meanpathdistance:         mean of path distances
                sumpathdistance:          sum of path distances
                eyemovementvelocity:      average eye movement velocity
                sumabspathangles:         sum of absolute path angles
                abspathanglesrate:        ratio of absolute path angles relative to all datapoints
                stddevabspathangles:      standard deviation of absolute path angles
                sumrelpathangles:         sum of relative path angles
                relpathanglesrate:        ratio of relative path angles relative to all datapoints
                stddevrelpathangles:      standard deviation of relative path angles
            Args:
                segments: The list of Segments for this Scene with pre-calculated features
        """
        self.numfixdistances = sumfeat(segments, "numfixdistances")
        self.numabsangles = sumfeat(segments, "numabsangles")
        self.numrelangles = sumfeat(segments, "numrelangles")

        if self.numfixations > 1:
            self.features['meanpathdistance'] = weightedmeanfeat(segments,'numfixdistances',"features['meanpathdistance']")
            self.features['sumpathdistance'] = sumfeat(segments, "features['sumpathdistance']")
            self.features['stddevpathdistance'] = aggregatestddevfeat(segments, 'numfixdistances', "features['stddevpathdistance']", "features['meanpathdistance']", self.features['meanpathdistance'])
            self.features['eyemovementvelocity'] = self.features['sumpathdistance']/(self.length - self.length_invalid)
            self.features['sumabspathangles'] = sumfeat(segments, "features['sumabspathangles']")
            self.features['meanabspathangles'] = weightedmeanfeat(segments,'numabsangles',"features['meanabspathangles']")
            self.features['abspathanglesrate'] = self.features['sumabspathangles']/(self.length - self.length_invalid)
            self.features['stddevabspathangles'] = aggregatestddevfeat(segments, 'numabsangles', "features['stddevabspathangles']", "features['meanabspathangles']", self.features['meanabspathangles'])
            self.features['sumrelpathangles'] = sumfeat(segments, "features['sumrelpathangles']")
            self.features['meanrelpathangles'] = weightedmeanfeat(segments,'numrelangles',"features['meanrelpathangles']")
            self.features['relpathanglesrate'] = self.features['sumrelpathangles']/(self.length - self.length_invalid)
            self.features['stddevrelpathangles'] = aggregatestddevfeat(segments, 'numrelangles', "features['stddevrelpathangles']", "features['meanrelpathangles']", self.features['meanrelpathangles'])
        else:
            self.features['meanpathdistance'] = -1
            self.features['sumpathdistance'] = -1
            self.features['stddevpathdistance'] = -1
            self.features['eyemovementvelocity'] = -1
            self.features['sumabspathangles'] = -1
            self.features['abspathanglesrate'] = -1
            self.features['meanabspathangles']= -1
            self.features['stddevabspathangles']= -1
            self.features['sumrelpathangles'] = -1
            self.features['relpathanglesrate'] = -1
            self.features['meanrelpathangles']= -1
            self.features['stddevrelpathangles'] = -1


    def merge_blink_features(self, segments):
        """ Merge blink features asuch as
                blink_num:                 number of blinks
                blink_duration_total:       sum of the blink durations
                blink_duration_mean:        mean of the blink durations
                blink_duration_std:         standard deviation of blink durations
                blink_duration_max:         maximal blink duration
                blink_duration_min:         minimal blink duration
                blink_rate:                 rate of blinks
                blink_time_distance_mean:   mean time difference between consequtive blinks
                blink_time_distance_std:    std time difference between consequtive blinks
                blink_time_distance_min:    minimal time difference between consequtive blinks
                blink_time_distance_max:    maximal time difference between consequtive blinks
            Args:
                segments: The list of Segments for this Scene with pre-calculated features
        """
        self.features['blinknum'] = sumfeat(segments, "features['blinknum']")
        if self.features['blinknum'] > 0:
            self.features['blinkdurationtotal']     = sumfeat(segments, "features['blinkdurationtotal']")
            self.features['blinkdurationmean']      = weightedmeanfeat(segments, "features['blinknum']", "features['blinkdurationmean']")
            self.features['blinkdurationstd']       = aggregatestddevfeat(segments, "features['blinknum']", "features['blinkdurationstd']",
                                                      "features['blinkdurationmean']", self.features['blinkdurationmean'])
            self.features['blinkdurationmin']       = minfeat(segments, "features['blinkdurationmin']", -1)
            self.features['blinkdurationmax']       = maxfeat(segments, "features['blinkdurationmax']")
            self.features['blinkrate']              = float(self.features['blinknum']) / (self.length - self.length_invalid)
            self.features['blinktimedistancemean']  = weightedmeanfeat(segments,
                                                      "features['blinknum']", "features['blinktimedistancemean']")
            self.features['blinktimedistancestd']   = aggregatestddevfeat(segments, "features['blinknum']",
                                                      "features['blinktimedistancestd']", "features['blinktimedistancemean']",
                                                      self.features['blinktimedistancemean'])
            self.features['blinktimedistancemin']   = minfeat(segments, "features['blinktimedistancemin']", -1)
            self.features['blinktimedistancemax']   = maxfeat(segments, "features['blinktimedistancemax']")
        else:
            self.features['blinkdurationtotal']     = -1
            self.features['blinkdurationmean']      = -1
            self.features['blinkdurationstd']       = -1
            self.features['blinkdurationmin']       = -1
            self.features['blinkdurationmax']       = -1
            self.features['blinkrate']              = -1
            self.features['blinktimedistancemean']  = -1
            self.features['blinktimedistancestd']   = -1
            self.features['blinktimedistancemin']   = -1
            self.features['blinktimedistancemax']   = -1


    def merge_pupil_features(self, export_pupilinfo, segments):
        """ Merge pupil features asuch as
                mean_pupil_size:            mean of pupil sizes
                stddev_pupil_size:          standard deviation of pupil sizes
                min_pupil_size:             smallest pupil size
                max_pupil_size:             largest pupil size
                mean_pupil_velocity:        mean of pupil velocities
                stddev_pupil_velocity:      standard deviation of pupil velocities
                min_pupil_velocity:         smallest pupil velocity
                max_pupil_velocity:         largest pupil velocity
            Args:
                segments: The list of Segments for this Scene with pre-calculated features
                export_pupilinfo: True to export raw pupil data in EMDAT output (False by default).
        """
        self.numpupilsizes    = sumfeat(segments,'numpupilsizes')
        self.numpupilvelocity = sumfeat(segments,'numpupilvelocity')

        if self.numpupilsizes > 0: # check if scene has any pupil data
            if export_pupilinfo:
                self.pupilinfo_for_export = mergevalues(segments, 'pupilinfo_for_export')
            self.features['meanpupilsize'] = weightedmeanfeat(segments, 'numpupilsizes', "features['meanpupilsize']")
            self.features['stddevpupilsize'] = aggregatestddevfeat(segments, 'numpupilsizes', "features['stddevpupilsize']", "features['meanpupilsize']", self.features['meanpupilsize']) #stddev(self.adjvalidpupilsizes)
            self.features['maxpupilsize'] = maxfeat(segments, "features['maxpupilsize']")
            self.features['minpupilsize'] = minfeat(segments, "features['minpupilsize']", -1)
            self.features['startpupilsize'] = self.firstseg.features['startpupilsize']
            self.features['endpupilsize'] = self.endseg.features['endpupilsize']
        else:
            self.pupilinfo_for_export = []
            self.features['meanpupilsize'] = -1
            self.features['stddevpupilsize'] = -1
            self.features['maxpupilsize'] = -1
            self.features['minpupilsize'] = -1
            self.features['startpupilsize'] = -1
            self.features['endpupilsize'] = -1

        if self.numpupilvelocity > 0: # check if scene has any pupil velocity data
            self.features['meanpupilvelocity'] = weightedmeanfeat(segments, 'numpupilvelocity', "features['meanpupilvelocity']")
            self.features['stddevpupilvelocity'] = aggregatestddevfeat(segments, 'numpupilvelocity', "features['stddevpupilvelocity']", "features['meanpupilvelocity']", self.features['meanpupilvelocity']) #stddev(self.valid_pupil_velocity)
            self.features['maxpupilvelocity'] = maxfeat(segments, "features['maxpupilvelocity']")
            self.features['minpupilvelocity'] = minfeat(segments, "features['minpupilvelocity']", -1)
        else:
            self.features['meanpupilvelocity'] = -1
            self.features['stddevpupilvelocity'] = -1
            self.features['maxpupilvelocity'] = -1
            self.features['minpupilvelocity'] = -1


    def merge_distance_data(self, segments):
        """ Merge distance features such as
                mean_distance:            mean of distances from the screen
                stddev_distance:          standard deviation of distances from the screen
                min_distance:             smallest distance from the screen
                max_distance:             largest distance from the screen
                start_distance:           distance from the screen in the beginning of this scene
                end_distance:             distance from the screen in the end of this scene

            Args:
                segments: The list of Segments for this Scene with pre-calculated features
        """
        self.numdistancedata = sumfeat(segments,'numdistancedata') #Distance
        if self.numdistancedata > 0: # check if scene has any pupil data
            self.features['meandistance'] = weightedmeanfeat(segments, 'numdistancedata', "features['meandistance']")
            self.features['stddevdistance'] = aggregatestddevfeat(segments, 'numdistancedata', "features['stddevdistance']", "features['meandistance']", self.features['meandistance'])
            self.features['maxdistance'] = maxfeat(segments, "features['maxdistance']")
            self.features['mindistance'] = minfeat(segments, "features['mindistance']", -1)
            self.features['startdistance'] = self.firstseg.features['startdistance']
            self.features['enddistance'] = self.endseg.features['enddistance']
        else:
            self.features['meandistance'] = -1
            self.features['stddevdistance'] = -1
            self.features['maxdistance'] = -1
            self.features['mindistance'] = -1
            self.features['startdistance'] = -1
            self.features['enddistance'] = -1


    def merge_saccade_data(self, saccade_data, segments):
        """ Merge saccade features such as
                numsaccades:              number of saccades in the segment
                sumsaccadedistance:       sum of distances during each saccade
                meansaccadedistance:      mean of distances during each saccade
                stddevsaccadedistance:    standard deviation of distances during each saccade
                longestsaccadedistance:   distance of longest saccade
                sumsaccadeduration:       total time spent on saccades in this segment
                meansaccadeduration:      average saccade duration
                stddevsaccadeduration:    standard deviation of saccade durations
                longestsaccadeduration:   longest duration of saccades in this segment
                meansaccadespeed:         average speed of saccades in this segment
                stddevsaccadespeed:       standard deviation of speed of saccades in this segment
                maxsaccadespeed:          highest saccade speed in this segment
                minsaccadespeed:          lowest saccade speed in this  segment
                fixationsaccadetimeratio: fixation to saccade time ratio for this segment
            Args:
                saccade_data: The list of saccade datapoints for this Scene
                segments: The list of Segments for this Scene with pre-calculated features
        """
        if saccade_data != None:
            self.features['numsaccades'] = sumfeat(segments,'numsaccades')
            self.features['sumsaccadedistance'] = sumfeat(segments, "features['sumsaccadedistance']")
            self.features['meansaccadedistance'] = weightedmeanfeat(self.segments,'numsaccades',"features['meansaccadedistance']")
            self.features['stddevsaccadedistance'] = aggregatestddevfeat(segments, 'numsaccades', "features['stddevsaccadedistance']", "features['meansaccadedistance']", self.features['meansaccadedistance'])
            self.features['longestsaccadedistance'] = maxfeat(segments, "features['longestsaccadedistance']")
            self.features['sumsaccadeduration'] = sumfeat(segments,"features['sumsaccadeduration']")
            self.features['meansaccadeduration'] = weightedmeanfeat(self.segments,'numsaccades',"features['meansaccadeduration']")
            self.features['stddevsaccadeduration'] = aggregatestddevfeat(segments, 'numsaccades', "features['stddevsaccadeduration']", "features['meansaccadeduration']", self.features['meansaccadeduration'])
            self.features['longestsaccadeduration'] = maxfeat(segments, "features['longestsaccadeduration']")
            self.features['meansaccadespeed'] = weightedmeanfeat(self.segments,'numsaccades',"features['meansaccadespeed']")
            self.features['stddevsaccadespeed'] = aggregatestddevfeat(segments, 'numsaccades', "features['stddevsaccadespeed']", "features['meansaccadespeed']", self.features['meansaccadespeed'])
            self.features['maxsaccadespeed'] = maxfeat(segments, "features['maxsaccadespeed']")
            self.features['minsaccadespeed'] = minfeat(segments, "features['minsaccadespeed']", -1)
            self.features['fixationsaccadetimeratio'] = sumfeat(segments, "features['fixationsaccadetimeratio']") / float(len(segments))
        else:
            self.features['numsaccades'] = 0
            self.features['sumsaccadedistance'] = -1
            self.features['meansaccadedistance'] = -1
            self.features['stddevsaccadedistance'] = -1
            self.features['longestsaccadedistance'] = -1
            self.features['sumsaccadeduration'] = -1
            self.features['meansaccadeduration'] = -1
            self.features['stddevsaccadeduration'] = -1
            self.features['longestsaccadeduration'] = -1
            self.features['meansaccadespeed'] = -1
            self.features['stddevsaccadespeed'] = -1
            self.features['maxsaccadespeed'] = -1
            self.features['minsaccadespeed'] = -1
            self.features['fixationsaccadetimeratio'] = -1


    def merge_event_data(self, event_data, segments):
        """ Merge event features such as
                numevents:                number of events in the segment
                numleftclic:              number of left clinks in the segment
                numrightclic:             number of right clinks in the segment
                numdoubleclic:            number of double clinks in the segment
                numkeypressed:            number of times a key was pressed in the segment
                leftclicrate:             the rate of left clicks (relative to all datapoints) in this segment
                rightclicrate:            the rate of right clicks (relative to all datapoints) in this segment
                doubleclicrate:           the rate of double clicks (relative to all datapoints) in this segment
                keypressedrate:           the rate of key presses (relative to all datapoints) in this segment
                timetofirstleftclic:      time until the first left click in this segment
                timetofirstrightclic:     time until the first right click in this segment
                timetofirstdoubleclic:    time until the first double click in this segment
                timetofirstkeypressed:    time until the first key pressed in this segment
            Args:
                event_data: The list of events for this Scene
                segments: The list of Segments for this Scene with pre-calculated features
        """
        if event_data != None:
            self.features['numevents'] = sumfeat(segments,'numevents')
            self.features['numleftclic'] = sumfeat(segments,"features['numleftclic']")
            self.features['numrightclic'] = sumfeat(segments, "features['numrightclic']")
            self.features['numdoubleclic'] = sumfeat(segments, "features['numdoubleclic']")
            self.features['numkeypressed'] = sumfeat(segments, "features['numkeypressed']")
            self.features['leftclicrate'] = float(self.features['numleftclic'])/(self.length - self.length_invalid)
            self.features['rightclicrate'] = float(self.features['numrightclic'])/(self.length - self.length_invalid)
            self.features['doubleclicrate'] = float(self.features['numdoubleclic'])/(self.length - self.length_invalid)
            self.features['keypressedrate'] = float(self.features['numkeypressed'])/(self.length - self.length_invalid)
            self.features['timetofirstleftclic'] = self.firstseg.features['timetofirstleftclic']
            self.features['timetofirstrightclic'] = self.firstseg.features['timetofirstrightclic']
            self.features['timetofirstdoubleclic'] = self.firstseg.features['timetofirstdoubleclic']
            self.features['timetofirstkeypressed'] = self.firstseg.features['timetofirstkeypressed']
        else:
            self.features['numevents'] = 0
            self.features['numleftclic'] = 0
            self.features['numrightclic'] = 0
            self.features['numdoubleclic'] = 0
            self.features['numkeypressed'] = 0
            self.features['leftclicrate'] = -1
            self.features['rightclicrate'] = -1
            self.features['doubleclicrate'] = -1
            self.features['keypressedrate'] = -1
            self.features['timetofirstleftclic'] = -1
            self.features['timetofirstrightclic'] = -1
            self.features['timetofirstdoubleclic'] = -1
            self.features['timetofirstkeypressed'] = -1

    def merge_aoisequences(self, segments):
        """returns the AOI sequence merged from the AOI sequences in the "Segment"s
        Args:
            segments: a list of "Segment"s which belong to this Scene.
        Returns:
            a list of AOI names that correspond to the sequence of "Fixation"s in this Scene
        """
        sequence = []
        for seg in segments:
            sequence.extend(seg.features.get('aoisequence', []))
        return sequence

    def get_length_invalid(self):
        length = 0
        for segment in self.segments:
            length += segment.length_invalid
        return length

    def clean_memory(self):
        return
        #for seg in self.segments:
        #   seg.adjvalidpupilsizes = []
        #    seg.distances_from_screen = []
        #self.adjvalidpupilsizes = []
        #self.distances_from_screen = []

def merge_aoistats(main_AOI_Stat,new_AOI_Stat,total_time,total_numfixations,sc_start=0):
        """a helper method that updates the AOI_Stat object of this Scene with a new AOI_Stat object

        Args:
            main_AOI_Stat: AOI_Stat object of this Scene (must have been initialised)

            new_AOI_Stat: a new AOI_Stat object

            total_time: duration of the scene

            total_numfixations: number of fixations in the scene

            sc_start: start time (timestamp) of the scene

        Returns:
            the updated AOI_Sata object
        """
        maois = main_AOI_Stat
        merge_aoi_fixations(maois, new_AOI_Stat, total_time, total_numfixations, sc_start)
        #calculating the transitions to and from this AOI and other active AOIs at the moment
        new_AOI_Stat_transition_aois = filter(lambda x: x.startswith('numtransfrom_'), new_AOI_Stat.features.keys())
        if params.DEBUG or params.VERBOSE == "VERBOSE":
            print("Segment's transition_aois", new_AOI_Stat_transition_aois)

        merge_aoi_events(maois, new_AOI_Stat, total_time, sc_start)

        maois.total_trans_from += new_AOI_Stat.total_trans_from   #updating the total number of transition from this AOI
        for feat in new_AOI_Stat_transition_aois:
            if feat in maois.features:
                maois.features[feat] += new_AOI_Stat.features[feat]
            else:
                maois.features[feat] = new_AOI_Stat.features[feat]
#               sumtransfrom += maois.features[feat]

        merge_aoi_distance(maois, new_AOI_Stat)
        merge_aoi_pupil(maois, new_AOI_Stat)
        # updating the proportion tansition features based on new transitions to and from this AOI
        maois_transition_aois = filter(lambda x: x.startswith('numtransfrom_'),maois.features.keys()) #all the transition features for this AOI should be aupdated even if they are not active for this segment
        for feat in maois_transition_aois:
            aid = feat[len('numtransfrom_'):]
            if maois.total_trans_from > 0:
                maois.features['proptransfrom_%s'%(aid)] = float(maois.features[feat]) / maois.total_trans_from
            else:
                maois.features['proptransfrom_%s'%(aid)] = 0
        ###endof transition calculation
        return maois


def merge_aoi_fixations(maois, new_AOI_Stat, total_time, total_numfixations, sc_start):
    """ Merge fixation features such as
            meanfixationduration:     mean duration of fixations
            stddevfixationduration    standard deviation of duration of fixations
            sumfixationduration:      sum of durations of fixations
            fixationrate:             rate of fixation datapoints relative to all datapoints
        Args:
            main_AOI_Stat: AOI_Stat object of this Scene (must have been initialised)

            new_AOI_Stat: a new AOI_Stat object

            total_time: duration of the scene

            total_numfixations: number of fixations in the scene

            sc_start: start time (timestamp) of the scene
    """
    if new_AOI_Stat.features['numfixations'] > 0:
        aoi_list = [maois, new_AOI_Stat]
        numfixations = sumfeat(aoi_list, "features['numfixations']")
        maois.features['longestfixation'] = maxfeat(aoi_list, "features['longestfixation']")
        maois.features['totaltimespent'] += new_AOI_Stat.features['totaltimespent']
        aggregate_meanfixationduration = maois.features['totaltimespent'] / numfixations
        maois.features['stddevfixationduration'] = aggregatestddevfeat(aoi_list, "features['numfixations']", "features['stddevfixationduration']", "features['meanfixationduration']", aggregate_meanfixationduration)
        maois.features['numfixations'] +=  new_AOI_Stat.features['numfixations']
        maois.features['meanfixationduration'] = aggregate_meanfixationduration
        maois.features['proportiontime'] = float(maois.features['totaltimespent'])/total_time
        maois.features['proportionnum'] = float(maois.features['numfixations'])/total_numfixations

        if maois.features['totaltimespent'] > 0:
            maois.features['fixationrate'] = float(maois.features['numfixations']) / maois.features['totaltimespent']
        else:
            maois.features['fixationrate'] = -1

        if new_AOI_Stat.features['timetofirstfixation'] != -1:
            maois.features['timetofirstfixation'] = min(maois.features['timetofirstfixation'], deepcopy(new_AOI_Stat.features['timetofirstfixation']) + new_AOI_Stat.starttime - sc_start)
        if new_AOI_Stat.features['timetolastfixation'] != -1:
            maois.features['timetolastfixation'] = max(maois.features['timetolastfixation'], deepcopy(new_AOI_Stat.features['timetolastfixation']) + new_AOI_Stat.starttime - sc_start)


def merge_aoi_distance(maois, new_AOI_Stat):
    """ Merge distance features such as
            mean_distance:            mean of distances from the screen
            stddev_distance:          standard deviation of distances from the screen
            min_distance:             smallest distance from the screen
            max_distance:             largest distance from the screen
            start_distance:           distance from the screen in the beginning of this scene
            end_distance:             distance from the screen in the end of this scene

        Args:
            maois: AOI_Stat object of this Scene (must have been initialised)
            new_AOI_Stat: a new AOI_Stat object
    """
    aoi_list = [maois, new_AOI_Stat]
    if new_AOI_Stat.numdistancedata > 0:
        total_distances = sumfeat(aoi_list, 'numdistancedata')
        aggregate_mean_distance = weightedmeanfeat(aoi_list, 'numdistancedata', "features['meandistance']")
        maois.features['stddevdistance'] = aggregatestddevfeat(aoi_list, 'numdistancedata', "features['stddevdistance']",
                                                                    "features['meandistance']", aggregate_mean_distance)
        maois.features['maxdistance'] = maxfeat(aoi_list, "features['maxdistance']")
        maois.features['mindistance'] = minfeat(aoi_list, "features['mindistance']")
        maois.features['meandistance'] = aggregate_mean_distance
        if maois.starttime > new_AOI_Stat.starttime:
            maois.features['startdistance'] = new_AOI_Stat.features['startdistance']
        if maois.endtime < new_AOI_Stat.endtime:
            maois.features['enddistance'] = new_AOI_Stat.features['enddistance']
        maois.numdistancedata += new_AOI_Stat.numdistancedata

def merge_aoi_pupil(maois, new_AOI_Stat):
    """ Merge pupil features asuch as
            mean_pupil_size:            mean of pupil sizes
            stddev_pupil_size:          standard deviation of pupil sizes
            min_pupil_size:             smallest pupil size
            max_pupil_size:             largest pupil size
            mean_pupil_velocity:        mean of pupil velocities
            stddev_pupil_velocity:      standard deviation of pupil velocities
            min_pupil_velocity:         smallest pupil velocity
            max_pupil_velocity:         largest pupil velocity
        Args:
            maois: AOI_Stat object of this Scene (must have been initialised)
            new_AOI_Stat: a new AOI_Stat object
    """
    aoi_list = [maois, new_AOI_Stat]
    if (new_AOI_Stat.numpupilsizes > 0):
        aggregate_mean_pupil = weightedmeanfeat(aoi_list, 'numpupilsizes', "features['meanpupilsize']")
        maois.features['stddevpupilsize'] = aggregatestddevfeat(aoi_list, 'numpupilsizes', "features['stddevpupilsize']",
                                                                        "features['meanpupilsize']", aggregate_mean_pupil)
        maois.features['maxpupilsize'] = maxfeat(aoi_list, "features['maxpupilsize']")
        maois.features['minpupilsize'] = minfeat(aoi_list, "features['minpupilsize']")
        maois.features['meanpupilsize'] = aggregate_mean_pupil
        if maois.starttime > new_AOI_Stat.starttime:
            maois.features['startpupilsize'] = new_AOI_Stat.features['startpupilsize']
        if maois.endtime < new_AOI_Stat.endtime:
            maois.features['endpupilsize'] = new_AOI_Stat.features['endpupilsize']
        maois.numpupilsizes += new_AOI_Stat.numpupilsizes

    if (new_AOI_Stat.numpupilvelocity > 0):
        aggregate_mean_velocity =  weightedmeanfeat(aoi_list, 'numpupilvelocity', "features['meanpupilvelocity']")
        maois.features['stddevpupilvelocity'] = aggregatestddevfeat(aoi_list, 'numpupilvelocity', "features['stddevpupilvelocity']",
                                                                        "features['meanpupilvelocity']", aggregate_mean_velocity)
        maois.features['maxpupilvelocity'] = maxfeat(aoi_list, "features['maxpupilvelocity']")
        maois.features['minpupilvelocity'] = minfeat(aoi_list, "features['minpupilvelocity']")
        maois.features['meanpupilvelocity'] = aggregate_mean_velocity
        maois.numpupilvelocity += new_AOI_Stat.numpupilvelocity

def merge_aoi_events(maois, new_AOI_Stat, total_time, sc_start):
    """ Merge event features such as
            numevents:                number of events in the segment
            numleftclic:              number of left clinks in the segment
            numrightclic:             number of right clinks in the segment
            numdoubleclic:            number of double clinks in the segment
            numkeypressed:            number of times a key was pressed in the segment
            leftclicrate:             the rate of left clicks (relative to all datapoints) in this segment
            rightclicrate:            the rate of right clicks (relative to all datapoints) in this segment
            doubleclicrate:           the rate of double clicks (relative to all datapoints) in this segment
            keypressedrate:           the rate of key presses (relative to all datapoints) in this segment
            timetofirstleftclic:      time until the first left click in this segment
            timetofirstrightclic:     time until the first right click in this segment
            timetofirstdoubleclic:    time until the first double click in this segment
            timetofirstkeypressed:    time until the first key pressed in this segment
        Args:
            maois: AOI_Stat object of this Scene (must have been initialised)
            new_AOI_Stat: a new AOI_Stat object
            total_time: duration of the scene
            sc_start: start time (timestamp) of the scene
    """
    if new_AOI_Stat.features['numevents']>0:
        maois.features['numevents'] += new_AOI_Stat.features['numevents']
        maois.features['numleftclic'] += new_AOI_Stat.features['numleftclic']
        maois.features['numrightclic'] += new_AOI_Stat.features['numrightclic']
        maois.features['numdoubleclic'] += new_AOI_Stat.features['numdoubleclic']
        maois.features['leftclicrate'] = float(maois.features['numleftclic'])/total_time
        maois.features['rightclicrate'] = float(maois.features['numrightclic'])/total_time
        maois.features['doubleclicrate'] = float(maois.features['numdoubleclic'])/total_time

        if new_AOI_Stat.features['timetofirstleftclic'] != -1:
            maois.features['timetofirstleftclic'] = min(maois.features['timetofirstleftclic'], deepcopy(new_AOI_Stat.features['timetofirstleftclic']) + new_AOI_Stat.starttime - sc_start)
        if new_AOI_Stat.features['timetofirstrightclic'] != -1:
            maois.features['timetofirstrightclic'] = min(maois.features['timetofirstrightclic'], deepcopy(new_AOI_Stat.features['timetofirstrightclic']) + new_AOI_Stat.starttime - sc_start)
        if new_AOI_Stat.features['timetofirstdoubleclic'] != -1:
            maois.features['timetofirstdoubleclic'] = min(maois.features['timetofirstdoubleclic'], deepcopy(new_AOI_Stat.features['timetofirstdoubleclic']) + new_AOI_Stat.starttime - sc_start)

        if new_AOI_Stat.features['timetolastleftclic'] != -1:
            maois.features['timetolastleftclic'] = max(maois.features['timetolastleftclic'], deepcopy(new_AOI_Stat.features['timetolastleftclic']) + new_AOI_Stat.starttime - sc_start)
        if new_AOI_Stat.features['timetolastrightclic'] != -1:
            maois.features['timetolastrightclic'] = max(maois.features['timetolastrightclic'], deepcopy(new_AOI_Stat.features['timetolastrightclic']) + new_AOI_Stat.starttime - sc_start)
        if new_AOI_Stat.features['timetolastdoubleclic'] != -1:
            maois.features['timetolastdoubleclic'] = max(maois.features['timetolastdoubleclic'], deepcopy(new_AOI_Stat.features['timetolastdoubleclic']) + new_AOI_Stat.starttime - sc_start)


def weightedmeanfeat(obj_list, totalfeat,ratefeat):
    """a helper method that calculates the weighted average of a target feature over a list of Segments

    Args:
        obj_list: a list of Segments which all have a numeric field for which the weighted average is calculated

        totalfeat: a string containing the name of the feature that has the total value of the target feature

        ratefeat: a string containing the name of the feature that has the rate value of the target feature

    Returns:
        the weighted average of the ratefeat over the Segments
    """
    num_valid = float(0)
    num = 0

    for obj in obj_list:
        t = eval('obj.'+totalfeat)
        num_valid += t * eval('obj.'+ratefeat)
        num += t
    if num != 0:
        return num_valid / num
    return 0

def aggregatestddevfeat(obj_list, totalfeat, sdfeat, meanfeat, meanscene):
    """a helper method that calculates the aggregated standard deviation of a target feature over a list of Segments

    Args:
        obj_list: a list of Segments which all have a numeric field for which the stdev is calculated

        totalfeat: a string containing the name of the feature that has the total value of the target feature

        ratefeat: a string containing the name of the feature that has the rate value of the target feature

    Returns:
        the weighted average of the ratefeat over the Segments
    """
    num = float(0)
    den = float(0)

    for obj in obj_list:
        t = eval('obj.'+totalfeat)
        if t > 0:
            sd = eval('obj.'+sdfeat)
            if math.isnan(sd): sd = 0
            meanobj = eval('obj.'+meanfeat)

            num += (t-1) * sd**2 + t * (meanobj-meanscene)**2
            den += t

    if den > 1:
        return math.sqrt(float(num)/(den-1))
    return 0

def sumfeat(obj_list, feat):
    """a helper method that calculates the sum of a target feature over a list of objects

    Args:

        obj_list: a list of objects

        feat: a string containing the name of the target feature

    Returns:
        the sum of the target feature over the given list of objects
    """
    sum = 0
    for obj in obj_list:
        sum += eval('obj.'+feat)
    return sum

def minfeat(obj_list, feat, nonevalue = None):
    """a helper method that calculates the min of a target feature over a list of objects

    Args:

        obj_list: a list of objects

        feat: a string containing the name of the target feature

        nonevalue: value to be ignored when computing the min (typically -1 in EMDAT)

    Returns:
        the min of the target feature over the given list of objects
    """
    min = float('+infinity')
    for obj in obj_list:
        val = eval('obj.'+feat)
        if min > val and val != nonevalue:
            min = val
    return min

def maxfeat(obj_list, feat):
    """a helper method that calculates the max of a target feature over a list of objects

    Args:

        obj_list: a list of objects

        feat: a string containing the name of the target feature

    Returns:
        the max of the target feature over the given list of objects
    """
    max = float('-infinity')
    for obj in obj_list:
        val = eval('obj.'+feat)
        if max < val:
            max = val
    return max

def mergevalues(obj_list, field):
    """a helper method that merges lists of values stored in field

    Args:

        obj_list: a list of objects

        field: name of a field that contains a list of values (string)

    Returns:
        a list formed by merging corresponding lists from collection of subjects
    """
    mergedlist = []
    for obj in obj_list:
        mergedlist.extend(eval('obj.'+ field))
    return mergedlist
</code></pre>
  </div>

  </header>

  <section id="section-items">

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="Scene.aggregatestddevfeat">
    <p>def <span class="ident">aggregatestddevfeat</span>(</p><p>obj_list, totalfeat, sdfeat, meanfeat, meanscene)</p>
    </div>
    

    
  
    <div class="desc"><p>a helper method that calculates the aggregated standard deviation of a target feature over a list of Segments</p>
<p>Args:
    obj_list: a list of Segments which all have a numeric field for which the stdev is calculated</p>
<pre><code>totalfeat: a string containing the name of the feature that has the total value of the target feature

ratefeat: a string containing the name of the feature that has the rate value of the target feature
</code></pre>
<p>Returns:
    the weighted average of the ratefeat over the Segments</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.aggregatestddevfeat', this);">Show source &equiv;</a></p>
  <div id="source-Scene.aggregatestddevfeat" class="source">
    <pre><code>def aggregatestddevfeat(obj_list, totalfeat, sdfeat, meanfeat, meanscene):
    """a helper method that calculates the aggregated standard deviation of a target feature over a list of Segments

    Args:
        obj_list: a list of Segments which all have a numeric field for which the stdev is calculated

        totalfeat: a string containing the name of the feature that has the total value of the target feature

        ratefeat: a string containing the name of the feature that has the rate value of the target feature

    Returns:
        the weighted average of the ratefeat over the Segments
    """
    num = float(0)
    den = float(0)

    for obj in obj_list:
        t = eval('obj.'+totalfeat)
        if t > 0:
            sd = eval('obj.'+sdfeat)
            if math.isnan(sd): sd = 0
            meanobj = eval('obj.'+meanfeat)

            num += (t-1) * sd**2 + t * (meanobj-meanscene)**2
            den += t

    if den > 1:
        return math.sqrt(float(num)/(den-1))
    return 0
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="Scene.maxfeat">
    <p>def <span class="ident">maxfeat</span>(</p><p>obj_list, feat)</p>
    </div>
    

    
  
    <div class="desc"><p>a helper method that calculates the max of a target feature over a list of objects</p>
<p>Args:</p>
<pre><code>obj_list: a list of objects

feat: a string containing the name of the target feature
</code></pre>
<p>Returns:
    the max of the target feature over the given list of objects</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.maxfeat', this);">Show source &equiv;</a></p>
  <div id="source-Scene.maxfeat" class="source">
    <pre><code>def maxfeat(obj_list, feat):
    """a helper method that calculates the max of a target feature over a list of objects

    Args:

        obj_list: a list of objects

        feat: a string containing the name of the target feature

    Returns:
        the max of the target feature over the given list of objects
    """
    max = float('-infinity')
    for obj in obj_list:
        val = eval('obj.'+feat)
        if max < val:
            max = val
    return max
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="Scene.merge_aoi_distance">
    <p>def <span class="ident">merge_aoi_distance</span>(</p><p>maois, new_AOI_Stat)</p>
    </div>
    

    
  
    <div class="desc"><p>Merge distance features such as
    mean_distance:            mean of distances from the screen
    stddev_distance:          standard deviation of distances from the screen
    min_distance:             smallest distance from the screen
    max_distance:             largest distance from the screen
    start_distance:           distance from the screen in the beginning of this scene
    end_distance:             distance from the screen in the end of this scene</p>
<p>Args:
    maois: AOI_Stat object of this Scene (must have been initialised)
    new_AOI_Stat: a new AOI_Stat object</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.merge_aoi_distance', this);">Show source &equiv;</a></p>
  <div id="source-Scene.merge_aoi_distance" class="source">
    <pre><code>def merge_aoi_distance(maois, new_AOI_Stat):
    """ Merge distance features such as
            mean_distance:            mean of distances from the screen
            stddev_distance:          standard deviation of distances from the screen
            min_distance:             smallest distance from the screen
            max_distance:             largest distance from the screen
            start_distance:           distance from the screen in the beginning of this scene
            end_distance:             distance from the screen in the end of this scene

        Args:
            maois: AOI_Stat object of this Scene (must have been initialised)
            new_AOI_Stat: a new AOI_Stat object
    """
    aoi_list = [maois, new_AOI_Stat]
    if new_AOI_Stat.numdistancedata > 0:
        total_distances = sumfeat(aoi_list, 'numdistancedata')
        aggregate_mean_distance = weightedmeanfeat(aoi_list, 'numdistancedata', "features['meandistance']")
        maois.features['stddevdistance'] = aggregatestddevfeat(aoi_list, 'numdistancedata', "features['stddevdistance']",
                                                                    "features['meandistance']", aggregate_mean_distance)
        maois.features['maxdistance'] = maxfeat(aoi_list, "features['maxdistance']")
        maois.features['mindistance'] = minfeat(aoi_list, "features['mindistance']")
        maois.features['meandistance'] = aggregate_mean_distance
        if maois.starttime > new_AOI_Stat.starttime:
            maois.features['startdistance'] = new_AOI_Stat.features['startdistance']
        if maois.endtime < new_AOI_Stat.endtime:
            maois.features['enddistance'] = new_AOI_Stat.features['enddistance']
        maois.numdistancedata += new_AOI_Stat.numdistancedata
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="Scene.merge_aoi_events">
    <p>def <span class="ident">merge_aoi_events</span>(</p><p>maois, new_AOI_Stat, total_time, sc_start)</p>
    </div>
    

    
  
    <div class="desc"><p>Merge event features such as
    numevents:                number of events in the segment
    numleftclic:              number of left clinks in the segment
    numrightclic:             number of right clinks in the segment
    numdoubleclic:            number of double clinks in the segment
    numkeypressed:            number of times a key was pressed in the segment
    leftclicrate:             the rate of left clicks (relative to all datapoints) in this segment
    rightclicrate:            the rate of right clicks (relative to all datapoints) in this segment
    doubleclicrate:           the rate of double clicks (relative to all datapoints) in this segment
    keypressedrate:           the rate of key presses (relative to all datapoints) in this segment
    timetofirstleftclic:      time until the first left click in this segment
    timetofirstrightclic:     time until the first right click in this segment
    timetofirstdoubleclic:    time until the first double click in this segment
    timetofirstkeypressed:    time until the first key pressed in this segment
Args:
    maois: AOI_Stat object of this Scene (must have been initialised)
    new_AOI_Stat: a new AOI_Stat object
    total_time: duration of the scene
    sc_start: start time (timestamp) of the scene</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.merge_aoi_events', this);">Show source &equiv;</a></p>
  <div id="source-Scene.merge_aoi_events" class="source">
    <pre><code>def merge_aoi_events(maois, new_AOI_Stat, total_time, sc_start):
    """ Merge event features such as
            numevents:                number of events in the segment
            numleftclic:              number of left clinks in the segment
            numrightclic:             number of right clinks in the segment
            numdoubleclic:            number of double clinks in the segment
            numkeypressed:            number of times a key was pressed in the segment
            leftclicrate:             the rate of left clicks (relative to all datapoints) in this segment
            rightclicrate:            the rate of right clicks (relative to all datapoints) in this segment
            doubleclicrate:           the rate of double clicks (relative to all datapoints) in this segment
            keypressedrate:           the rate of key presses (relative to all datapoints) in this segment
            timetofirstleftclic:      time until the first left click in this segment
            timetofirstrightclic:     time until the first right click in this segment
            timetofirstdoubleclic:    time until the first double click in this segment
            timetofirstkeypressed:    time until the first key pressed in this segment
        Args:
            maois: AOI_Stat object of this Scene (must have been initialised)
            new_AOI_Stat: a new AOI_Stat object
            total_time: duration of the scene
            sc_start: start time (timestamp) of the scene
    """
    if new_AOI_Stat.features['numevents']>0:
        maois.features['numevents'] += new_AOI_Stat.features['numevents']
        maois.features['numleftclic'] += new_AOI_Stat.features['numleftclic']
        maois.features['numrightclic'] += new_AOI_Stat.features['numrightclic']
        maois.features['numdoubleclic'] += new_AOI_Stat.features['numdoubleclic']
        maois.features['leftclicrate'] = float(maois.features['numleftclic'])/total_time
        maois.features['rightclicrate'] = float(maois.features['numrightclic'])/total_time
        maois.features['doubleclicrate'] = float(maois.features['numdoubleclic'])/total_time

        if new_AOI_Stat.features['timetofirstleftclic'] != -1:
            maois.features['timetofirstleftclic'] = min(maois.features['timetofirstleftclic'], deepcopy(new_AOI_Stat.features['timetofirstleftclic']) + new_AOI_Stat.starttime - sc_start)
        if new_AOI_Stat.features['timetofirstrightclic'] != -1:
            maois.features['timetofirstrightclic'] = min(maois.features['timetofirstrightclic'], deepcopy(new_AOI_Stat.features['timetofirstrightclic']) + new_AOI_Stat.starttime - sc_start)
        if new_AOI_Stat.features['timetofirstdoubleclic'] != -1:
            maois.features['timetofirstdoubleclic'] = min(maois.features['timetofirstdoubleclic'], deepcopy(new_AOI_Stat.features['timetofirstdoubleclic']) + new_AOI_Stat.starttime - sc_start)

        if new_AOI_Stat.features['timetolastleftclic'] != -1:
            maois.features['timetolastleftclic'] = max(maois.features['timetolastleftclic'], deepcopy(new_AOI_Stat.features['timetolastleftclic']) + new_AOI_Stat.starttime - sc_start)
        if new_AOI_Stat.features['timetolastrightclic'] != -1:
            maois.features['timetolastrightclic'] = max(maois.features['timetolastrightclic'], deepcopy(new_AOI_Stat.features['timetolastrightclic']) + new_AOI_Stat.starttime - sc_start)
        if new_AOI_Stat.features['timetolastdoubleclic'] != -1:
            maois.features['timetolastdoubleclic'] = max(maois.features['timetolastdoubleclic'], deepcopy(new_AOI_Stat.features['timetolastdoubleclic']) + new_AOI_Stat.starttime - sc_start)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="Scene.merge_aoi_fixations">
    <p>def <span class="ident">merge_aoi_fixations</span>(</p><p>maois, new_AOI_Stat, total_time, total_numfixations, sc_start)</p>
    </div>
    

    
  
    <div class="desc"><p>Merge fixation features such as
    meanfixationduration:     mean duration of fixations
    stddevfixationduration    standard deviation of duration of fixations
    sumfixationduration:      sum of durations of fixations
    fixationrate:             rate of fixation datapoints relative to all datapoints
Args:
    main_AOI_Stat: AOI_Stat object of this Scene (must have been initialised)</p>
<pre><code>new_AOI_Stat: a new AOI_Stat object

total_time: duration of the scene

total_numfixations: number of fixations in the scene

sc_start: start time (timestamp) of the scene
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.merge_aoi_fixations', this);">Show source &equiv;</a></p>
  <div id="source-Scene.merge_aoi_fixations" class="source">
    <pre><code>def merge_aoi_fixations(maois, new_AOI_Stat, total_time, total_numfixations, sc_start):
    """ Merge fixation features such as
            meanfixationduration:     mean duration of fixations
            stddevfixationduration    standard deviation of duration of fixations
            sumfixationduration:      sum of durations of fixations
            fixationrate:             rate of fixation datapoints relative to all datapoints
        Args:
            main_AOI_Stat: AOI_Stat object of this Scene (must have been initialised)

            new_AOI_Stat: a new AOI_Stat object

            total_time: duration of the scene

            total_numfixations: number of fixations in the scene

            sc_start: start time (timestamp) of the scene
    """
    if new_AOI_Stat.features['numfixations'] > 0:
        aoi_list = [maois, new_AOI_Stat]
        numfixations = sumfeat(aoi_list, "features['numfixations']")
        maois.features['longestfixation'] = maxfeat(aoi_list, "features['longestfixation']")
        maois.features['totaltimespent'] += new_AOI_Stat.features['totaltimespent']
        aggregate_meanfixationduration = maois.features['totaltimespent'] / numfixations
        maois.features['stddevfixationduration'] = aggregatestddevfeat(aoi_list, "features['numfixations']", "features['stddevfixationduration']", "features['meanfixationduration']", aggregate_meanfixationduration)
        maois.features['numfixations'] +=  new_AOI_Stat.features['numfixations']
        maois.features['meanfixationduration'] = aggregate_meanfixationduration
        maois.features['proportiontime'] = float(maois.features['totaltimespent'])/total_time
        maois.features['proportionnum'] = float(maois.features['numfixations'])/total_numfixations

        if maois.features['totaltimespent'] > 0:
            maois.features['fixationrate'] = float(maois.features['numfixations']) / maois.features['totaltimespent']
        else:
            maois.features['fixationrate'] = -1

        if new_AOI_Stat.features['timetofirstfixation'] != -1:
            maois.features['timetofirstfixation'] = min(maois.features['timetofirstfixation'], deepcopy(new_AOI_Stat.features['timetofirstfixation']) + new_AOI_Stat.starttime - sc_start)
        if new_AOI_Stat.features['timetolastfixation'] != -1:
            maois.features['timetolastfixation'] = max(maois.features['timetolastfixation'], deepcopy(new_AOI_Stat.features['timetolastfixation']) + new_AOI_Stat.starttime - sc_start)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="Scene.merge_aoi_pupil">
    <p>def <span class="ident">merge_aoi_pupil</span>(</p><p>maois, new_AOI_Stat)</p>
    </div>
    

    
  
    <div class="desc"><p>Merge pupil features asuch as
    mean_pupil_size:            mean of pupil sizes
    stddev_pupil_size:          standard deviation of pupil sizes
    min_pupil_size:             smallest pupil size
    max_pupil_size:             largest pupil size
    mean_pupil_velocity:        mean of pupil velocities
    stddev_pupil_velocity:      standard deviation of pupil velocities
    min_pupil_velocity:         smallest pupil velocity
    max_pupil_velocity:         largest pupil velocity
Args:
    maois: AOI_Stat object of this Scene (must have been initialised)
    new_AOI_Stat: a new AOI_Stat object</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.merge_aoi_pupil', this);">Show source &equiv;</a></p>
  <div id="source-Scene.merge_aoi_pupil" class="source">
    <pre><code>def merge_aoi_pupil(maois, new_AOI_Stat):
    """ Merge pupil features asuch as
            mean_pupil_size:            mean of pupil sizes
            stddev_pupil_size:          standard deviation of pupil sizes
            min_pupil_size:             smallest pupil size
            max_pupil_size:             largest pupil size
            mean_pupil_velocity:        mean of pupil velocities
            stddev_pupil_velocity:      standard deviation of pupil velocities
            min_pupil_velocity:         smallest pupil velocity
            max_pupil_velocity:         largest pupil velocity
        Args:
            maois: AOI_Stat object of this Scene (must have been initialised)
            new_AOI_Stat: a new AOI_Stat object
    """
    aoi_list = [maois, new_AOI_Stat]
    if (new_AOI_Stat.numpupilsizes > 0):
        aggregate_mean_pupil = weightedmeanfeat(aoi_list, 'numpupilsizes', "features['meanpupilsize']")
        maois.features['stddevpupilsize'] = aggregatestddevfeat(aoi_list, 'numpupilsizes', "features['stddevpupilsize']",
                                                                        "features['meanpupilsize']", aggregate_mean_pupil)
        maois.features['maxpupilsize'] = maxfeat(aoi_list, "features['maxpupilsize']")
        maois.features['minpupilsize'] = minfeat(aoi_list, "features['minpupilsize']")
        maois.features['meanpupilsize'] = aggregate_mean_pupil
        if maois.starttime > new_AOI_Stat.starttime:
            maois.features['startpupilsize'] = new_AOI_Stat.features['startpupilsize']
        if maois.endtime < new_AOI_Stat.endtime:
            maois.features['endpupilsize'] = new_AOI_Stat.features['endpupilsize']
        maois.numpupilsizes += new_AOI_Stat.numpupilsizes

    if (new_AOI_Stat.numpupilvelocity > 0):
        aggregate_mean_velocity =  weightedmeanfeat(aoi_list, 'numpupilvelocity', "features['meanpupilvelocity']")
        maois.features['stddevpupilvelocity'] = aggregatestddevfeat(aoi_list, 'numpupilvelocity', "features['stddevpupilvelocity']",
                                                                        "features['meanpupilvelocity']", aggregate_mean_velocity)
        maois.features['maxpupilvelocity'] = maxfeat(aoi_list, "features['maxpupilvelocity']")
        maois.features['minpupilvelocity'] = minfeat(aoi_list, "features['minpupilvelocity']")
        maois.features['meanpupilvelocity'] = aggregate_mean_velocity
        maois.numpupilvelocity += new_AOI_Stat.numpupilvelocity
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="Scene.merge_aoistats">
    <p>def <span class="ident">merge_aoistats</span>(</p><p>main_AOI_Stat, new_AOI_Stat, total_time, total_numfixations, sc_start=0)</p>
    </div>
    

    
  
    <div class="desc"><p>a helper method that updates the AOI_Stat object of this Scene with a new AOI_Stat object</p>
<p>Args:
    main_AOI_Stat: AOI_Stat object of this Scene (must have been initialised)</p>
<pre><code>new_AOI_Stat: a new AOI_Stat object

total_time: duration of the scene

total_numfixations: number of fixations in the scene

sc_start: start time (timestamp) of the scene
</code></pre>
<p>Returns:
    the updated AOI_Sata object</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.merge_aoistats', this);">Show source &equiv;</a></p>
  <div id="source-Scene.merge_aoistats" class="source">
    <pre><code>def merge_aoistats(main_AOI_Stat,new_AOI_Stat,total_time,total_numfixations,sc_start=0):
        """a helper method that updates the AOI_Stat object of this Scene with a new AOI_Stat object

        Args:
            main_AOI_Stat: AOI_Stat object of this Scene (must have been initialised)

            new_AOI_Stat: a new AOI_Stat object

            total_time: duration of the scene

            total_numfixations: number of fixations in the scene

            sc_start: start time (timestamp) of the scene

        Returns:
            the updated AOI_Sata object
        """
        maois = main_AOI_Stat
        merge_aoi_fixations(maois, new_AOI_Stat, total_time, total_numfixations, sc_start)
        #calculating the transitions to and from this AOI and other active AOIs at the moment
        new_AOI_Stat_transition_aois = filter(lambda x: x.startswith('numtransfrom_'), new_AOI_Stat.features.keys())
        if params.DEBUG or params.VERBOSE == "VERBOSE":
            print("Segment's transition_aois", new_AOI_Stat_transition_aois)

        merge_aoi_events(maois, new_AOI_Stat, total_time, sc_start)

        maois.total_trans_from += new_AOI_Stat.total_trans_from   #updating the total number of transition from this AOI
        for feat in new_AOI_Stat_transition_aois:
            if feat in maois.features:
                maois.features[feat] += new_AOI_Stat.features[feat]
            else:
                maois.features[feat] = new_AOI_Stat.features[feat]
#               sumtransfrom += maois.features[feat]

        merge_aoi_distance(maois, new_AOI_Stat)
        merge_aoi_pupil(maois, new_AOI_Stat)
        # updating the proportion tansition features based on new transitions to and from this AOI
        maois_transition_aois = filter(lambda x: x.startswith('numtransfrom_'),maois.features.keys()) #all the transition features for this AOI should be aupdated even if they are not active for this segment
        for feat in maois_transition_aois:
            aid = feat[len('numtransfrom_'):]
            if maois.total_trans_from > 0:
                maois.features['proptransfrom_%s'%(aid)] = float(maois.features[feat]) / maois.total_trans_from
            else:
                maois.features['proptransfrom_%s'%(aid)] = 0
        ###endof transition calculation
        return maois
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="Scene.mergevalues">
    <p>def <span class="ident">mergevalues</span>(</p><p>obj_list, field)</p>
    </div>
    

    
  
    <div class="desc"><p>a helper method that merges lists of values stored in field</p>
<p>Args:</p>
<pre><code>obj_list: a list of objects

field: name of a field that contains a list of values (string)
</code></pre>
<p>Returns:
    a list formed by merging corresponding lists from collection of subjects</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.mergevalues', this);">Show source &equiv;</a></p>
  <div id="source-Scene.mergevalues" class="source">
    <pre><code>def mergevalues(obj_list, field):
    """a helper method that merges lists of values stored in field

    Args:

        obj_list: a list of objects

        field: name of a field that contains a list of values (string)

    Returns:
        a list formed by merging corresponding lists from collection of subjects
    """
    mergedlist = []
    for obj in obj_list:
        mergedlist.extend(eval('obj.'+ field))
    return mergedlist
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="Scene.minfeat">
    <p>def <span class="ident">minfeat</span>(</p><p>obj_list, feat, nonevalue=None)</p>
    </div>
    

    
  
    <div class="desc"><p>a helper method that calculates the min of a target feature over a list of objects</p>
<p>Args:</p>
<pre><code>obj_list: a list of objects

feat: a string containing the name of the target feature

nonevalue: value to be ignored when computing the min (typically -1 in EMDAT)
</code></pre>
<p>Returns:
    the min of the target feature over the given list of objects</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.minfeat', this);">Show source &equiv;</a></p>
  <div id="source-Scene.minfeat" class="source">
    <pre><code>def minfeat(obj_list, feat, nonevalue = None):
    """a helper method that calculates the min of a target feature over a list of objects

    Args:

        obj_list: a list of objects

        feat: a string containing the name of the target feature

        nonevalue: value to be ignored when computing the min (typically -1 in EMDAT)

    Returns:
        the min of the target feature over the given list of objects
    """
    min = float('+infinity')
    for obj in obj_list:
        val = eval('obj.'+feat)
        if min > val and val != nonevalue:
            min = val
    return min
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="Scene.sumfeat">
    <p>def <span class="ident">sumfeat</span>(</p><p>obj_list, feat)</p>
    </div>
    

    
  
    <div class="desc"><p>a helper method that calculates the sum of a target feature over a list of objects</p>
<p>Args:</p>
<pre><code>obj_list: a list of objects

feat: a string containing the name of the target feature
</code></pre>
<p>Returns:
    the sum of the target feature over the given list of objects</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.sumfeat', this);">Show source &equiv;</a></p>
  <div id="source-Scene.sumfeat" class="source">
    <pre><code>def sumfeat(obj_list, feat):
    """a helper method that calculates the sum of a target feature over a list of objects

    Args:

        obj_list: a list of objects

        feat: a string containing the name of the target feature

    Returns:
        the sum of the target feature over the given list of objects
    """
    sum = 0
    for obj in obj_list:
        sum += eval('obj.'+feat)
    return sum
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="Scene.weightedmeanfeat">
    <p>def <span class="ident">weightedmeanfeat</span>(</p><p>obj_list, totalfeat, ratefeat)</p>
    </div>
    

    
  
    <div class="desc"><p>a helper method that calculates the weighted average of a target feature over a list of Segments</p>
<p>Args:
    obj_list: a list of Segments which all have a numeric field for which the weighted average is calculated</p>
<pre><code>totalfeat: a string containing the name of the feature that has the total value of the target feature

ratefeat: a string containing the name of the feature that has the rate value of the target feature
</code></pre>
<p>Returns:
    the weighted average of the ratefeat over the Segments</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.weightedmeanfeat', this);">Show source &equiv;</a></p>
  <div id="source-Scene.weightedmeanfeat" class="source">
    <pre><code>def weightedmeanfeat(obj_list, totalfeat,ratefeat):
    """a helper method that calculates the weighted average of a target feature over a list of Segments

    Args:
        obj_list: a list of Segments which all have a numeric field for which the weighted average is calculated

        totalfeat: a string containing the name of the feature that has the total value of the target feature

        ratefeat: a string containing the name of the feature that has the rate value of the target feature

    Returns:
        the weighted average of the ratefeat over the Segments
    """
    num_valid = float(0)
    num = 0

    for obj in obj_list:
        t = eval('obj.'+totalfeat)
        num_valid += t * eval('obj.'+ratefeat)
        num += t
    if num != 0:
        return num_valid / num
    return 0
</code></pre>
  </div>
</div>

  </div>
  

    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="Scene.Scene" class="name">class <span class="ident">Scene</span></p>
      
  
    <div class="desc"><p>A Scene is a class that represent one scene in the experiment.</p>
<p>A Scene is a class that represent one scene in the experiment. The Scene is designed to capture all "Datapoint"s related to a target
conceptual entity in the experiment. A Scene should have at least one Segment assigned to it. The Scene class is also used to
combine multiple "Segment"s and calculate the aggregated statistics for this new entity as a whole. This class is the equivalent
of scenes as defined in Tobii studio.</p>
<p>Attributes:
    scid: a string containing the Scene ids
    segments: a list of "Segment"s for this Scene</p>
<p>Attributes inherited from Segment:
    alldata: A list of "Datapoint"s for this Scene
    features: A dict with feature names as its keys and feature values as its values
    completion_time: An integer indicating total duration of the Scene in milliseconds
        minimum is 16 ms (ength of one sample with 60Hz sampling rate (ms)
    start:An integer indicating the Scene's start time in milliseconds
    end: An integer indicating the Scene's end time in milliseconds
    sample_start_ind: An integer indicating the index of the first Datapoint for this Scene in the Participant's list of all "Datapoint"s (all_data)
    sample_end_ind: An integer indicating the index of the last Datapoint for this Scene in the Participant's list of all "Datapoint"s (all_data)
    fixation_start_ind: An integer indicating the index of the first Fixation for this Scene in the Participant's list of all "Fixation"s (fixation_data)
    fixation_end_ind: An integer indicating the index of the first Fixation for this Scene in the Participant's list of all "Fixation"s (fixation_data)
    numfixations: An integer indicating the number of "Fixation"s in this Scene
    time_gaps: a list of tuples of the form (start, end) indicating the start and end of the gaps of invalid samples in the Segement's samples
    largest_data_gap: An integer indicating the length of largest invalid gap for this Scene in milliseconds
    proportion_valid: A float indicating the proportion of valid samples over all the samples in this Scene
    proportion_valid_fix: A float indicating the proportion of (valid + restored) samples over all the samples in this Scene
    validity1: a boolean indicating whether this Scene is valid using proportion of valid samples threshold
    validity2: a boolean indicating whether this Scene is valid using largest acceptable gap threshold
    validity3: a boolean indicating whether this Scene is valid using proportion of (valid + restored) samples threshold
    is_valid: a boolean indicating whether this Scene is considered valid by the validity method indicated by params.VALIDITY_METHOD
    length: An integer indicating total duration of the Scene in milliseconds
    numsamples: An integer indicating total number of samples in the Scene
    fixation_data: A list of "Fixation"s for this Scene
    fixation_start = fixation_data[0].timestamp
    fixation_end = fixation_data[-1].timestamp
    aoi_data: A list of AOI_Stat objects for relevants "AOI"s for this Scene
    has_aois: A boolean indicating if this Scene has AOI features calculated for it</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene" class="source">
    <pre><code>class Scene(Segment):
    """A Scene is a class that represent one scene in the experiment.

    A Scene is a class that represent one scene in the experiment. The Scene is designed to capture all "Datapoint"s related to a target
    conceptual entity in the experiment. A Scene should have at least one Segment assigned to it. The Scene class is also used to
    combine multiple "Segment"s and calculate the aggregated statistics for this new entity as a whole. This class is the equivalent
    of scenes as defined in Tobii studio.

    Attributes:
        scid: a string containing the Scene ids
        segments: a list of "Segment"s for this Scene

    Attributes inherited from Segment:
        alldata: A list of "Datapoint"s for this Scene
        features: A dict with feature names as its keys and feature values as its values
        completion_time: An integer indicating total duration of the Scene in milliseconds
            minimum is 16 ms (ength of one sample with 60Hz sampling rate (ms)
        start:An integer indicating the Scene's start time in milliseconds
        end: An integer indicating the Scene's end time in milliseconds
        sample_start_ind: An integer indicating the index of the first Datapoint for this Scene in the Participant's list of all "Datapoint"s (all_data)
        sample_end_ind: An integer indicating the index of the last Datapoint for this Scene in the Participant's list of all "Datapoint"s (all_data)
        fixation_start_ind: An integer indicating the index of the first Fixation for this Scene in the Participant's list of all "Fixation"s (fixation_data)
        fixation_end_ind: An integer indicating the index of the first Fixation for this Scene in the Participant's list of all "Fixation"s (fixation_data)
        numfixations: An integer indicating the number of "Fixation"s in this Scene
        time_gaps: a list of tuples of the form (start, end) indicating the start and end of the gaps of invalid samples in the Segement's samples
        largest_data_gap: An integer indicating the length of largest invalid gap for this Scene in milliseconds
        proportion_valid: A float indicating the proportion of valid samples over all the samples in this Scene
        proportion_valid_fix: A float indicating the proportion of (valid + restored) samples over all the samples in this Scene
        validity1: a boolean indicating whether this Scene is valid using proportion of valid samples threshold
        validity2: a boolean indicating whether this Scene is valid using largest acceptable gap threshold
        validity3: a boolean indicating whether this Scene is valid using proportion of (valid + restored) samples threshold
        is_valid: a boolean indicating whether this Scene is considered valid by the validity method indicated by params.VALIDITY_METHOD
        length: An integer indicating total duration of the Scene in milliseconds
        numsamples: An integer indicating total number of samples in the Scene
        fixation_data: A list of "Fixation"s for this Scene
        fixation_start = fixation_data[0].timestamp
        fixation_end = fixation_data[-1].timestamp
        aoi_data: A list of AOI_Stat objects for relevants "AOI"s for this Scene
        has_aois: A boolean indicating if this Scene has AOI features calculated for it

    """


    def __init__(self, scid, seglist, all_data, fixation_data, saccade_data = None, event_data = None, Segments = None, aoilist = None,
                  prune_length= None, require_valid = True, auto_partition = False, rest_pupil_size = 0, export_pupilinfo = False):
        """
        Args:
            scid: A string containing the id of the Scene.

            seglist: a list of tuples of the form (segid, start, end) defining the segments
            *Note: this method of defining segments is implemented to make batch processing of
            files defining segments easier

            all_data: a list of "Datapoint"s which make up this Scene.

            fixation_data: a list of "Fixation"s which make up this Scene.

            saccade_data: If not None, a list of "Saccade"s which make up this Scene.

            event_data: If not None, a list of "Event"s which make up this Scene.

            Segments: a list of "Segment"s which belong to this Scene.

            aoilist: If not None, a list of "AOI"s.

            prune_length: If not None, an integer that specifies the time
                interval (in ms) from the begining of each Segment of this Scene
                which samples are considered in calculations.  This can be used if,
                for example, you only wish to consider data in the first
                1000 ms of each Segment. In this case (prune_length = 1000),
                all data beyond the first 1000ms of the start of the "Segment"s
                will be disregarded.

            require_valid: a boolean determining whether invalid "Segment"s
                will be ignored when calculating the features or not. default = True

            auto_partition: a boolean flag determining whether
                EMDAT should automatically split the "Segment"s which have low sample quality
                into two new ssub "Segment"s discarding the largest invalid sample gap in
                the "Segment". default = False

            rest_pupil_size: rest pupil size for the current scene

        Yields:
            a Scene object
        """

        ########################################
        def partition_segment(new_seg, seg_start, seg_end, rest_pupil_size, export_pupilinfo):
            """ A helper method for splitting a Segment object into new Segments and removing gaps of invalid samples

            One way to deal with a low quality Segment is to find the gaps of invalid samples within its "Datapoint"s and
            splitting the Segment into two Segments one from the beginnning of the Segment to the gap and another from after
            the gap to the end of the Segment. This can be done multiple times resulting multiple "Segment"s with higher
            quality. For example if a Segment S1 started at s1 and ended at e1 and had two invalid gaps between gs1-ge1 and
            gs2-ge2 milliseconds, this method will generate the following three segments
                SS1: starting at s1 and ending at gs1
                SS2: starting at ge1 and ending at gs2
                SS3: starting at ge2 and ending at e1

            Args:
                new_seg: The Segment that is being split

                seg_start: An integer showing the start time of the segment in milliseconds

                seg_end: An integer showing the end time of the segment in milliseconds

                rest_pupil_size: rest pupil size for the current scene

            Returns:
                subsegments: a list of newly generated "Segment"s

                samp_inds: a list of tuples of the form (start, end) that detrmines the index of the start and end of each
                    new Segment in the old Segment's all_data field

                fix_inds: a list of tuples of the form (start, end) that detrmines the index of the start and end of each
                    new Segment in the old Segment's fixation_data field

                sac_inds: a list of tuples of the form (start, end) that detrmines the index of the start and end of each
                    new Segment in the old Segment's saccade_data field

                event_inds: a list of tuples of the form (start, end) that detrmines the index of the start and end of each
                    new Segment in the old Segment's event_data field
            """
            timegaps = new_seg.getgaps()
            subsegments = []
            sub_segid = 0
            samp_inds = []
            fix_inds = []
            saccade_inds = []
            event_inds = []
            last_samp_idx = 0
            last_fix_idx = 0
            last_sac_idx = 0
            last_event_idx = 0
            sub_seg_time_start = seg_start
            for timebounds in timegaps:
                sub_seg_time_end = timebounds[0] #end of this sub_seg is start of this gap
                last_samp_idx, all_start,all_end = get_chunk(all_data, last_samp_idx, sub_seg_time_start, sub_seg_time_end)
                last_fix_idx, fix_start, fix_end = get_chunk(fixation_data, last_fix_idx, sub_seg_time_start, sub_seg_time_end)
                if saccade_data != None:
                    last_sac_idx, sac_start, sac_end = get_chunk(saccade_data, last_sac_idx, sub_seg_time_start, sub_seg_time_end)
                    saccade_data_in_part = saccade_data[sac_start:sac_end]
                else:
                    saccade_data_in_part = None
                if event_data != None:
                    last_event_idx, event_start, event_end = get_chunk(event_data, last_event_idx, sub_seg_time_start, sub_seg_time_end)
                    event_data_in_part = event_data[event_start:event_end]
                else:
                    event_data_in_part = None

                sub_seg_time_start = timebounds[1] #beginning of the next sub_seg is end of this gap
                if fix_end - fix_start>0:
                    try:
                        new_sub_seg = Segment(segid+"_"+str(sub_segid), all_data[all_start:all_end], fixation_data[fix_start:fix_end], saccade_data=saccade_data_in_part,
                                      event_data=event_data_in_part, aois=aoilist, prune_length=prune_length, rest_pupil_size = rest_pupil_size, export_pupilinfo = export_pupilinfo)
                    except  Exception as e:
                        warn(str(e))
                        if params.DEBUG:
                            raise
                        else:
                            continue
                else:
                    continue
                subsegments.append(new_sub_seg)
                samp_inds.append((all_start,all_end))
                fix_inds.append((fix_start, fix_end))
                if saccade_data != None:
                    saccade_inds.append((sac_start, sac_end))
                if event_data != None:
                    event_inds.append((event_start, event_end))
                sub_segid +=1

            # handling the last sub_seg
            sub_seg_time_end = seg_end #end of last sub_seg is the end of seg
            last_samp_idx, all_start,all_end = get_chunk(all_data, last_samp_idx, sub_seg_time_start, sub_seg_time_end)
            last_fix_idx, fix_start, fix_end = get_chunk(fixation_data, last_fix_idx, sub_seg_time_start, sub_seg_time_end)
            if saccade_data != None:
                last_sac_idx, sac_start, sac_end = get_chunk(saccade_data, last_sac_idx, sub_seg_time_start, sub_seg_time_end)
                saccade_data_in_part = saccade_data[sac_start:sac_end]
            else:
                saccade_data_in_part = None
            if event_data != None:
                last_event_idx, event_start, event_end = get_chunk(event_data, last_event_idx, sub_seg_time_start, sub_seg_time_end)
                event_data_in_part = event_data[event_start:event_end]
            else:
                event_data_in_part = None
            if fix_end - fix_start>0: #add the last sub_seg
                try:
                    new_sub_seg = Segment(segid+"_"+str(sub_segid), all_data[all_start:all_end], fixation_data[fix_start:fix_end], saccade_data_in_part,
                                      event_data=event_data_in_part, aois=aoilist, prune_length=prune_length, rest_pupil_size = rest_pupil_size, export_pupilinfo = export_pupilinfo)
                except Exception as e:
                    warn(str(e))
                    if params.DEBUG:
                        raise
                    else:
                        new_sub_seg = None

                if new_sub_seg != None:
                    subsegments.append(new_sub_seg)
                    samp_inds.append((all_start,all_end))
                    fix_inds.append((fix_start, fix_end))
                    if saccade_data != None:
                        saccade_inds.append((sac_start, sac_end))
                    if event_data != None:
                        event_inds.append((event_start, event_end))
            #end of handling the last sub_seg

            return subsegments, samp_inds, fix_inds, saccade_inds, event_inds
        ######################################## end partition_segment()



        if len(all_data)<=0:
            raise Exception('A scene with no sample data!')
        if Segments == None:
            self.segments = []
#            print "seglist",seglist
            for (segid, start, end) in seglist:
                if params.VERBOSE != "QUIET":
                    print("segid, start, end:", segid, start, end)
                # Selecting subsets of points belonging only to the current segment
                if prune_length != None:
                    end = min(end, start+prune_length)
                _, all_start, all_end = get_chunk(all_data, 0, start, end)
                _, fix_start, fix_end = get_chunk(fixation_data, 0, start, end)
                if saccade_data != None:
                    _, sac_start, sac_end = get_chunk(saccade_data, 0, start, end)
                    saccade_data_in_seg = saccade_data[sac_start:sac_end]
                else:
                    sac_start = None
                    sac_end = None
                    saccade_data_in_seg = None
                if event_data != None:
                    _, event_start, event_end = get_chunk(event_data, 0, start, end)
                    event_data_in_seg = event_data[event_start:event_end]
                else:
                    event_start = None
                    event_end = None
                    event_data_in_seg = None

                if fix_end - fix_start>0:
                    try:
                        new_seg = Segment(segid, all_data[all_start:all_end], fixation_data[fix_start:fix_end], saccade_data = saccade_data_in_seg,
							        event_data=event_data_in_seg, aois=aoilist, prune_length=prune_length, rest_pupil_size = rest_pupil_size, export_pupilinfo = export_pupilinfo)
                    except  Exception as e:
                        warn(str(e))
                        if params.DEBUG:
                            raise
                        else:
                            continue
                else:
                    continue

                if (new_seg.largest_data_gap > params.MAX_SEG_TIMEGAP) and auto_partition: #low quality segment that needs to be partitioned!
                    try:
                        new_segs, samp_inds, fix_inds, sac_inds, event_inds = partition_segment(new_seg, start, end, rest_pupil_size, export_pupilinfo=export_pupilinfo)
                        if saccade_data != None and event_data != None:
                            for nseg,samp,fix,sac,eve in zip(new_segs, samp_inds, fix_inds, sac_inds, event_inds):
                                if nseg.length > params.MINSEGSIZE:
                                    nseg.set_indices(samp[0],samp[1],fix[0],fix[1],sac[0],sac[1],eve[0],eve[1])
                                    self.segments.append(nseg)
                        elif saccade_data != None and event_data == None:
                            for nseg,samp,fix,sac in zip(new_segs, samp_inds, fix_inds, sac_inds):
                                if nseg.length > params.MINSEGSIZE:
                                    nseg.set_indices(samp[0],samp[1],fix[0],fix[1],sac[0],sac[1])
                                    self.segments.append(nseg)
                        elif saccade_data == None and event_data != None:
                            for nseg,samp,fix,eve in zip(new_segs, samp_inds, fix_inds, event_inds):
                                if nseg.length > params.MINSEGSIZE:
                                    nseg.set_indices(samp[0],samp[1],fix[0],fix[1],event_st=eve[0],event_end=eve[1])
                                    self.segments.append(nseg)
                        else:
                            for nseg,samp,fix in zip(new_segs, samp_inds, fix_inds):
                                if nseg.length > params.MINSEGSIZE:
                                    nseg.set_indices(samp[0],samp[1],fix[0],fix[1])
                                    self.segments.append(nseg)
                    except Exception as e:
                        raise Exception("Error while partitioning scene. "+str(e))

                else:   #good quality segment OR no auto_partition
                    new_seg.set_indices(all_start,all_end,fix_start,fix_end,sac_start,sac_end,event_start,event_end)
                    self.segments.append(new_seg)
        else:
            self.segments = Segments #segments are already generated

        self.require_valid_Segments = require_valid
        if require_valid:   #filter out the invalid Segments

            segments = filter(lambda x:x.is_valid,self.segments)
        else:
            segments = self.segments
        if len(segments)==0:
            raise Exception('no segments in scene %s!' %(scid))

        fixationlist = []
        saccadelist = []
        totalfixations = 0
        firstsegtime = float('infinity')
        endsegtime = float(0)
        firstseg = None
        for seg in segments:
            sample_st,sample_end,fix_start,fix_end,sac_st,sac_end,event_st,event_end = seg.get_indices()
            if params.DEBUG or params.VERBOSE == "VERBOSE":
                print("sample_st,sample_end,fix_start,fix_end",sample_st,sample_end,fix_start,fix_end,sac_st,sac_end,event_st,event_end)
            fixationlist.append(fixation_data[fix_start:fix_end])
            totalfixations += len(fixationlist[-1])
            if seg.start < firstsegtime:
                firstsegtime = seg.start
                firstseg = seg
            if seg.end > endsegtime:
                endsegtime = seg.end
                endseg = seg
        fixationlist = []

        self.firstseg = firstseg
        self.endseg = endseg
        self.scid = scid
        self.features = {}
        self.largest_data_gap = maxfeat(self.segments,'largest_data_gap')   #self.segments is used to calculate validity of the scenes instead of segments which is only valid segments
        self.proportion_valid = weightedmeanfeat(self.segments,'numsamples','proportion_valid') #self.segments is used to calculate validity of the scenes instead of segments which is only valid segments
        self.proportion_valid_fix = weightedmeanfeat(self.segments,'numsamples','proportion_valid_fix') #self.segments is used to calculate validity of the scenes instead of segments which is only valid segments
        self.validity1 = self.calc_validity1()
        self.validity2 = self.calc_validity2()
        self.validity3 = self.calc_validity3()
        self.is_valid = self.get_validity()

        self.length = sumfeat(segments,"features['length']")
        if self.length == 0:
            raise Exception('Zero length segments!')

        self.length_invalid = self.get_length_invalid()

        self.features['numsegments'] = len(segments)
        self.features['length'] = self.length
        self.start = minfeat(segments,'start')
        self.numfixations = sumfeat(segments,'numfixations')
        self.end = maxfeat(segments,'end')
        self.numsamples = sumfeat(segments, 'numsamples')
        self.features['numsamples'] = self.numsamples

        if prune_length == None:
            if self.numfixations != totalfixations:
                if params.DEBUG:
                    raise Exception('Error in fixation count for scene: '+self.scid)
                else:
                    warn('Error in fixation count for scene: '+self.scid)

        self.merge_fixation_features(segments)

        self.merge_path_angle_features(segments)

        self.merge_blink_features(segments)

        self.merge_pupil_features(export_pupilinfo, segments)

        self.merge_distance_data(segments)

        self.merge_saccade_data(saccade_data, segments)

        self.merge_event_data(event_data, segments)

        self.has_aois = False

        if aoilist:
            self.set_aois(segments, aoilist)

        self.features['aoisequence'] = self.merge_aoisequences(segments)

    def getid(self):
        """Returns the scid for this Scene

        Returns: a string conataining the scid for this Scene
        """
        return self.scid

    def set_aois(self, segments, aois):
        """Sets the "AOI"s relevant to this Scene

        Args:
            segments: a list of "Segment"s which belong to this Scene.

            aois: a list of "AOI"s relevant to this Scene
        """
        if len(aois) == 0 and params.VERBOSE != "QUIET":
            print("No AOI in segment ", self.segid)

        self.aoi_data={}
        for seg in segments:
            for aid in seg.aoi_data.keys():
                    if aid in self.aoi_data:
                        if seg.aoi_data[aid].isActive:
                            self.aoi_data[aid] = merge_aoistats(self.aoi_data[aid],seg.aoi_data[aid], self.features['length'], self.numfixations, self.start)
                    else:
                        self.aoi_data[aid] = deepcopy(seg.aoi_data[aid])
                        if seg.aoi_data[aid].isActive:
                            self.aoi_data[aid].features['timetofirstfixation'] += self.aoi_data[aid].starttime - self.start
                            self.aoi_data[aid].features['timetolastfixation'] += self.aoi_data[aid].starttime - self.start

                            if self.firstseg.aoi_data[aid].features['timetofirstleftclic'] != -1:
                                self.aoi_data[aid].features['timetofirstleftclic'] += self.aoi_data[aid].starttime - self.start
                            if self.firstseg.aoi_data[aid].features['timetofirstrightclic'] != -1:
                                self.aoi_data[aid].features['timetofirstrightclic'] += self.aoi_data[aid].starttime - self.start
                            if self.firstseg.aoi_data[aid].features['timetofirstdoubleclic'] != -1:
                                self.aoi_data[aid].features['timetofirstdoubleclic'] += self.aoi_data[aid].starttime - self.start

                            if self.firstseg.aoi_data[aid].features['timetolastleftclic'] != -1:
                                self.aoi_data[aid].features['timetolastleftclic'] += self.aoi_data[aid].starttime - self.start
                            if self.firstseg.aoi_data[aid].features['timetolastrightclic'] != -1:
                                self.aoi_data[aid].features['timetolastrightclic'] += self.aoi_data[aid].starttime - self.start
                            if self.firstseg.aoi_data[aid].features['timetolastdoubleclic'] != -1:
                                self.aoi_data[aid].features['timetolastdoubleclic'] += self.aoi_data[aid].starttime - self.start
        #Merge stdev
        #For each seg, compute: T = [(numfix-1) * Variance + numfix * power( meanfixduration_in_seg - meanfixduration_in_scene, 2)]
        #At the Scene level: [ SQRT( SUM(T_seg1...Tsegn) / (numfix-1) ]
        for aid in self.aoi_data.keys():
            temp = 0
            numdata = 0
            for seg in segments:
                    temp += (seg.aoi_data[aid].features['numfixations']-1) * seg.aoi_data[aid].variance + seg.aoi_data[aid].features['numfixations'] * math.pow(seg.aoi_data[aid].features['meanfixationduration'] - self.aoi_data[aid].features['meanfixationduration'], 2)
                    numdata += seg.aoi_data[aid].features['numfixations']
            self.aoi_data[aid].features['stddevfixationduration'] = math.sqrt(temp / (numdata-1) ) if numdata > 1 else 0
        """
        firstsegaois = self.firstseg.aoi_data.keys()
        for aid in self.aoi_data.keys():
            if aid in firstsegaois:
                self.aoi_data[aid].features['timetofirstfixation'] = deepcopy(self.firstseg.aoi_data[aid].features['timetofirstfixation'])
                if self.firstseg.aoi_data[aid].features['timetofirstleftclic'] != -1:
                    self.aoi_data[aid].features['timetofirstleftclic'] = deepcopy(self.firstseg.aoi_data[aid].features['timetofirstleftclic'])
                    self.aoi_data[aid].features['timetofirstrightclic'] = deepcopy(self.firstseg.aoi_data[aid].features['timetofirstrightclic'])
                    self.aoi_data[aid].features['timetofirstdoubleclic'] = deepcopy(self.firstseg.aoi_data[aid].features['timetofirstdoubleclic'])
            else:
                self.aoi_data[aid].features['timetofirstfixation'] = float('inf')
                self.aoi_data[aid].features['timetofirstleftclic'] = float('inf')
                self.aoi_data[aid].features['timetofirstrightclic'] = float('inf')
                self.aoi_data[aid].features['timetofirstdoubleclic'] = float('inf')
        """
        if len(self.aoi_data) > 0:
            self.has_aois = True


    def merge_fixation_features(self, segments):
        """ Merge fixation features such as
                meanfixationduration:     mean duration of fixations
                stddevfixationduration    standard deviation of duration of fixations
                sumfixationduration:      sum of durations of fixations
                fixationrate:             rate of fixation datapoints relative to all datapoints
            Args:
                segments: The list of Segments for this Scene with pre-calculated features
        """
        self.numfixations = sumfeat(segments, 'numfixations')
        self.features['numfixations'] = self.numfixations
        self.features['fixationrate'] = float(self.numfixations) / (self.length - self.length_invalid)

        if self.numfixations > 0:
            self.features['meanfixationduration'] = weightedmeanfeat(segments,'numfixations',"features['meanfixationduration']")
            self.features['stddevfixationduration'] = aggregatestddevfeat(segments, 'numfixations', "features['stddevfixationduration']", "features['meanfixationduration']", self.features['meanfixationduration'])
            self.features['sumfixationduration'] = sumfeat(segments, "features['sumfixationduration']")
            self.features['fixationrate'] = float(self.numfixations)/(self.length - self.length_invalid)
        else:
            self.features['meanfixationduration'] = -1
            self.features['stddevfixationduration'] = -1
            self.features['sumfixationduration'] = -1
            self.features['fixationrate'] = -1


    def merge_path_angle_features(self, segments):
        """ Merge path and angle features such as
                meanpathdistance:         mean of path distances
                sumpathdistance:          sum of path distances
                eyemovementvelocity:      average eye movement velocity
                sumabspathangles:         sum of absolute path angles
                abspathanglesrate:        ratio of absolute path angles relative to all datapoints
                stddevabspathangles:      standard deviation of absolute path angles
                sumrelpathangles:         sum of relative path angles
                relpathanglesrate:        ratio of relative path angles relative to all datapoints
                stddevrelpathangles:      standard deviation of relative path angles
            Args:
                segments: The list of Segments for this Scene with pre-calculated features
        """
        self.numfixdistances = sumfeat(segments, "numfixdistances")
        self.numabsangles = sumfeat(segments, "numabsangles")
        self.numrelangles = sumfeat(segments, "numrelangles")

        if self.numfixations > 1:
            self.features['meanpathdistance'] = weightedmeanfeat(segments,'numfixdistances',"features['meanpathdistance']")
            self.features['sumpathdistance'] = sumfeat(segments, "features['sumpathdistance']")
            self.features['stddevpathdistance'] = aggregatestddevfeat(segments, 'numfixdistances', "features['stddevpathdistance']", "features['meanpathdistance']", self.features['meanpathdistance'])
            self.features['eyemovementvelocity'] = self.features['sumpathdistance']/(self.length - self.length_invalid)
            self.features['sumabspathangles'] = sumfeat(segments, "features['sumabspathangles']")
            self.features['meanabspathangles'] = weightedmeanfeat(segments,'numabsangles',"features['meanabspathangles']")
            self.features['abspathanglesrate'] = self.features['sumabspathangles']/(self.length - self.length_invalid)
            self.features['stddevabspathangles'] = aggregatestddevfeat(segments, 'numabsangles', "features['stddevabspathangles']", "features['meanabspathangles']", self.features['meanabspathangles'])
            self.features['sumrelpathangles'] = sumfeat(segments, "features['sumrelpathangles']")
            self.features['meanrelpathangles'] = weightedmeanfeat(segments,'numrelangles',"features['meanrelpathangles']")
            self.features['relpathanglesrate'] = self.features['sumrelpathangles']/(self.length - self.length_invalid)
            self.features['stddevrelpathangles'] = aggregatestddevfeat(segments, 'numrelangles', "features['stddevrelpathangles']", "features['meanrelpathangles']", self.features['meanrelpathangles'])
        else:
            self.features['meanpathdistance'] = -1
            self.features['sumpathdistance'] = -1
            self.features['stddevpathdistance'] = -1
            self.features['eyemovementvelocity'] = -1
            self.features['sumabspathangles'] = -1
            self.features['abspathanglesrate'] = -1
            self.features['meanabspathangles']= -1
            self.features['stddevabspathangles']= -1
            self.features['sumrelpathangles'] = -1
            self.features['relpathanglesrate'] = -1
            self.features['meanrelpathangles']= -1
            self.features['stddevrelpathangles'] = -1


    def merge_blink_features(self, segments):
        """ Merge blink features asuch as
                blink_num:                 number of blinks
                blink_duration_total:       sum of the blink durations
                blink_duration_mean:        mean of the blink durations
                blink_duration_std:         standard deviation of blink durations
                blink_duration_max:         maximal blink duration
                blink_duration_min:         minimal blink duration
                blink_rate:                 rate of blinks
                blink_time_distance_mean:   mean time difference between consequtive blinks
                blink_time_distance_std:    std time difference between consequtive blinks
                blink_time_distance_min:    minimal time difference between consequtive blinks
                blink_time_distance_max:    maximal time difference between consequtive blinks
            Args:
                segments: The list of Segments for this Scene with pre-calculated features
        """
        self.features['blinknum'] = sumfeat(segments, "features['blinknum']")
        if self.features['blinknum'] > 0:
            self.features['blinkdurationtotal']     = sumfeat(segments, "features['blinkdurationtotal']")
            self.features['blinkdurationmean']      = weightedmeanfeat(segments, "features['blinknum']", "features['blinkdurationmean']")
            self.features['blinkdurationstd']       = aggregatestddevfeat(segments, "features['blinknum']", "features['blinkdurationstd']",
                                                      "features['blinkdurationmean']", self.features['blinkdurationmean'])
            self.features['blinkdurationmin']       = minfeat(segments, "features['blinkdurationmin']", -1)
            self.features['blinkdurationmax']       = maxfeat(segments, "features['blinkdurationmax']")
            self.features['blinkrate']              = float(self.features['blinknum']) / (self.length - self.length_invalid)
            self.features['blinktimedistancemean']  = weightedmeanfeat(segments,
                                                      "features['blinknum']", "features['blinktimedistancemean']")
            self.features['blinktimedistancestd']   = aggregatestddevfeat(segments, "features['blinknum']",
                                                      "features['blinktimedistancestd']", "features['blinktimedistancemean']",
                                                      self.features['blinktimedistancemean'])
            self.features['blinktimedistancemin']   = minfeat(segments, "features['blinktimedistancemin']", -1)
            self.features['blinktimedistancemax']   = maxfeat(segments, "features['blinktimedistancemax']")
        else:
            self.features['blinkdurationtotal']     = -1
            self.features['blinkdurationmean']      = -1
            self.features['blinkdurationstd']       = -1
            self.features['blinkdurationmin']       = -1
            self.features['blinkdurationmax']       = -1
            self.features['blinkrate']              = -1
            self.features['blinktimedistancemean']  = -1
            self.features['blinktimedistancestd']   = -1
            self.features['blinktimedistancemin']   = -1
            self.features['blinktimedistancemax']   = -1


    def merge_pupil_features(self, export_pupilinfo, segments):
        """ Merge pupil features asuch as
                mean_pupil_size:            mean of pupil sizes
                stddev_pupil_size:          standard deviation of pupil sizes
                min_pupil_size:             smallest pupil size
                max_pupil_size:             largest pupil size
                mean_pupil_velocity:        mean of pupil velocities
                stddev_pupil_velocity:      standard deviation of pupil velocities
                min_pupil_velocity:         smallest pupil velocity
                max_pupil_velocity:         largest pupil velocity
            Args:
                segments: The list of Segments for this Scene with pre-calculated features
                export_pupilinfo: True to export raw pupil data in EMDAT output (False by default).
        """
        self.numpupilsizes    = sumfeat(segments,'numpupilsizes')
        self.numpupilvelocity = sumfeat(segments,'numpupilvelocity')

        if self.numpupilsizes > 0: # check if scene has any pupil data
            if export_pupilinfo:
                self.pupilinfo_for_export = mergevalues(segments, 'pupilinfo_for_export')
            self.features['meanpupilsize'] = weightedmeanfeat(segments, 'numpupilsizes', "features['meanpupilsize']")
            self.features['stddevpupilsize'] = aggregatestddevfeat(segments, 'numpupilsizes', "features['stddevpupilsize']", "features['meanpupilsize']", self.features['meanpupilsize']) #stddev(self.adjvalidpupilsizes)
            self.features['maxpupilsize'] = maxfeat(segments, "features['maxpupilsize']")
            self.features['minpupilsize'] = minfeat(segments, "features['minpupilsize']", -1)
            self.features['startpupilsize'] = self.firstseg.features['startpupilsize']
            self.features['endpupilsize'] = self.endseg.features['endpupilsize']
        else:
            self.pupilinfo_for_export = []
            self.features['meanpupilsize'] = -1
            self.features['stddevpupilsize'] = -1
            self.features['maxpupilsize'] = -1
            self.features['minpupilsize'] = -1
            self.features['startpupilsize'] = -1
            self.features['endpupilsize'] = -1

        if self.numpupilvelocity > 0: # check if scene has any pupil velocity data
            self.features['meanpupilvelocity'] = weightedmeanfeat(segments, 'numpupilvelocity', "features['meanpupilvelocity']")
            self.features['stddevpupilvelocity'] = aggregatestddevfeat(segments, 'numpupilvelocity', "features['stddevpupilvelocity']", "features['meanpupilvelocity']", self.features['meanpupilvelocity']) #stddev(self.valid_pupil_velocity)
            self.features['maxpupilvelocity'] = maxfeat(segments, "features['maxpupilvelocity']")
            self.features['minpupilvelocity'] = minfeat(segments, "features['minpupilvelocity']", -1)
        else:
            self.features['meanpupilvelocity'] = -1
            self.features['stddevpupilvelocity'] = -1
            self.features['maxpupilvelocity'] = -1
            self.features['minpupilvelocity'] = -1


    def merge_distance_data(self, segments):
        """ Merge distance features such as
                mean_distance:            mean of distances from the screen
                stddev_distance:          standard deviation of distances from the screen
                min_distance:             smallest distance from the screen
                max_distance:             largest distance from the screen
                start_distance:           distance from the screen in the beginning of this scene
                end_distance:             distance from the screen in the end of this scene

            Args:
                segments: The list of Segments for this Scene with pre-calculated features
        """
        self.numdistancedata = sumfeat(segments,'numdistancedata') #Distance
        if self.numdistancedata > 0: # check if scene has any pupil data
            self.features['meandistance'] = weightedmeanfeat(segments, 'numdistancedata', "features['meandistance']")
            self.features['stddevdistance'] = aggregatestddevfeat(segments, 'numdistancedata', "features['stddevdistance']", "features['meandistance']", self.features['meandistance'])
            self.features['maxdistance'] = maxfeat(segments, "features['maxdistance']")
            self.features['mindistance'] = minfeat(segments, "features['mindistance']", -1)
            self.features['startdistance'] = self.firstseg.features['startdistance']
            self.features['enddistance'] = self.endseg.features['enddistance']
        else:
            self.features['meandistance'] = -1
            self.features['stddevdistance'] = -1
            self.features['maxdistance'] = -1
            self.features['mindistance'] = -1
            self.features['startdistance'] = -1
            self.features['enddistance'] = -1


    def merge_saccade_data(self, saccade_data, segments):
        """ Merge saccade features such as
                numsaccades:              number of saccades in the segment
                sumsaccadedistance:       sum of distances during each saccade
                meansaccadedistance:      mean of distances during each saccade
                stddevsaccadedistance:    standard deviation of distances during each saccade
                longestsaccadedistance:   distance of longest saccade
                sumsaccadeduration:       total time spent on saccades in this segment
                meansaccadeduration:      average saccade duration
                stddevsaccadeduration:    standard deviation of saccade durations
                longestsaccadeduration:   longest duration of saccades in this segment
                meansaccadespeed:         average speed of saccades in this segment
                stddevsaccadespeed:       standard deviation of speed of saccades in this segment
                maxsaccadespeed:          highest saccade speed in this segment
                minsaccadespeed:          lowest saccade speed in this  segment
                fixationsaccadetimeratio: fixation to saccade time ratio for this segment
            Args:
                saccade_data: The list of saccade datapoints for this Scene
                segments: The list of Segments for this Scene with pre-calculated features
        """
        if saccade_data != None:
            self.features['numsaccades'] = sumfeat(segments,'numsaccades')
            self.features['sumsaccadedistance'] = sumfeat(segments, "features['sumsaccadedistance']")
            self.features['meansaccadedistance'] = weightedmeanfeat(self.segments,'numsaccades',"features['meansaccadedistance']")
            self.features['stddevsaccadedistance'] = aggregatestddevfeat(segments, 'numsaccades', "features['stddevsaccadedistance']", "features['meansaccadedistance']", self.features['meansaccadedistance'])
            self.features['longestsaccadedistance'] = maxfeat(segments, "features['longestsaccadedistance']")
            self.features['sumsaccadeduration'] = sumfeat(segments,"features['sumsaccadeduration']")
            self.features['meansaccadeduration'] = weightedmeanfeat(self.segments,'numsaccades',"features['meansaccadeduration']")
            self.features['stddevsaccadeduration'] = aggregatestddevfeat(segments, 'numsaccades', "features['stddevsaccadeduration']", "features['meansaccadeduration']", self.features['meansaccadeduration'])
            self.features['longestsaccadeduration'] = maxfeat(segments, "features['longestsaccadeduration']")
            self.features['meansaccadespeed'] = weightedmeanfeat(self.segments,'numsaccades',"features['meansaccadespeed']")
            self.features['stddevsaccadespeed'] = aggregatestddevfeat(segments, 'numsaccades', "features['stddevsaccadespeed']", "features['meansaccadespeed']", self.features['meansaccadespeed'])
            self.features['maxsaccadespeed'] = maxfeat(segments, "features['maxsaccadespeed']")
            self.features['minsaccadespeed'] = minfeat(segments, "features['minsaccadespeed']", -1)
            self.features['fixationsaccadetimeratio'] = sumfeat(segments, "features['fixationsaccadetimeratio']") / float(len(segments))
        else:
            self.features['numsaccades'] = 0
            self.features['sumsaccadedistance'] = -1
            self.features['meansaccadedistance'] = -1
            self.features['stddevsaccadedistance'] = -1
            self.features['longestsaccadedistance'] = -1
            self.features['sumsaccadeduration'] = -1
            self.features['meansaccadeduration'] = -1
            self.features['stddevsaccadeduration'] = -1
            self.features['longestsaccadeduration'] = -1
            self.features['meansaccadespeed'] = -1
            self.features['stddevsaccadespeed'] = -1
            self.features['maxsaccadespeed'] = -1
            self.features['minsaccadespeed'] = -1
            self.features['fixationsaccadetimeratio'] = -1


    def merge_event_data(self, event_data, segments):
        """ Merge event features such as
                numevents:                number of events in the segment
                numleftclic:              number of left clinks in the segment
                numrightclic:             number of right clinks in the segment
                numdoubleclic:            number of double clinks in the segment
                numkeypressed:            number of times a key was pressed in the segment
                leftclicrate:             the rate of left clicks (relative to all datapoints) in this segment
                rightclicrate:            the rate of right clicks (relative to all datapoints) in this segment
                doubleclicrate:           the rate of double clicks (relative to all datapoints) in this segment
                keypressedrate:           the rate of key presses (relative to all datapoints) in this segment
                timetofirstleftclic:      time until the first left click in this segment
                timetofirstrightclic:     time until the first right click in this segment
                timetofirstdoubleclic:    time until the first double click in this segment
                timetofirstkeypressed:    time until the first key pressed in this segment
            Args:
                event_data: The list of events for this Scene
                segments: The list of Segments for this Scene with pre-calculated features
        """
        if event_data != None:
            self.features['numevents'] = sumfeat(segments,'numevents')
            self.features['numleftclic'] = sumfeat(segments,"features['numleftclic']")
            self.features['numrightclic'] = sumfeat(segments, "features['numrightclic']")
            self.features['numdoubleclic'] = sumfeat(segments, "features['numdoubleclic']")
            self.features['numkeypressed'] = sumfeat(segments, "features['numkeypressed']")
            self.features['leftclicrate'] = float(self.features['numleftclic'])/(self.length - self.length_invalid)
            self.features['rightclicrate'] = float(self.features['numrightclic'])/(self.length - self.length_invalid)
            self.features['doubleclicrate'] = float(self.features['numdoubleclic'])/(self.length - self.length_invalid)
            self.features['keypressedrate'] = float(self.features['numkeypressed'])/(self.length - self.length_invalid)
            self.features['timetofirstleftclic'] = self.firstseg.features['timetofirstleftclic']
            self.features['timetofirstrightclic'] = self.firstseg.features['timetofirstrightclic']
            self.features['timetofirstdoubleclic'] = self.firstseg.features['timetofirstdoubleclic']
            self.features['timetofirstkeypressed'] = self.firstseg.features['timetofirstkeypressed']
        else:
            self.features['numevents'] = 0
            self.features['numleftclic'] = 0
            self.features['numrightclic'] = 0
            self.features['numdoubleclic'] = 0
            self.features['numkeypressed'] = 0
            self.features['leftclicrate'] = -1
            self.features['rightclicrate'] = -1
            self.features['doubleclicrate'] = -1
            self.features['keypressedrate'] = -1
            self.features['timetofirstleftclic'] = -1
            self.features['timetofirstrightclic'] = -1
            self.features['timetofirstdoubleclic'] = -1
            self.features['timetofirstkeypressed'] = -1

    def merge_aoisequences(self, segments):
        """returns the AOI sequence merged from the AOI sequences in the "Segment"s
        Args:
            segments: a list of "Segment"s which belong to this Scene.
        Returns:
            a list of AOI names that correspond to the sequence of "Fixation"s in this Scene
        """
        sequence = []
        for seg in segments:
            sequence.extend(seg.features.get('aoisequence', []))
        return sequence

    def get_length_invalid(self):
        length = 0
        for segment in self.segments:
            length += segment.length_invalid
        return length

    def clean_memory(self):
        return
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#Scene.Scene">Scene</a></li>
          <li>EMDAT_core.Segment.Segment</li>
          </ul>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="Scene.Scene.end" class="name">var <span class="ident">end</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="Scene.Scene.endseg" class="name">var <span class="ident">endseg</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="Scene.Scene.features" class="name">var <span class="ident">features</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="Scene.Scene.firstseg" class="name">var <span class="ident">firstseg</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="Scene.Scene.has_aois" class="name">var <span class="ident">has_aois</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="Scene.Scene.is_valid" class="name">var <span class="ident">is_valid</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="Scene.Scene.largest_data_gap" class="name">var <span class="ident">largest_data_gap</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="Scene.Scene.length" class="name">var <span class="ident">length</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="Scene.Scene.length_invalid" class="name">var <span class="ident">length_invalid</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="Scene.Scene.numfixations" class="name">var <span class="ident">numfixations</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="Scene.Scene.numsamples" class="name">var <span class="ident">numsamples</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="Scene.Scene.proportion_valid" class="name">var <span class="ident">proportion_valid</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="Scene.Scene.proportion_valid_fix" class="name">var <span class="ident">proportion_valid_fix</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="Scene.Scene.require_valid_Segments" class="name">var <span class="ident">require_valid_Segments</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="Scene.Scene.scid" class="name">var <span class="ident">scid</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="Scene.Scene.start" class="name">var <span class="ident">start</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="Scene.Scene.validity1" class="name">var <span class="ident">validity1</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="Scene.Scene.validity2" class="name">var <span class="ident">validity2</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="Scene.Scene.validity3" class="name">var <span class="ident">validity3</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="Scene.Scene.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, scid, seglist, all_data, fixation_data, saccade_data=None, event_data=None, Segments=None, aoilist=None, prune_length=None, require_valid=True, auto_partition=False, rest_pupil_size=0, export_pupilinfo=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Args:
    scid: A string containing the id of the Scene.</p>
<pre><code>seglist: a list of tuples of the form (segid, start, end) defining the segments
*Note: this method of defining segments is implemented to make batch processing of
files defining segments easier

all_data: a list of "Datapoint"s which make up this Scene.

fixation_data: a list of "Fixation"s which make up this Scene.

saccade_data: If not None, a list of "Saccade"s which make up this Scene.

event_data: If not None, a list of "Event"s which make up this Scene.

Segments: a list of "Segment"s which belong to this Scene.

aoilist: If not None, a list of "AOI"s.

prune_length: If not None, an integer that specifies the time
    interval (in ms) from the begining of each Segment of this Scene
    which samples are considered in calculations.  This can be used if,
    for example, you only wish to consider data in the first
    1000 ms of each Segment. In this case (prune_length = 1000),
    all data beyond the first 1000ms of the start of the "Segment"s
    will be disregarded.

require_valid: a boolean determining whether invalid "Segment"s
    will be ignored when calculating the features or not. default = True

auto_partition: a boolean flag determining whether
    EMDAT should automatically split the "Segment"s which have low sample quality
    into two new ssub "Segment"s discarding the largest invalid sample gap in
    the "Segment". default = False

rest_pupil_size: rest pupil size for the current scene
</code></pre>
<p>Yields:
    a Scene object</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.__init__', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.__init__" class="source">
    <pre><code>def __init__(self, scid, seglist, all_data, fixation_data, saccade_data = None, event_data = None, Segments = None, aoilist = None,
              prune_length= None, require_valid = True, auto_partition = False, rest_pupil_size = 0, export_pupilinfo = False):
    """
    Args:
        scid: A string containing the id of the Scene.
        seglist: a list of tuples of the form (segid, start, end) defining the segments
        *Note: this method of defining segments is implemented to make batch processing of
        files defining segments easier
        all_data: a list of "Datapoint"s which make up this Scene.
        fixation_data: a list of "Fixation"s which make up this Scene.
        saccade_data: If not None, a list of "Saccade"s which make up this Scene.
        event_data: If not None, a list of "Event"s which make up this Scene.
        Segments: a list of "Segment"s which belong to this Scene.
        aoilist: If not None, a list of "AOI"s.
        prune_length: If not None, an integer that specifies the time
            interval (in ms) from the begining of each Segment of this Scene
            which samples are considered in calculations.  This can be used if,
            for example, you only wish to consider data in the first
            1000 ms of each Segment. In this case (prune_length = 1000),
            all data beyond the first 1000ms of the start of the "Segment"s
            will be disregarded.
        require_valid: a boolean determining whether invalid "Segment"s
            will be ignored when calculating the features or not. default = True
        auto_partition: a boolean flag determining whether
            EMDAT should automatically split the "Segment"s which have low sample quality
            into two new ssub "Segment"s discarding the largest invalid sample gap in
            the "Segment". default = False
        rest_pupil_size: rest pupil size for the current scene
    Yields:
        a Scene object
    """
    ########################################
    def partition_segment(new_seg, seg_start, seg_end, rest_pupil_size, export_pupilinfo):
        """ A helper method for splitting a Segment object into new Segments and removing gaps of invalid samples
        One way to deal with a low quality Segment is to find the gaps of invalid samples within its "Datapoint"s and
        splitting the Segment into two Segments one from the beginnning of the Segment to the gap and another from after
        the gap to the end of the Segment. This can be done multiple times resulting multiple "Segment"s with higher
        quality. For example if a Segment S1 started at s1 and ended at e1 and had two invalid gaps between gs1-ge1 and
        gs2-ge2 milliseconds, this method will generate the following three segments
            SS1: starting at s1 and ending at gs1
            SS2: starting at ge1 and ending at gs2
            SS3: starting at ge2 and ending at e1
        Args:
            new_seg: The Segment that is being split
            seg_start: An integer showing the start time of the segment in milliseconds
            seg_end: An integer showing the end time of the segment in milliseconds
            rest_pupil_size: rest pupil size for the current scene
        Returns:
            subsegments: a list of newly generated "Segment"s
            samp_inds: a list of tuples of the form (start, end) that detrmines the index of the start and end of each
                new Segment in the old Segment's all_data field
            fix_inds: a list of tuples of the form (start, end) that detrmines the index of the start and end of each
                new Segment in the old Segment's fixation_data field
            sac_inds: a list of tuples of the form (start, end) that detrmines the index of the start and end of each
                new Segment in the old Segment's saccade_data field
            event_inds: a list of tuples of the form (start, end) that detrmines the index of the start and end of each
                new Segment in the old Segment's event_data field
        """
        timegaps = new_seg.getgaps()
        subsegments = []
        sub_segid = 0
        samp_inds = []
        fix_inds = []
        saccade_inds = []
        event_inds = []
        last_samp_idx = 0
        last_fix_idx = 0
        last_sac_idx = 0
        last_event_idx = 0
        sub_seg_time_start = seg_start
        for timebounds in timegaps:
            sub_seg_time_end = timebounds[0] #end of this sub_seg is start of this gap
            last_samp_idx, all_start,all_end = get_chunk(all_data, last_samp_idx, sub_seg_time_start, sub_seg_time_end)
            last_fix_idx, fix_start, fix_end = get_chunk(fixation_data, last_fix_idx, sub_seg_time_start, sub_seg_time_end)
            if saccade_data != None:
                last_sac_idx, sac_start, sac_end = get_chunk(saccade_data, last_sac_idx, sub_seg_time_start, sub_seg_time_end)
                saccade_data_in_part = saccade_data[sac_start:sac_end]
            else:
                saccade_data_in_part = None
            if event_data != None:
                last_event_idx, event_start, event_end = get_chunk(event_data, last_event_idx, sub_seg_time_start, sub_seg_time_end)
                event_data_in_part = event_data[event_start:event_end]
            else:
                event_data_in_part = None
            sub_seg_time_start = timebounds[1] #beginning of the next sub_seg is end of this gap
            if fix_end - fix_start>0:
                try:
                    new_sub_seg = Segment(segid+"_"+str(sub_segid), all_data[all_start:all_end], fixation_data[fix_start:fix_end], saccade_data=saccade_data_in_part,
                                  event_data=event_data_in_part, aois=aoilist, prune_length=prune_length, rest_pupil_size = rest_pupil_size, export_pupilinfo = export_pupilinfo)
                except  Exception as e:
                    warn(str(e))
                    if params.DEBUG:
                        raise
                    else:
                        continue
            else:
                continue
            subsegments.append(new_sub_seg)
            samp_inds.append((all_start,all_end))
            fix_inds.append((fix_start, fix_end))
            if saccade_data != None:
                saccade_inds.append((sac_start, sac_end))
            if event_data != None:
                event_inds.append((event_start, event_end))
            sub_segid +=1
        # handling the last sub_seg
        sub_seg_time_end = seg_end #end of last sub_seg is the end of seg
        last_samp_idx, all_start,all_end = get_chunk(all_data, last_samp_idx, sub_seg_time_start, sub_seg_time_end)
        last_fix_idx, fix_start, fix_end = get_chunk(fixation_data, last_fix_idx, sub_seg_time_start, sub_seg_time_end)
        if saccade_data != None:
            last_sac_idx, sac_start, sac_end = get_chunk(saccade_data, last_sac_idx, sub_seg_time_start, sub_seg_time_end)
            saccade_data_in_part = saccade_data[sac_start:sac_end]
        else:
            saccade_data_in_part = None
        if event_data != None:
            last_event_idx, event_start, event_end = get_chunk(event_data, last_event_idx, sub_seg_time_start, sub_seg_time_end)
            event_data_in_part = event_data[event_start:event_end]
        else:
            event_data_in_part = None
        if fix_end - fix_start>0: #add the last sub_seg
            try:
                new_sub_seg = Segment(segid+"_"+str(sub_segid), all_data[all_start:all_end], fixation_data[fix_start:fix_end], saccade_data_in_part,
                                  event_data=event_data_in_part, aois=aoilist, prune_length=prune_length, rest_pupil_size = rest_pupil_size, export_pupilinfo = export_pupilinfo)
            except Exception as e:
                warn(str(e))
                if params.DEBUG:
                    raise
                else:
                    new_sub_seg = None
            if new_sub_seg != None:
                subsegments.append(new_sub_seg)
                samp_inds.append((all_start,all_end))
                fix_inds.append((fix_start, fix_end))
                if saccade_data != None:
                    saccade_inds.append((sac_start, sac_end))
                if event_data != None:
                    event_inds.append((event_start, event_end))
        #end of handling the last sub_seg
        return subsegments, samp_inds, fix_inds, saccade_inds, event_inds
    ######################################## end partition_segment()
    if len(all_data)<=0:
        raise Exception('A scene with no sample data!')
    if Segments == None:
        self.segments = []
         print "seglist",seglist
        for (segid, start, end) in seglist:
            if params.VERBOSE != "QUIET":
                print("segid, start, end:", segid, start, end)
            # Selecting subsets of points belonging only to the current segment
            if prune_length != None:
                end = min(end, start+prune_length)
            _, all_start, all_end = get_chunk(all_data, 0, start, end)
            _, fix_start, fix_end = get_chunk(fixation_data, 0, start, end)
            if saccade_data != None:
                _, sac_start, sac_end = get_chunk(saccade_data, 0, start, end)
                saccade_data_in_seg = saccade_data[sac_start:sac_end]
            else:
                sac_start = None
                sac_end = None
                saccade_data_in_seg = None
            if event_data != None:
                _, event_start, event_end = get_chunk(event_data, 0, start, end)
                event_data_in_seg = event_data[event_start:event_end]
            else:
                event_start = None
                event_end = None
                event_data_in_seg = None
            if fix_end - fix_start>0:
                try:
                    new_seg = Segment(segid, all_data[all_start:all_end], fixation_data[fix_start:fix_end], saccade_data = saccade_data_in_seg,
			        event_data=event_data_in_seg, aois=aoilist, prune_length=prune_length, rest_pupil_size = rest_pupil_size, export_pupilinfo = export_pupilinfo)
                except  Exception as e:
                    warn(str(e))
                    if params.DEBUG:
                        raise
                    else:
                        continue
            else:
                continue
            if (new_seg.largest_data_gap > params.MAX_SEG_TIMEGAP) and auto_partition: #low quality segment that needs to be partitioned!
                try:
                    new_segs, samp_inds, fix_inds, sac_inds, event_inds = partition_segment(new_seg, start, end, rest_pupil_size, export_pupilinfo=export_pupilinfo)
                    if saccade_data != None and event_data != None:
                        for nseg,samp,fix,sac,eve in zip(new_segs, samp_inds, fix_inds, sac_inds, event_inds):
                            if nseg.length > params.MINSEGSIZE:
                                nseg.set_indices(samp[0],samp[1],fix[0],fix[1],sac[0],sac[1],eve[0],eve[1])
                                self.segments.append(nseg)
                    elif saccade_data != None and event_data == None:
                        for nseg,samp,fix,sac in zip(new_segs, samp_inds, fix_inds, sac_inds):
                            if nseg.length > params.MINSEGSIZE:
                                nseg.set_indices(samp[0],samp[1],fix[0],fix[1],sac[0],sac[1])
                                self.segments.append(nseg)
                    elif saccade_data == None and event_data != None:
                        for nseg,samp,fix,eve in zip(new_segs, samp_inds, fix_inds, event_inds):
                            if nseg.length > params.MINSEGSIZE:
                                nseg.set_indices(samp[0],samp[1],fix[0],fix[1],event_st=eve[0],event_end=eve[1])
                                self.segments.append(nseg)
                    else:
                        for nseg,samp,fix in zip(new_segs, samp_inds, fix_inds):
                            if nseg.length > params.MINSEGSIZE:
                                nseg.set_indices(samp[0],samp[1],fix[0],fix[1])
                                self.segments.append(nseg)
                except Exception as e:
                    raise Exception("Error while partitioning scene. "+str(e))
            else:   #good quality segment OR no auto_partition
                new_seg.set_indices(all_start,all_end,fix_start,fix_end,sac_start,sac_end,event_start,event_end)
                self.segments.append(new_seg)
    else:
        self.segments = Segments #segments are already generated
    self.require_valid_Segments = require_valid
    if require_valid:   #filter out the invalid Segments
        segments = filter(lambda x:x.is_valid,self.segments)
    else:
        segments = self.segments
    if len(segments)==0:
        raise Exception('no segments in scene %s!' %(scid))
    fixationlist = []
    saccadelist = []
    totalfixations = 0
    firstsegtime = float('infinity')
    endsegtime = float(0)
    firstseg = None
    for seg in segments:
        sample_st,sample_end,fix_start,fix_end,sac_st,sac_end,event_st,event_end = seg.get_indices()
        if params.DEBUG or params.VERBOSE == "VERBOSE":
            print("sample_st,sample_end,fix_start,fix_end",sample_st,sample_end,fix_start,fix_end,sac_st,sac_end,event_st,event_end)
        fixationlist.append(fixation_data[fix_start:fix_end])
        totalfixations += len(fixationlist[-1])
        if seg.start < firstsegtime:
            firstsegtime = seg.start
            firstseg = seg
        if seg.end > endsegtime:
            endsegtime = seg.end
            endseg = seg
    fixationlist = []
    self.firstseg = firstseg
    self.endseg = endseg
    self.scid = scid
    self.features = {}
    self.largest_data_gap = maxfeat(self.segments,'largest_data_gap')   #self.segments is used to calculate validity of the scenes instead of segments which is only valid segments
    self.proportion_valid = weightedmeanfeat(self.segments,'numsamples','proportion_valid') #self.segments is used to calculate validity of the scenes instead of segments which is only valid segments
    self.proportion_valid_fix = weightedmeanfeat(self.segments,'numsamples','proportion_valid_fix') #self.segments is used to calculate validity of the scenes instead of segments which is only valid segments
    self.validity1 = self.calc_validity1()
    self.validity2 = self.calc_validity2()
    self.validity3 = self.calc_validity3()
    self.is_valid = self.get_validity()
    self.length = sumfeat(segments,"features['length']")
    if self.length == 0:
        raise Exception('Zero length segments!')
    self.length_invalid = self.get_length_invalid()
    self.features['numsegments'] = len(segments)
    self.features['length'] = self.length
    self.start = minfeat(segments,'start')
    self.numfixations = sumfeat(segments,'numfixations')
    self.end = maxfeat(segments,'end')
    self.numsamples = sumfeat(segments, 'numsamples')
    self.features['numsamples'] = self.numsamples
    if prune_length == None:
        if self.numfixations != totalfixations:
            if params.DEBUG:
                raise Exception('Error in fixation count for scene: '+self.scid)
            else:
                warn('Error in fixation count for scene: '+self.scid)
    self.merge_fixation_features(segments)
    self.merge_path_angle_features(segments)
    self.merge_blink_features(segments)
    self.merge_pupil_features(export_pupilinfo, segments)
    self.merge_distance_data(segments)
    self.merge_saccade_data(saccade_data, segments)
    self.merge_event_data(event_data, segments)
    self.has_aois = False
    if aoilist:
        self.set_aois(segments, aoilist)
    self.features['aoisequence'] = self.merge_aoisequences(segments)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.calc_abs_angles">
    <p>def <span class="ident">calc_abs_angles</span>(</p><p>self, fixdata)</p>
    </div>
    

    
  
    <div class="desc"><p>returns the absolute angles between a sequence of "Fixation"s that build a scan path.</p>
<p>Abosolute angle for each saccade is the angle between that saccade and the horizental axis</p>
<p>Args:
    fixdata: a list of "Fixation"s</p>
<p>Returns:
    a list of absolute angles for the saccades formed by the given sequence of "Fixation"s in Radiant</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.calc_abs_angles', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.calc_abs_angles" class="source">
    <pre><code>def calc_abs_angles(self, fixdata):
    """returns the absolute angles between a sequence of "Fixation"s that build a scan path.
    Abosolute angle for each saccade is the angle between that saccade and the horizental axis
    Args:
        fixdata: a list of "Fixation"s
    Returns:
        a list of absolute angles for the saccades formed by the given sequence of "Fixation"s in Radiant
    """
    abs_angles = []
    lastx = fixdata[0].mappedfixationpointx
    lasty = fixdata[0].mappedfixationpointy
    for i in xrange(1,len(fixdata)):
        x = fixdata[i].mappedfixationpointx
        y = fixdata[i].mappedfixationpointy
        (dist, theta) = geometry.vector_difference((lastx,lasty), (x, y))
        abs_angles.append(abs(theta))
        lastx=x
        lasty=y
    return abs_angles
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.calc_blink_features">
    <p>def <span class="ident">calc_blink_features</span>(</p><p>self, all_data)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculates blink features such as
    blink_num:                 number of blinks on the in the segment
    blink_duration_total:       sum of the blink durations for this segment
    blink_duration_mean:        mean of the blink durations for this segment
    blink_duration_std:         standard deviation of blink durations for this segment
    blink_duration_max:         maximal blink duration for this segment
    blink_duration_min:         minimal blink duration for this segment
    blink_rate:                 rate of blinks for this segment
    blink_time_distance_mean:   mean time difference between consequtive blinks
    blink_time_distance_std:    std time difference between consequtive blinks
    blink_time_distance_min:    minimal time difference between consequtive blinks
    blink_time_distance_max:    maximal time difference between consequtive blinks
Args:
    all_data: The list of "Datapoint"s which make up this Segment</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.calc_blink_features', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.calc_blink_features" class="source">
    <pre><code>def calc_blink_features(self, all_data):
    """ Calculates blink features such as
            blink_num:                 number of blinks on the in the segment
            blink_duration_total:       sum of the blink durations for this segment
            blink_duration_mean:        mean of the blink durations for this segment
            blink_duration_std:         standard deviation of blink durations for this segment
            blink_duration_max:         maximal blink duration for this segment
            blink_duration_min:         minimal blink duration for this segment
            blink_rate:                 rate of blinks for this segment
            blink_time_distance_mean:   mean time difference between consequtive blinks
            blink_time_distance_std:    std time difference between consequtive blinks
            blink_time_distance_min:    minimal time difference between consequtive blinks
            blink_time_distance_max:    maximal time difference between consequtive blinks
        Args:
            all_data: The list of "Datapoint"s which make up this Segment
    """
    blink_durations = []
    blink_intervals = []
    last_blink_detected = -1
    self.features['blinknum']               = 0
    self.features['blinkdurationtotal']     = 0
    self.features['blinkdurationmean']      = 0
    self.features['blinkdurationstd']       = 0
    self.features['blinkdurationmin']       = -1
    self.features['blinkdurationmax']       = -1
    self.features['blinkrate']              = -1
    self.features['blinktimedistancemean']  = -1
    self.features['blinktimedistancestd']   = -1
    self.features['blinktimedistancemin']   = -1
    self.features['blinktimedistancemax']   = -1
    lower_bound, upper_bould = params.blink_threshold
    ### File operations are for testing
    #file = open('outputfolder/blinks/blinks_%s.txt' % all_data[0].participant_name, 'w
    blinks_validity_gaps = self.calc_blink_validity_gaps(all_data)
    if params.EYETRACKERTYPE == "SMI":
        for i in range(len(blinks_validity_gaps)):
            blink_length = blinks_validity_gaps[i][1] - blinks_validity_gaps[i][0]
            blink_durations.append(blink_length)
            #file.write('Blink start, end: %d %d\n' % (self.time_gaps[i][0], self.time_gaps[i][1]))
            if last_blink_detected != -1:
                # Calculate time difference between start of current blink and end of previous blink
                blink_intervals.append(blinks_validity_gaps[i][0] - blinks_validity_gaps[last_blink_detected][1])
            last_blink_detected = i
    else:
        for i in range(len(blinks_validity_gaps)):
            blink_length = blinks_validity_gaps[i][1] - blinks_validity_gaps[i][0]
            if blink_length <= upper_bould and blink_length >= lower_bound:
                blink_durations.append(blink_length)
                #file.write('Blink start, end: %d %d\n' % (self.time_gaps[i][0], self.time_gaps[i][1]))
                if last_blink_detected != -1:
                    # Calculate time difference between start of current blink and end of previous blink
                    blink_intervals.append(blinks_validity_gaps[i][0] - blinks_validity_gaps[last_blink_detected][1])
                last_blink_detected = i
    #file.close()
    if len(blink_durations) > 0:
        self.features['blinknum']               = len(blink_durations)
        self.features['blinkdurationtotal']     = sum(blink_durations)
        self.features['blinkdurationmean']      = mean(blink_durations)
        self.features['blinkdurationstd']       = stddev(blink_durations)
        self.features['blinkdurationmin']       = min(blink_durations)
        self.features['blinkdurationmax']       = max(blink_durations)
        self.features['blinkrate']              = float(self.features['blinknum']) / (self.length - self.length_invalid)
    if len(blink_intervals) > 0:
        self.features['blinktimedistancemean']  = mean(blink_intervals)
        self.features['blinktimedistancestd']   = stddev(blink_intervals)
        self.features['blinktimedistancemin']   = min(blink_intervals)
        self.features['blinktimedistancemax']   = max(blink_intervals)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.calc_blink_validity_gaps">
    <p>def <span class="ident">calc_blink_validity_gaps</span>(</p><p>self, all_data)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculates the blink validity gaps for this segment</p>
<p>Args:
    all_data: The list of "Datapoint"s which make up this Segement</p>
<p>Returns:
    An array for tuples (int, int) indicating beginning and end timestamps for each contiguous invalid group of rows</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.calc_blink_validity_gaps', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.calc_blink_validity_gaps" class="source">
    <pre><code>def calc_blink_validity_gaps(self, all_data):
    """Calculates the blink validity gaps for this segment
    Args:
        all_data: The list of "Datapoint"s which make up this Segement
    Returns:
        An array for tuples (int, int) indicating beginning and end timestamps for each contiguous invalid group of rows
    """
    blinks_validity_gaps = []
    dindex = 0
    datalen = len(all_data)
    while dindex < datalen:
        d = all_data[dindex]
        while d.is_valid_blink and (dindex < datalen - 1):
            dindex += 1
            d = all_data[dindex]
        if not (d.is_valid_blink):
            gap_start = d.timestamp
            while not (d.is_valid_blink) and (dindex < datalen - 1):
                dindex += 1
                d = all_data[dindex]
            blinks_validity_gaps.append((gap_start, d.timestamp))
        dindex += 1
    return blinks_validity_gaps
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.calc_distance_features">
    <p>def <span class="ident">calc_distance_features</span>(</p><p>self, all_data)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculates distance features such as
    mean_distance:            mean of distances from the screen
    stddev_distance:          standard deviation of distances from the screen
    min_distance:             smallest distance from the screen in this segment
    max_distance:             largest distance from the screen in this segment
    start_distance:           distance from the screen in the beginning of this segment
    end_distance:             distance from the screen in the end of this segment</p>
<p>Args:
    all_data: The list of "Datapoint"s which make up this Segment</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.calc_distance_features', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.calc_distance_features" class="source">
    <pre><code>def calc_distance_features(self, all_data):
    """ Calculates distance features such as
            mean_distance:            mean of distances from the screen
            stddev_distance:          standard deviation of distances from the screen
            min_distance:             smallest distance from the screen in this segment
            max_distance:             largest distance from the screen in this segment
            start_distance:           distance from the screen in the beginning of this segment
            end_distance:             distance from the screen in the end of this segment
        Args:
            all_data: The list of "Datapoint"s which make up this Segment
    """
    # check if distances are available for all missing points
    invalid_distance_data = filter(lambda x: x.distance <= 0 and x.gazepointx >= 0, all_data)
    if len(invalid_distance_data) > 0:
        warn("Distance from screen is unavailable for a valid data sample. \
                    Number of missing points: " + str(len(invalid_distance_data)))
    #get all datapoints where distance is available
    valid_distance_data = filter(lambda x: x.distance > 0, all_data)
    #number of valid distance datapoints
    self.numdistancedata = len(valid_distance_data)
    if self.numdistancedata > 0: #check if the current segment has pupil data available
        distances_from_screen               = map(lambda x: x.distance, valid_distance_data)
        self.features['meandistance']       = mean(distances_from_screen)
        self.features['stddevdistance']     = stddev(distances_from_screen)
        self.features['maxdistance']        = max(distances_from_screen)
        self.features['mindistance']        = min(distances_from_screen)
        self.features['startdistance']      = distances_from_screen[0]
        self.features['enddistance']        = distances_from_screen[-1]
    else:
        self.features['meandistance']       = -1
        self.features['stddevdistance']     = -1
        self.features['maxdistance']        = -1
        self.features['mindistance']        = -1
        self.features['startdistance']      = -1
        self.features['enddistance']        = -1
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.calc_distances">
    <p>def <span class="ident">calc_distances</span>(</p><p>self, fixdata)</p>
    </div>
    

    
  
    <div class="desc"><p>returns the Euclidean distances between a sequence of "Fixation"s</p>
<p>Args:
    fixdata: a list of "Fixation"s</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.calc_distances', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.calc_distances" class="source">
    <pre><code>def calc_distances(self, fixdata):
    """returns the Euclidean distances between a sequence of "Fixation"s
    Args:
        fixdata: a list of "Fixation"s
    """
    distances = []
    lastx = fixdata[0].mappedfixationpointx
    lasty = fixdata[0].mappedfixationpointy
    for i in xrange(1, len(fixdata)):
        x = fixdata[i].mappedfixationpointx
        y = fixdata[i].mappedfixationpointy
        dist = math.sqrt((x - lastx)**2 + (y - lasty)**2)
        distances.append(dist)
        lastx = x
        lasty = y
    return distances
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.calc_event_features">
    <p>def <span class="ident">calc_event_features</span>(</p><p>self, event_data)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculates event features such as
    numevents:                number of events in the segment
    numleftclic:              number of left clinks in the segment
    numrightclic:             number of right clinks in the segment
    numdoubleclic:            number of double clinks in the segment
    numkeypressed:            number of times a key was pressed in the segment
    leftclicrate:             the rate of left clicks (relative to all datapoints) in this segment
    rightclicrate:            the rate of right clicks (relative to all datapoints) in this segment
    doubleclicrate:           the rate of double clicks (relative to all datapoints) in this segment
    keypressedrate:           the rate of key presses (relative to all datapoints) in this segment
    timetofirstleftclic:      time until the first left click in this segment
    timetofirstrightclic:     time until the first right click in this segment
    timetofirstdoubleclic:    time until the first double click in this segment
    timetofirstkeypressed:    time until the first key pressed in this segment
Args:
    event_data: The list of events for this Segment</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.calc_event_features', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.calc_event_features" class="source">
    <pre><code>def calc_event_features(self, event_data):
    """ Calculates event features such as
            numevents:                number of events in the segment
            numleftclic:              number of left clinks in the segment
            numrightclic:             number of right clinks in the segment
            numdoubleclic:            number of double clinks in the segment
            numkeypressed:            number of times a key was pressed in the segment
            leftclicrate:             the rate of left clicks (relative to all datapoints) in this segment
            rightclicrate:            the rate of right clicks (relative to all datapoints) in this segment
            doubleclicrate:           the rate of double clicks (relative to all datapoints) in this segment
            keypressedrate:           the rate of key presses (relative to all datapoints) in this segment
            timetofirstleftclic:      time until the first left click in this segment
            timetofirstrightclic:     time until the first right click in this segment
            timetofirstdoubleclic:    time until the first double click in this segment
            timetofirstkeypressed:    time until the first key pressed in this segment
        Args:
            event_data: The list of events for this Segment
    """
    if event_data != None:
        (leftc, rightc, doublec, keyp) = generate_event_lists(event_data)
        self.numevents = len(leftc)+len(rightc)+len(doublec)+len(keyp)
        self.features['numevents'] = self.numevents
        self.features['numleftclic'] = len(leftc)
        self.features['numrightclic'] = len(rightc)
        self.features['numdoubleclic'] = len(doublec)
        self.features['numkeypressed'] = len(keyp)
        self.features['leftclicrate'] = float(len(leftc))/(self.length - self.length_invalid)
        self.features['rightclicrate'] = float(len(rightc))/(self.length - self.length_invalid)
        self.features['doubleclicrate'] = float(len(doublec))/(self.length - self.length_invalid)
        self.features['keypressedrate'] = float(len(keyp))/(self.length - self.length_invalid)
        self.features['timetofirstleftclic'] = leftc[0].timestamp if len(leftc) > 0 else -1
        self.features['timetofirstrightclic'] = rightc[0].timestamp if len(rightc) > 0 else -1
        self.features['timetofirstdoubleclic'] = doublec[0].timestamp if len(doublec) > 0 else -1
        self.features['timetofirstkeypressed'] = keyp[0].timestamp if len(keyp) > 0 else -1
    else:
        self.features['numevents'] = 0
        self.features['numleftclic'] = 0
        self.features['numrightclic'] = 0
        self.features['numdoubleclic'] = 0
        self.features['numkeypressed'] = 0
        self.features['leftclicrate'] = -1
        self.features['rightclicrate'] = -1
        self.features['doubleclicrate'] = -1
        self.features['keypressedrate'] = -1
        self.features['timetofirstleftclic'] = -1
        self.features['timetofirstrightclic'] = -1
        self.features['timetofirstdoubleclic'] = -1
        self.features['timetofirstkeypressed'] = -1
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.calc_fix_ang_path_features">
    <p>def <span class="ident">calc_fix_ang_path_features</span>(</p><p>self, fixation_data)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculates fixation, angle and path features such as
    meanfixationduration:     mean duration of fixations in the segment
    stddevfixationduration    standard deviation of duration of fixations in the segment
    sumfixationduration:      sum of durations of fixations in the segment
    fixationrate:             rate of fixation datapoints relative to all datapoints in this segment
    meanpathdistance:         mean of path distances for this segment
    sumpathdistance:          sum of path distances for this segment
    eyemovementvelocity:      average eye movement velocity for this segment
    sumabspathangles:         sum of absolute path angles for this segment
    abspathanglesrate:        ratio of absolute path angles relative to all datapoints in this segment
    stddevabspathangles:      standard deviation of absolute path angles for this segment
    sumrelpathangles:         sum of relative path angles for this segment
    relpathanglesrate:        ratio of relative path angles relative to all datapoints in this segment
    stddevrelpathangles:      standard deviation of relative path angles for this segment
Args:
    saccade_data: The list of saccade datapoints for this Segment</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.calc_fix_ang_path_features', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.calc_fix_ang_path_features" class="source">
    <pre><code>def calc_fix_ang_path_features(self, fixation_data):
    """ Calculates fixation, angle and path features such as
            meanfixationduration:     mean duration of fixations in the segment
            stddevfixationduration    standard deviation of duration of fixations in the segment
            sumfixationduration:      sum of durations of fixations in the segment
            fixationrate:             rate of fixation datapoints relative to all datapoints in this segment
            meanpathdistance:         mean of path distances for this segment
            sumpathdistance:          sum of path distances for this segment
            eyemovementvelocity:      average eye movement velocity for this segment
            sumabspathangles:         sum of absolute path angles for this segment
            abspathanglesrate:        ratio of absolute path angles relative to all datapoints in this segment
            stddevabspathangles:      standard deviation of absolute path angles for this segment
            sumrelpathangles:         sum of relative path angles for this segment
            relpathanglesrate:        ratio of relative path angles relative to all datapoints in this segment
            stddevrelpathangles:      standard deviation of relative path angles for this segment
        Args:
            saccade_data: The list of saccade datapoints for this Segment
    """
    if self.numfixations > 0:
        self.fixation_start = fixation_data[0].timestamp
        self.fixation_end = fixation_data[-1].timestamp
        self.features['meanfixationduration'] = mean(map(lambda x: float(x.fixationduration), fixation_data))
        self.features['stddevfixationduration'] = stddev(map(lambda x: float(x.fixationduration), fixation_data))
        self.features['sumfixationduration'] = sum(map(lambda x: x.fixationduration, fixation_data))
        self.features['fixationrate'] = float(self.numfixations) / (self.length - self.length_invalid)
        distances = self.calc_distances(fixation_data)
        abs_angles = self.calc_abs_angles(fixation_data)
        rel_angles = self.calc_rel_angles(fixation_data)
    else:
        self.fixation_start = -1
        self.fixation_end = -1
        self.features['meanfixationduration'] = -1
        self.features['stddevfixationduration'] = -1
        self.features['sumfixationduration'] = -1
        self.features['fixationrate'] = -1
    self.numfixdistances = len(distances)
    self.numabsangles = len(abs_angles)
    self.numrelangles = len(rel_angles)
    if len(distances) > 0:
        self.features['meanpathdistance'] = mean(distances)
        self.features['sumpathdistance'] = sum(distances)
        self.features['stddevpathdistance'] = stddev(distances)
        self.features['eyemovementvelocity'] = self.features['sumpathdistance']/(self.length - self.length_invalid)
        self.features['sumabspathangles'] = sum(abs_angles)
        self.features['abspathanglesrate'] = sum(abs_angles)/(self.length - self.length_invalid)
        self.features['meanabspathangles'] = mean(abs_angles)
        self.features['stddevabspathangles'] = stddev(abs_angles)
        self.features['sumrelpathangles'] = sum(rel_angles)
        self.features['relpathanglesrate'] = sum(rel_angles)/(self.length - self.length_invalid)
        self.features['meanrelpathangles'] = mean(rel_angles)
        self.features['stddevrelpathangles'] = stddev(rel_angles)
    else:
        self.features['meanpathdistance'] = -1
        self.features['sumpathdistance'] = -1
        self.features['stddevpathdistance'] = -1
        self.features['eyemovementvelocity'] = -1
        self.features['sumabspathangles'] = -1
        self.features['abspathanglesrate'] = -1
        self.features['meanabspathangles'] = -1
        self.features['stddevabspathangles'] = -1
        self.features['sumrelpathangles'] = -1
        self.features['relpathanglesrate'] = -1
        self.features['meanrelpathangles'] = -1
        self.features['stddevrelpathangles'] = -1
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.calc_largest_validity_gap">
    <p>def <span class="ident">calc_largest_validity_gap</span>(</p><p>self, all_data)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculates the largest gap of invalid samples in the "Datapoint"s for this Segment.</p>
<p>Args:
    all_data: The list of "Datapoint"s which make up this Segement</p>
<p>Returns:
    An integer indicating the length of largest invalid gap for this Segment in milliseconds</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.calc_largest_validity_gap', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.calc_largest_validity_gap" class="source">
    <pre><code>def calc_largest_validity_gap(self, all_data):
    """Calculates the largest gap of invalid samples in the "Datapoint"s for this Segment.
    Args:
        all_data: The list of "Datapoint"s which make up this Segement
    Returns:
        An integer indicating the length of largest invalid gap for this Segment in milliseconds
    """
    if self.numfixations == 0:
        return all_data[-1].timestamp - all_data[0].timestamp
    self.time_gaps = []
    self.all_invalid_gaps = []
    max_size = 0
    dindex = 0
    datalen = len(all_data)
    while dindex < datalen:
        d = all_data[dindex]
        while d.is_valid and (dindex < datalen - 1):
            dindex += 1
            d = all_data[dindex]
        if not (d.is_valid):
            gap_start = d.timestamp
            while not (d.is_valid) and (dindex < datalen - 1):
                dindex += 1
                d = all_data[dindex]
            if d.timestamp - gap_start > max_size:
                max_size = d.timestamp - gap_start
            if d.timestamp - gap_start > params.MAX_SEG_TIMEGAP:
                self.time_gaps.append((gap_start, d.timestamp))
        dindex += 1
    return max_size
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.calc_num_samples">
    <p>def <span class="ident">calc_num_samples</span>(</p><p>self, all_data)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the number of samples in the Segment</p>
<p>Args:
    all_data: a list of "Datapoint"s which make up this Segment.</p>
<p>Returns:
    An integer determining the number of samples in the Segment</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.calc_num_samples', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.calc_num_samples" class="source">
    <pre><code>def calc_num_samples(self, all_data):
    """Returns the number of samples in the Segment
    Args:
        all_data: a list of "Datapoint"s which make up this Segment.
    Returns:
        An integer determining the number of samples in the Segment
    """
    num = 0
    for d in all_data:
        if d.stimuliname != '':
            num += 1
    return num
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.calc_pupil_features">
    <p>def <span class="ident">calc_pupil_features</span>(</p><p>self, all_data, export_pupilinfo, rest_pupil_size)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculates pupil features such as
    mean_pupil_size:            mean of pupil sizes
    stddev_pupil_size:          standard deviation of pupil sizes
    min_pupil_size:             smallest pupil size in this segment
    max_pupil_size:             largest pupil size in this segment
    mean_pupil_velocity:        mean of pupil velocities
    stddev_pupil_velocity:      standard deviation of pupil velocities
    min_pupil_velocity:         smallest pupil velocity in this segment
    max_pupil_velocity:         largest pupil velocity in this segment</p>
<p>Args:
    all_data: The list of "Datapoint"s which make up this Segment</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.calc_pupil_features', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.calc_pupil_features" class="source">
    <pre><code>def calc_pupil_features(self, all_data, export_pupilinfo, rest_pupil_size):
    """ Calculates pupil features such as
            mean_pupil_size:            mean of pupil sizes
            stddev_pupil_size:          standard deviation of pupil sizes
            min_pupil_size:             smallest pupil size in this segment
            max_pupil_size:             largest pupil size in this segment
            mean_pupil_velocity:        mean of pupil velocities
            stddev_pupil_velocity:      standard deviation of pupil velocities
            min_pupil_velocity:         smallest pupil velocity in this segment
            max_pupil_velocity:         largest pupil velocity in this segment
        Args:
            all_data: The list of "Datapoint"s which make up this Segment
    """
    # check if pupil sizes are available for all missing points
    pupil_invalid_data = filter(lambda x: x.pupilsize == -1 and x.gazepointx > 0, all_data)
    if len(pupil_invalid_data) > 0:
        if params.DEBUG:
            raise Exception("Pupil size is unavailable for a valid data sample. \
                    Number of missing points: " + str(len(pupil_invalid_data)))
        else:
            warn("Pupil size is unavailable for a valid data sample. Number of missing points: " + str(len(pupil_invalid_data)) )
et all pupil sizes (valid + invalid)
    #pupilsizes = map(lambda x: x.pupilsize, all_data)
    #get all datapoints where pupil size is available
    valid_pupil_data = filter(lambda x: x.pupilsize > 0, all_data)
    valid_pupil_velocity = filter(lambda x: x.pupilvelocity != -1, all_data)
    #number of valid pupil sizes
    self.features['meanpupilsize']       = -1
    self.features['stddevpupilsize']     = -1
    self.features['maxpupilsize']        = -1
    self.features['minpupilsize']        = -1
    self.features['startpupilsize']      = -1
    self.features['endpupilsize']        = -1
    self.features['meanpupilvelocity']   = -1
    self.features['stddevpupilvelocity'] = -1
    self.features['maxpupilvelocity']    = -1
    self.features['minpupilvelocity']    = -1
    self.numpupilsizes                   = len(valid_pupil_data)
    self.numpupilvelocity                = len(valid_pupil_velocity)
    if self.numpupilsizes > 0: #check if the current segment has pupil data available
        if params.PUPIL_ADJUSTMENT == "rpscenter":
            adjvalidpupilsizes = map(lambda x: x.pupilsize - rest_pupil_size, valid_pupil_data)
        elif params.PUPIL_ADJUSTMENT == "PCPS":
            adjvalidpupilsizes = map(lambda x: (x.pupilsize - rest_pupil_size) / (1.0 * rest_pupil_size), valid_pupil_data)
        else:
            adjvalidpupilsizes = map(lambda x: x.pupilsize, valid_pupil_data)#valid_pupil_data
        valid_pupil_velocity = map(lambda x: x.pupilvelocity, valid_pupil_velocity)#valid_pupil_data
        if export_pupilinfo:
            self.pupilinfo_for_export = map(lambda x: [x.timestamp, x.pupilsize, rest_pupil_size], valid_pupil_data)
        self.features['meanpupilsize']           = mean(adjvalidpupilsizes)
        self.features['stddevpupilsize']         = stddev(adjvalidpupilsizes)
        self.features['maxpupilsize']            = max(adjvalidpupilsizes)
        self.features['minpupilsize']            = min(adjvalidpupilsizes)
        self.features['startpupilsize']          = adjvalidpupilsizes[0]
        self.features['endpupilsize']            = adjvalidpupilsizes[-1]
        if len(valid_pupil_velocity) > 0:
            self.features['meanpupilvelocity']   = mean(valid_pupil_velocity)
            self.features['stddevpupilvelocity'] = stddev(valid_pupil_velocity)
            self.features['maxpupilvelocity']    = max(valid_pupil_velocity)
            self.features['minpupilvelocity']    = min(valid_pupil_velocity)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.calc_rel_angles">
    <p>def <span class="ident">calc_rel_angles</span>(</p><p>self, fixdata)</p>
    </div>
    

    
  
    <div class="desc"><p>returns the relative angles between a sequence of "Fixation"s that build a scan path in Radiant</p>
<p>Relative angle for each saccade is the angle between that saccade and the previous saccade.</p>
<p>Defined as: angle = acos(v1 dot v2)  such that v1 and v2 are normalized vector2coord</p>
<p>Args:
    fixdata: a list of "Fixation"s</p>
<p>Returns:
    a list of relative angles for the saccades formed by the given sequence of "Fixation"s in Radiant</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.calc_rel_angles', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.calc_rel_angles" class="source">
    <pre><code>def calc_rel_angles(self, fixdata):
    """returns the relative angles between a sequence of "Fixation"s that build a scan path in Radiant
    Relative angle for each saccade is the angle between that saccade and the previous saccade.
    Defined as: angle = acos(v1 dot v2)  such that v1 and v2 are normalized vector2coord
    Args:
        fixdata: a list of "Fixation"s
    Returns:
        a list of relative angles for the saccades formed by the given sequence of "Fixation"s in Radiant
    """
    rel_angles = []
    lastx = fixdata[0].mappedfixationpointx
    lasty = fixdata[0].mappedfixationpointy
    for i in xrange(1, len(fixdata) - 1):
        x = fixdata[i].mappedfixationpointx
        y = fixdata[i].mappedfixationpointy
        nextx = fixdata[i + 1].mappedfixationpointx
        nexty = fixdata[i + 1].mappedfixationpointy
        v1 = (lastx - x, lasty - y)
        v2 = (nextx - x, nexty - y)
        if v1 != (0.0, 0.0) and v2 != (0.0, 0.0):
            v1_dot = math.sqrt(geometry.simpledotproduct(v1, v1))
            v2_dot = math.sqrt(geometry.simpledotproduct(v2, v2))
            normv1 = ((lastx - x) / v1_dot, (lasty - y) / v1_dot)
            normv2 = ((nextx - x) / v2_dot, (nexty - y) / v2_dot)
            dotproduct = geometry.simpledotproduct(normv1, normv2)
            if dotproduct < -1:
                dotproduct = -1.0
            if dotproduct > 1:
                dotproduct = 1.0
            theta = math.acos(dotproduct)
            rel_angles.append(theta)
        else:
            rel_angles.append(0.0)
        lastx = x
        lasty = y
    return rel_angles
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.calc_saccade_features">
    <p>def <span class="ident">calc_saccade_features</span>(</p><p>self, saccade_data)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculates saccade features such as
    numsaccades:              number of saccades in the segment
    sumsaccadedistance:       sum of distances during each saccade
    meansaccadedistance:      mean of distances during each saccade
    stddevsaccadedistance:    standard deviation of distances during each saccade
    longestsaccadedistance:   distance of longest saccade
    sumsaccadeduration:       total time spent on saccades in this segment
    meansaccadeduration:      average saccade duration
    stddevsaccadeduration:    standard deviation of saccade durations
    longestsaccadeduration:   longest duration of saccades in this segment
    meansaccadespeed:         average speed of saccades in this segment
    stddevsaccadespeed:       standard deviation of speed of saccades in this segment
    maxsaccadespeed:          highest saccade speed in this segment
    minsaccadespeed:          lowest saccade speed in this  segment
    fixationsaccadetimeratio: fixation to saccade time ratio for this segment
Args:
    saccade_data: The list of saccade datapoints for this Segment</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.calc_saccade_features', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.calc_saccade_features" class="source">
    <pre><code>def calc_saccade_features(self, saccade_data):
    """ Calculates saccade features such as
            numsaccades:              number of saccades in the segment
            sumsaccadedistance:       sum of distances during each saccade
            meansaccadedistance:      mean of distances during each saccade
            stddevsaccadedistance:    standard deviation of distances during each saccade
            longestsaccadedistance:   distance of longest saccade
            sumsaccadeduration:       total time spent on saccades in this segment
            meansaccadeduration:      average saccade duration
            stddevsaccadeduration:    standard deviation of saccade durations
            longestsaccadeduration:   longest duration of saccades in this segment
            meansaccadespeed:         average speed of saccades in this segment
            stddevsaccadespeed:       standard deviation of speed of saccades in this segment
            maxsaccadespeed:          highest saccade speed in this segment
            minsaccadespeed:          lowest saccade speed in this  segment
            fixationsaccadetimeratio: fixation to saccade time ratio for this segment
        Args:
            saccade_data: The list of saccade datapoints for this Segment
    """
    if saccade_data != None and len(saccade_data) > 0:
        self.numsaccades = len(saccade_data)
        self.features['numsaccades'] = self.numsaccades
        self.features['sumsaccadedistance'] = sum(map(lambda x: float(x.saccadedistance), saccade_data))
        self.features['meansaccadedistance'] = mean(map(lambda x: float(x.saccadedistance), saccade_data))
        self.features['stddevsaccadedistance'] = stddev(map(lambda x: float(x.saccadedistance), saccade_data))
        self.features['longestsaccadedistance'] = max(map(lambda x: float(x.saccadedistance), saccade_data))
        self.features['sumsaccadeduration'] = sum(map(lambda x: float(x.saccadeduration), saccade_data))
        self.features['meansaccadeduration'] = mean(map(lambda x: float(x.saccadeduration), saccade_data))
        self.features['stddevsaccadeduration'] = stddev(map(lambda x: float(x.saccadeduration), saccade_data))
        self.features['longestsaccadeduration'] = max(map(lambda x: float(x.saccadeduration), saccade_data))
        self.features['meansaccadespeed'] = mean(map(lambda x: float(x.saccadespeed), saccade_data))
        self.features['stddevsaccadespeed'] = stddev(map(lambda x: float(x.saccadespeed), saccade_data))
        self.features['maxsaccadespeed'] = max(map(lambda x: float(x.saccadespeed), saccade_data))
        self.features['minsaccadespeed'] = min(map(lambda x: float(x.saccadespeed), saccade_data))
        self.features['fixationsaccadetimeratio'] = float(self.features['sumfixationduration']) / self.features['sumsaccadeduration']
    else:
        self.numsaccades = 0
        self.features['numsaccades'] = 0
        self.features['sumsaccadedistance'] = -1
        self.features['meansaccadedistance'] = -1
        self.features['stddevsaccadedistance'] = -1
        self.features['longestsaccadedistance'] = -1
        self.features['sumsaccadeduration'] = -1
        self.features['meansaccadeduration'] = -1
        self.features['stddevsaccadeduration'] = -1
        self.features['longestsaccadeduration'] = -1
        self.features['meansaccadespeed'] = -1
        self.features['stddevsaccadespeed'] = -1
        self.features['maxsaccadespeed'] = -1
        self.features['minsaccadespeed'] = -1
        self.features['fixationsaccadetimeratio'] = -1
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.calc_validity1">
    <p>def <span class="ident">calc_validity1</span>(</p><p>self, threshold=0.8)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns a boolean indicating whether this Segment is valid using proportion of valid samples threshold</p>
<p>Args:
    threshold: the minimum proportion of valid samples for a Segment or Scene to be
        considered valid. By default set to value VALID_PROP_THRESH from module params.py</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.calc_validity1', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.calc_validity1" class="source">
    <pre><code>def calc_validity1(self, threshold = params.VALID_PROP_THRESH):
    """Returns a boolean indicating whether this Segment is valid using proportion of valid samples threshold
    Args:
        threshold: the minimum proportion of valid samples for a Segment or Scene to be
            considered valid. By default set to value VALID_PROP_THRESH from module params.py
    """
    return self.proportion_valid > threshold
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.calc_validity2">
    <p>def <span class="ident">calc_validity2</span>(</p><p>self, threshold=3000)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns a boolean indicating whether this Segment is valid using largest acceptable gap threshold</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.calc_validity2', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.calc_validity2" class="source">
    <pre><code>def calc_validity2(self, threshold = params.VALID_TIME_THRESH):
    """Returns a boolean indicating whether this Segment is valid using largest acceptable gap threshold
    """
    return self.largest_data_gap <= threshold
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.calc_validity3">
    <p>def <span class="ident">calc_validity3</span>(</p><p>self, threshold=0.8)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns a boolean indicating whether this Segment is valid using proportion of (valid + restored) samples threshold</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.calc_validity3', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.calc_validity3" class="source">
    <pre><code>def calc_validity3(self, threshold = params.VALID_PROP_THRESH):
    """Returns a boolean indicating whether this Segment is valid using proportion of (valid + restored) samples threshold
    """
    return self.proportion_valid_fix > threshold
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.calc_validity_fixation">
    <p>def <span class="ident">calc_validity_fixation</span>(</p><p>self, all_data)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculates the proportion of (valid + restored) "Datapoint"s over all "Datapoint"s of the Segment.</p>
<p>Restored samples are the samples which are not valid but they are part of a Fixation.
The idea is that if the user was looking at a certain point and then we loose the eye data for
a short period of time and afterwards the user is looking at the same point we can assume that user
was looking at that same point during that period.</p>
<p>Args:
    all_data: The list of "Datapoint"s which make up this Segement</p>
<p>Returns:
    A float indicating the proportion of (valid + restored) samples over all the samples in this Segment</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.calc_validity_fixation', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.calc_validity_fixation" class="source">
    <pre><code>def calc_validity_fixation(self, all_data):
    """Calculates the proportion of (valid + restored) "Datapoint"s over all "Datapoint"s of the Segment.
    Restored samples are the samples which are not valid but they are part of a Fixation.
    The idea is that if the user was looking at a certain point and then we loose the eye data for
    a short period of time and afterwards the user is looking at the same point we can assume that user
    was looking at that same point during that period.
    Args:
        all_data: The list of "Datapoint"s which make up this Segement
    Returns:
        A float indicating the proportion of (valid + restored) samples over all the samples in this Segment
    """
    if self.numfixations == 0:
        return 0.0
    num_valid = float(0)
    num = 0
    for d in all_data:
        #if d.stimuliname == 'ScreenRec':
        if d.stimuliname != '':
            num += 1
            if d.is_valid or d.fixationindex!=None:
                num_valid += 1.0
         else:
             print "###",d.event, d.data1
    if num == 0:
        return 0.0
    else:
        return num_valid / num
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.calc_validity_proportion">
    <p>def <span class="ident">calc_validity_proportion</span>(</p><p>self, all_data)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculates the proportion of "Datapoint"s which are valid.</p>
<p>Args:
    all_data: The list of "Datapoint"s which make up this Segment</p>
<p>Returns:
    A float indicating the proportion of valid samples over all the samples in this Segment</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.calc_validity_proportion', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.calc_validity_proportion" class="source">
    <pre><code>def calc_validity_proportion(self, all_data):
    """Calculates the proportion of "Datapoint"s which are valid.
    Args:
        all_data: The list of "Datapoint"s which make up this Segment
    Returns:
        A float indicating the proportion of valid samples over all the samples in this Segment
    """
    num_valid = float(0)
    num = 0
    for d in all_data:
        #if d.stimuliname == 'ScreenRec':
        #if d.stimuliname == 'Screen Recordings (1)'
        if d.stimuliname != '':
            num += 1
            if d.is_valid:
                num_valid += 1
         else:
             print "###",d.event, d.data1
    if num == 0:
        return 0.0
    else:
        return num_valid / num
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.clean_memory">
    <p>def <span class="ident">clean_memory</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.clean_memory', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.clean_memory" class="source">
    <pre><code>def clean_memory(self):
    return
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.generate_aoi_sequence">
    <p>def <span class="ident">generate_aoi_sequence</span>(</p><p>self, fixdata, aois)</p>
    </div>
    

    
  
    <div class="desc"><p>returns the sequence of AOI's where "Fixation"s occurred
Args:
    fixdata: a list of "Fixation"s
Returns:
    a list of AOI names that correspond to the sequence of "Fixation" locations</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.generate_aoi_sequence', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.generate_aoi_sequence" class="source">
    <pre><code>def generate_aoi_sequence(self, fixdata, aois):
    """returns the sequence of AOI's where "Fixation"s occurred
    Args:
        fixdata: a list of "Fixation"s
    Returns:
        a list of AOI names that correspond to the sequence of "Fixation" locations
    """
    sequence = []
    for fix in fixdata:
        for aoi in aois:
            if _fixation_inside_aoi(fix, aoi.polyin, aoi.polyout) and aoi.is_active(fix.timestamp, fix.timestamp) :
                sequence.append(aoi.aid)
    return sequence
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.get_features">
    <p>def <span class="ident">get_features</span>(</p><p>self, featurelist=None, aoifeaturelist=None, aoifeaturelabels=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns feature names and their values for this Segment</p>
<p>Args:
    featurelist: if not None, a list containing the name of features to be returned. If this is None all features will be returned
    aoifeaturelist: if not None, a list of features to be returned for each of the "AOI"s relevant to this Segment.
    aoifeaturelabels: if not None, a list of AOI related features to be returned.
    *Note: while aoifeaturelist is a subset of features that will be returned for all relevant "AOI"s, aoifeaturelabels contains
    the exact AOI feature name, i.e., a feature of the form: [AOI name]_[feature name]
    For example if an AOI called 'graph' is releveant to this Segment, aoifeaturelabels may contain 'graph_fixationrate'</p>
<p>Returns:
    featnames: a list of feature names sorted alphabetically
    featvals: a corrsponding list of feature values
    e.g.
    featnames = ['fixationrate', 'length', 'meanabspathangles']
    featvals  = [0.00268522882294', '1529851', '1.60354714212']</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.get_features', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.get_features" class="source">
    <pre><code>def get_features(self, featurelist = None, aoifeaturelist = None, aoifeaturelabels = None):
    """Returns feature names and their values for this Segment
    Args:
        featurelist: if not None, a list containing the name of features to be returned. If this is None all features will be returned
        aoifeaturelist: if not None, a list of features to be returned for each of the "AOI"s relevant to this Segment.
        aoifeaturelabels: if not None, a list of AOI related features to be returned.
        *Note: while aoifeaturelist is a subset of features that will be returned for all relevant "AOI"s, aoifeaturelabels contains
        the exact AOI feature name, i.e., a feature of the form: [AOI name]_[feature name]
        For example if an AOI called 'graph' is releveant to this Segment, aoifeaturelabels may contain 'graph_fixationrate'
    Returns:
        featnames: a list of feature names sorted alphabetically
        featvals: a corrsponding list of feature values
        e.g.
        featnames = ['fixationrate', 'length', 'meanabspathangles']
        featvals  = [0.00268522882294', '1529851', '1.60354714212']
    """
    if featurelist == []:
        featnames = []
    elif not featurelist:       #include all features
        featnames = self.features.keys()
    else:                       #a list of features was given
        featnames = []
        for name in featurelist:
            if name in self.features.keys():
                featnames.append(name)
            else:
                raise Exception('Segment %s has no such feature: %s'%(self.getid(),name))
    featnames.sort()
    featvals = map(lambda x: self.features[x], featnames)
    if self.has_aois:
        for aid, aoi in self.aoi_data.iteritems():
            if aoifeaturelabels:    #an exact list of aoifeatures was given
                anames, avals = aoi.get_features()
                anames = map(lambda x: '%s_%s'%(aid, x), anames)
                featval = zip(anames,avals)
                newfeatval = filter(lambda x: x[0] in aoifeaturelabels,featval)
                anames = []
                avals = []
                for fn,fv in newfeatval:
                    anames.append(fn)
                    avals.append(fv)
                if featnames:
                    featnames += anames
                    featvals += avals
            else:                   #a list of features for each AIO was given
                anames, avals = aoi.get_features(aoifeaturelist)
                anames = map(lambda x: '%s_%s'%(aid, x), anames)
                featnames += anames
                featvals += avals
    return featnames, featvals
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.get_indices">
    <p>def <span class="ident">get_indices</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the index features</p>
<p>Returns:
    An integer indicating the index of the first Datapoint for this Segment in the Participant's list of all "Datapoint"s (all_data)
    An integer indicating the index of the last Datapoint for this Segment in the Participant's list of all "Datapoint"s (all_data)
    An integer indicating the index of the first Fixation for this Segment in the Participant's list of all "Fixation"s (fixation_data)
    An integer indicating the index of the last Fixation for this Segment in the Participant's list of all "Fixation"s (fixation_data)
    An integer indicating the index of the first Saccade for this Segment in the Participant's list of all "Saccade"s (saccade_data). None if no saccade.
    An integer indicating the index of the last Saccade for this Segment in the Participant's list of all "Saccade"s (saccade_data). None if no saccade.
    An integer indicating the index of the first Event for this Segment in the Participant's list of all "Event"s (event_data). None if no saccade.
    An integer indicating the index of the last Event for this Segment in the Participant's list of all "Event"s (event_data). None if no saccade.
Raises:
    Exception: An exception is thrown if the values are read before initialization</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.get_indices', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.get_indices" class="source">
    <pre><code>def get_indices(self):
    """Returns the index features
    Returns:
        An integer indicating the index of the first Datapoint for this Segment in the Participant's list of all "Datapoint"s (all_data)
        An integer indicating the index of the last Datapoint for this Segment in the Participant's list of all "Datapoint"s (all_data)
        An integer indicating the index of the first Fixation for this Segment in the Participant's list of all "Fixation"s (fixation_data)
        An integer indicating the index of the last Fixation for this Segment in the Participant's list of all "Fixation"s (fixation_data)
        An integer indicating the index of the first Saccade for this Segment in the Participant's list of all "Saccade"s (saccade_data). None if no saccade.
        An integer indicating the index of the last Saccade for this Segment in the Participant's list of all "Saccade"s (saccade_data). None if no saccade.
        An integer indicating the index of the first Event for this Segment in the Participant's list of all "Event"s (event_data). None if no saccade.
        An integer indicating the index of the last Event for this Segment in the Participant's list of all "Event"s (event_data). None if no saccade.
    Raises:
        Exception: An exception is thrown if the values are read before initialization
    """
    if self.sample_start_ind != None:
        return self.sample_start_ind, self.sample_end_ind, self.fixation_start_ind, \
            self.fixation_end_ind, self.saccade_start_ind, self.saccade_end_ind, self.event_start_ind, self.event_end_ind
    raise Exception ('The indices values are accessed before setting the initial value in segement:'+self.segid+'!')
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.get_length_invalid">
    <p>def <span class="ident">get_length_invalid</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.get_length_invalid', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.get_length_invalid" class="source">
    <pre><code>def get_length_invalid(self):
    length = 0
    for segment in self.segments:
        length += segment.length_invalid
    return length
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.get_validity">
    <p>def <span class="ident">get_validity</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Determines if this Segment is valid with the given validity method set in params.VALIDITY_METHOD</p>
<p>Returns:
    A boolean indicating whether this Segment is valid</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.get_validity', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.get_validity" class="source">
    <pre><code>def get_validity(self):
    """Determines if this Segment is valid with the given validity method set in params.VALIDITY_METHOD
    Returns:
        A boolean indicating whether this Segment is valid
    """
    if params.VALIDITY_METHOD == 1:
        return self.validity1
    elif params.VALIDITY_METHOD == 2:
        return self.validity2
    elif params.VALIDITY_METHOD == 3:
        return self.validity3
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.getallgaps">
    <p>def <span class="ident">getallgaps</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the total length of all invalid gaps for this Segment</p>
<p>Args:
    an integer: the length in ms of invalid points for this Segment</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.getallgaps', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.getallgaps" class="source">
    <pre><code>def getallgaps(self):
    """Returns the total length of all invalid gaps for this Segment
    Args:
        an integer: the length in ms of invalid points for this Segment
    """
    return self.all_invalid_gaps
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.getgaps">
    <p>def <span class="ident">getgaps</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the list of invalid gaps &gt; params.MAX_SEG_TIMEGAP for this Segment</p>
<p>Args:
    a list of invalid gaps for this Segment</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.getgaps', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.getgaps" class="source">
    <pre><code>def getgaps(self):
    """Returns the list of invalid gaps > params.MAX_SEG_TIMEGAP for this Segment
    Args:
        a list of invalid gaps for this Segment
    """
    return self.time_gaps
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.getid">
    <p>def <span class="ident">getid</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the scid for this Scene</p>
<p>Returns: a string conataining the scid for this Scene</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.getid', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.getid" class="source">
    <pre><code>def getid(self):
    """Returns the scid for this Scene
    Returns: a string conataining the scid for this Scene
    """
    return self.scid
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.merge_aoisequences">
    <p>def <span class="ident">merge_aoisequences</span>(</p><p>self, segments)</p>
    </div>
    

    
  
    <div class="desc"><p>returns the AOI sequence merged from the AOI sequences in the "Segment"s
Args:
    segments: a list of "Segment"s which belong to this Scene.
Returns:
    a list of AOI names that correspond to the sequence of "Fixation"s in this Scene</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.merge_aoisequences', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.merge_aoisequences" class="source">
    <pre><code>def merge_aoisequences(self, segments):
    """returns the AOI sequence merged from the AOI sequences in the "Segment"s
    Args:
        segments: a list of "Segment"s which belong to this Scene.
    Returns:
        a list of AOI names that correspond to the sequence of "Fixation"s in this Scene
    """
    sequence = []
    for seg in segments:
        sequence.extend(seg.features.get('aoisequence', []))
    return sequence
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.merge_blink_features">
    <p>def <span class="ident">merge_blink_features</span>(</p><p>self, segments)</p>
    </div>
    

    
  
    <div class="desc"><p>Merge blink features asuch as
    blink_num:                 number of blinks
    blink_duration_total:       sum of the blink durations
    blink_duration_mean:        mean of the blink durations
    blink_duration_std:         standard deviation of blink durations
    blink_duration_max:         maximal blink duration
    blink_duration_min:         minimal blink duration
    blink_rate:                 rate of blinks
    blink_time_distance_mean:   mean time difference between consequtive blinks
    blink_time_distance_std:    std time difference between consequtive blinks
    blink_time_distance_min:    minimal time difference between consequtive blinks
    blink_time_distance_max:    maximal time difference between consequtive blinks
Args:
    segments: The list of Segments for this Scene with pre-calculated features</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.merge_blink_features', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.merge_blink_features" class="source">
    <pre><code>def merge_blink_features(self, segments):
    """ Merge blink features asuch as
            blink_num:                 number of blinks
            blink_duration_total:       sum of the blink durations
            blink_duration_mean:        mean of the blink durations
            blink_duration_std:         standard deviation of blink durations
            blink_duration_max:         maximal blink duration
            blink_duration_min:         minimal blink duration
            blink_rate:                 rate of blinks
            blink_time_distance_mean:   mean time difference between consequtive blinks
            blink_time_distance_std:    std time difference between consequtive blinks
            blink_time_distance_min:    minimal time difference between consequtive blinks
            blink_time_distance_max:    maximal time difference between consequtive blinks
        Args:
            segments: The list of Segments for this Scene with pre-calculated features
    """
    self.features['blinknum'] = sumfeat(segments, "features['blinknum']")
    if self.features['blinknum'] > 0:
        self.features['blinkdurationtotal']     = sumfeat(segments, "features['blinkdurationtotal']")
        self.features['blinkdurationmean']      = weightedmeanfeat(segments, "features['blinknum']", "features['blinkdurationmean']")
        self.features['blinkdurationstd']       = aggregatestddevfeat(segments, "features['blinknum']", "features['blinkdurationstd']",
                                                  "features['blinkdurationmean']", self.features['blinkdurationmean'])
        self.features['blinkdurationmin']       = minfeat(segments, "features['blinkdurationmin']", -1)
        self.features['blinkdurationmax']       = maxfeat(segments, "features['blinkdurationmax']")
        self.features['blinkrate']              = float(self.features['blinknum']) / (self.length - self.length_invalid)
        self.features['blinktimedistancemean']  = weightedmeanfeat(segments,
                                                  "features['blinknum']", "features['blinktimedistancemean']")
        self.features['blinktimedistancestd']   = aggregatestddevfeat(segments, "features['blinknum']",
                                                  "features['blinktimedistancestd']", "features['blinktimedistancemean']",
                                                  self.features['blinktimedistancemean'])
        self.features['blinktimedistancemin']   = minfeat(segments, "features['blinktimedistancemin']", -1)
        self.features['blinktimedistancemax']   = maxfeat(segments, "features['blinktimedistancemax']")
    else:
        self.features['blinkdurationtotal']     = -1
        self.features['blinkdurationmean']      = -1
        self.features['blinkdurationstd']       = -1
        self.features['blinkdurationmin']       = -1
        self.features['blinkdurationmax']       = -1
        self.features['blinkrate']              = -1
        self.features['blinktimedistancemean']  = -1
        self.features['blinktimedistancestd']   = -1
        self.features['blinktimedistancemin']   = -1
        self.features['blinktimedistancemax']   = -1
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.merge_distance_data">
    <p>def <span class="ident">merge_distance_data</span>(</p><p>self, segments)</p>
    </div>
    

    
  
    <div class="desc"><p>Merge distance features such as
    mean_distance:            mean of distances from the screen
    stddev_distance:          standard deviation of distances from the screen
    min_distance:             smallest distance from the screen
    max_distance:             largest distance from the screen
    start_distance:           distance from the screen in the beginning of this scene
    end_distance:             distance from the screen in the end of this scene</p>
<p>Args:
    segments: The list of Segments for this Scene with pre-calculated features</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.merge_distance_data', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.merge_distance_data" class="source">
    <pre><code>def merge_distance_data(self, segments):
    """ Merge distance features such as
            mean_distance:            mean of distances from the screen
            stddev_distance:          standard deviation of distances from the screen
            min_distance:             smallest distance from the screen
            max_distance:             largest distance from the screen
            start_distance:           distance from the screen in the beginning of this scene
            end_distance:             distance from the screen in the end of this scene
        Args:
            segments: The list of Segments for this Scene with pre-calculated features
    """
    self.numdistancedata = sumfeat(segments,'numdistancedata') #Distance
    if self.numdistancedata > 0: # check if scene has any pupil data
        self.features['meandistance'] = weightedmeanfeat(segments, 'numdistancedata', "features['meandistance']")
        self.features['stddevdistance'] = aggregatestddevfeat(segments, 'numdistancedata', "features['stddevdistance']", "features['meandistance']", self.features['meandistance'])
        self.features['maxdistance'] = maxfeat(segments, "features['maxdistance']")
        self.features['mindistance'] = minfeat(segments, "features['mindistance']", -1)
        self.features['startdistance'] = self.firstseg.features['startdistance']
        self.features['enddistance'] = self.endseg.features['enddistance']
    else:
        self.features['meandistance'] = -1
        self.features['stddevdistance'] = -1
        self.features['maxdistance'] = -1
        self.features['mindistance'] = -1
        self.features['startdistance'] = -1
        self.features['enddistance'] = -1
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.merge_event_data">
    <p>def <span class="ident">merge_event_data</span>(</p><p>self, event_data, segments)</p>
    </div>
    

    
  
    <div class="desc"><p>Merge event features such as
    numevents:                number of events in the segment
    numleftclic:              number of left clinks in the segment
    numrightclic:             number of right clinks in the segment
    numdoubleclic:            number of double clinks in the segment
    numkeypressed:            number of times a key was pressed in the segment
    leftclicrate:             the rate of left clicks (relative to all datapoints) in this segment
    rightclicrate:            the rate of right clicks (relative to all datapoints) in this segment
    doubleclicrate:           the rate of double clicks (relative to all datapoints) in this segment
    keypressedrate:           the rate of key presses (relative to all datapoints) in this segment
    timetofirstleftclic:      time until the first left click in this segment
    timetofirstrightclic:     time until the first right click in this segment
    timetofirstdoubleclic:    time until the first double click in this segment
    timetofirstkeypressed:    time until the first key pressed in this segment
Args:
    event_data: The list of events for this Scene
    segments: The list of Segments for this Scene with pre-calculated features</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.merge_event_data', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.merge_event_data" class="source">
    <pre><code>def merge_event_data(self, event_data, segments):
    """ Merge event features such as
            numevents:                number of events in the segment
            numleftclic:              number of left clinks in the segment
            numrightclic:             number of right clinks in the segment
            numdoubleclic:            number of double clinks in the segment
            numkeypressed:            number of times a key was pressed in the segment
            leftclicrate:             the rate of left clicks (relative to all datapoints) in this segment
            rightclicrate:            the rate of right clicks (relative to all datapoints) in this segment
            doubleclicrate:           the rate of double clicks (relative to all datapoints) in this segment
            keypressedrate:           the rate of key presses (relative to all datapoints) in this segment
            timetofirstleftclic:      time until the first left click in this segment
            timetofirstrightclic:     time until the first right click in this segment
            timetofirstdoubleclic:    time until the first double click in this segment
            timetofirstkeypressed:    time until the first key pressed in this segment
        Args:
            event_data: The list of events for this Scene
            segments: The list of Segments for this Scene with pre-calculated features
    """
    if event_data != None:
        self.features['numevents'] = sumfeat(segments,'numevents')
        self.features['numleftclic'] = sumfeat(segments,"features['numleftclic']")
        self.features['numrightclic'] = sumfeat(segments, "features['numrightclic']")
        self.features['numdoubleclic'] = sumfeat(segments, "features['numdoubleclic']")
        self.features['numkeypressed'] = sumfeat(segments, "features['numkeypressed']")
        self.features['leftclicrate'] = float(self.features['numleftclic'])/(self.length - self.length_invalid)
        self.features['rightclicrate'] = float(self.features['numrightclic'])/(self.length - self.length_invalid)
        self.features['doubleclicrate'] = float(self.features['numdoubleclic'])/(self.length - self.length_invalid)
        self.features['keypressedrate'] = float(self.features['numkeypressed'])/(self.length - self.length_invalid)
        self.features['timetofirstleftclic'] = self.firstseg.features['timetofirstleftclic']
        self.features['timetofirstrightclic'] = self.firstseg.features['timetofirstrightclic']
        self.features['timetofirstdoubleclic'] = self.firstseg.features['timetofirstdoubleclic']
        self.features['timetofirstkeypressed'] = self.firstseg.features['timetofirstkeypressed']
    else:
        self.features['numevents'] = 0
        self.features['numleftclic'] = 0
        self.features['numrightclic'] = 0
        self.features['numdoubleclic'] = 0
        self.features['numkeypressed'] = 0
        self.features['leftclicrate'] = -1
        self.features['rightclicrate'] = -1
        self.features['doubleclicrate'] = -1
        self.features['keypressedrate'] = -1
        self.features['timetofirstleftclic'] = -1
        self.features['timetofirstrightclic'] = -1
        self.features['timetofirstdoubleclic'] = -1
        self.features['timetofirstkeypressed'] = -1
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.merge_fixation_features">
    <p>def <span class="ident">merge_fixation_features</span>(</p><p>self, segments)</p>
    </div>
    

    
  
    <div class="desc"><p>Merge fixation features such as
    meanfixationduration:     mean duration of fixations
    stddevfixationduration    standard deviation of duration of fixations
    sumfixationduration:      sum of durations of fixations
    fixationrate:             rate of fixation datapoints relative to all datapoints
Args:
    segments: The list of Segments for this Scene with pre-calculated features</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.merge_fixation_features', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.merge_fixation_features" class="source">
    <pre><code>def merge_fixation_features(self, segments):
    """ Merge fixation features such as
            meanfixationduration:     mean duration of fixations
            stddevfixationduration    standard deviation of duration of fixations
            sumfixationduration:      sum of durations of fixations
            fixationrate:             rate of fixation datapoints relative to all datapoints
        Args:
            segments: The list of Segments for this Scene with pre-calculated features
    """
    self.numfixations = sumfeat(segments, 'numfixations')
    self.features['numfixations'] = self.numfixations
    self.features['fixationrate'] = float(self.numfixations) / (self.length - self.length_invalid)
    if self.numfixations > 0:
        self.features['meanfixationduration'] = weightedmeanfeat(segments,'numfixations',"features['meanfixationduration']")
        self.features['stddevfixationduration'] = aggregatestddevfeat(segments, 'numfixations', "features['stddevfixationduration']", "features['meanfixationduration']", self.features['meanfixationduration'])
        self.features['sumfixationduration'] = sumfeat(segments, "features['sumfixationduration']")
        self.features['fixationrate'] = float(self.numfixations)/(self.length - self.length_invalid)
    else:
        self.features['meanfixationduration'] = -1
        self.features['stddevfixationduration'] = -1
        self.features['sumfixationduration'] = -1
        self.features['fixationrate'] = -1
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.merge_path_angle_features">
    <p>def <span class="ident">merge_path_angle_features</span>(</p><p>self, segments)</p>
    </div>
    

    
  
    <div class="desc"><p>Merge path and angle features such as
    meanpathdistance:         mean of path distances
    sumpathdistance:          sum of path distances
    eyemovementvelocity:      average eye movement velocity
    sumabspathangles:         sum of absolute path angles
    abspathanglesrate:        ratio of absolute path angles relative to all datapoints
    stddevabspathangles:      standard deviation of absolute path angles
    sumrelpathangles:         sum of relative path angles
    relpathanglesrate:        ratio of relative path angles relative to all datapoints
    stddevrelpathangles:      standard deviation of relative path angles
Args:
    segments: The list of Segments for this Scene with pre-calculated features</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.merge_path_angle_features', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.merge_path_angle_features" class="source">
    <pre><code>def merge_path_angle_features(self, segments):
    """ Merge path and angle features such as
            meanpathdistance:         mean of path distances
            sumpathdistance:          sum of path distances
            eyemovementvelocity:      average eye movement velocity
            sumabspathangles:         sum of absolute path angles
            abspathanglesrate:        ratio of absolute path angles relative to all datapoints
            stddevabspathangles:      standard deviation of absolute path angles
            sumrelpathangles:         sum of relative path angles
            relpathanglesrate:        ratio of relative path angles relative to all datapoints
            stddevrelpathangles:      standard deviation of relative path angles
        Args:
            segments: The list of Segments for this Scene with pre-calculated features
    """
    self.numfixdistances = sumfeat(segments, "numfixdistances")
    self.numabsangles = sumfeat(segments, "numabsangles")
    self.numrelangles = sumfeat(segments, "numrelangles")
    if self.numfixations > 1:
        self.features['meanpathdistance'] = weightedmeanfeat(segments,'numfixdistances',"features['meanpathdistance']")
        self.features['sumpathdistance'] = sumfeat(segments, "features['sumpathdistance']")
        self.features['stddevpathdistance'] = aggregatestddevfeat(segments, 'numfixdistances', "features['stddevpathdistance']", "features['meanpathdistance']", self.features['meanpathdistance'])
        self.features['eyemovementvelocity'] = self.features['sumpathdistance']/(self.length - self.length_invalid)
        self.features['sumabspathangles'] = sumfeat(segments, "features['sumabspathangles']")
        self.features['meanabspathangles'] = weightedmeanfeat(segments,'numabsangles',"features['meanabspathangles']")
        self.features['abspathanglesrate'] = self.features['sumabspathangles']/(self.length - self.length_invalid)
        self.features['stddevabspathangles'] = aggregatestddevfeat(segments, 'numabsangles', "features['stddevabspathangles']", "features['meanabspathangles']", self.features['meanabspathangles'])
        self.features['sumrelpathangles'] = sumfeat(segments, "features['sumrelpathangles']")
        self.features['meanrelpathangles'] = weightedmeanfeat(segments,'numrelangles',"features['meanrelpathangles']")
        self.features['relpathanglesrate'] = self.features['sumrelpathangles']/(self.length - self.length_invalid)
        self.features['stddevrelpathangles'] = aggregatestddevfeat(segments, 'numrelangles', "features['stddevrelpathangles']", "features['meanrelpathangles']", self.features['meanrelpathangles'])
    else:
        self.features['meanpathdistance'] = -1
        self.features['sumpathdistance'] = -1
        self.features['stddevpathdistance'] = -1
        self.features['eyemovementvelocity'] = -1
        self.features['sumabspathangles'] = -1
        self.features['abspathanglesrate'] = -1
        self.features['meanabspathangles']= -1
        self.features['stddevabspathangles']= -1
        self.features['sumrelpathangles'] = -1
        self.features['relpathanglesrate'] = -1
        self.features['meanrelpathangles']= -1
        self.features['stddevrelpathangles'] = -1
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.merge_pupil_features">
    <p>def <span class="ident">merge_pupil_features</span>(</p><p>self, export_pupilinfo, segments)</p>
    </div>
    

    
  
    <div class="desc"><p>Merge pupil features asuch as
    mean_pupil_size:            mean of pupil sizes
    stddev_pupil_size:          standard deviation of pupil sizes
    min_pupil_size:             smallest pupil size
    max_pupil_size:             largest pupil size
    mean_pupil_velocity:        mean of pupil velocities
    stddev_pupil_velocity:      standard deviation of pupil velocities
    min_pupil_velocity:         smallest pupil velocity
    max_pupil_velocity:         largest pupil velocity
Args:
    segments: The list of Segments for this Scene with pre-calculated features
    export_pupilinfo: True to export raw pupil data in EMDAT output (False by default).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.merge_pupil_features', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.merge_pupil_features" class="source">
    <pre><code>def merge_pupil_features(self, export_pupilinfo, segments):
    """ Merge pupil features asuch as
            mean_pupil_size:            mean of pupil sizes
            stddev_pupil_size:          standard deviation of pupil sizes
            min_pupil_size:             smallest pupil size
            max_pupil_size:             largest pupil size
            mean_pupil_velocity:        mean of pupil velocities
            stddev_pupil_velocity:      standard deviation of pupil velocities
            min_pupil_velocity:         smallest pupil velocity
            max_pupil_velocity:         largest pupil velocity
        Args:
            segments: The list of Segments for this Scene with pre-calculated features
            export_pupilinfo: True to export raw pupil data in EMDAT output (False by default).
    """
    self.numpupilsizes    = sumfeat(segments,'numpupilsizes')
    self.numpupilvelocity = sumfeat(segments,'numpupilvelocity')
    if self.numpupilsizes > 0: # check if scene has any pupil data
        if export_pupilinfo:
            self.pupilinfo_for_export = mergevalues(segments, 'pupilinfo_for_export')
        self.features['meanpupilsize'] = weightedmeanfeat(segments, 'numpupilsizes', "features['meanpupilsize']")
        self.features['stddevpupilsize'] = aggregatestddevfeat(segments, 'numpupilsizes', "features['stddevpupilsize']", "features['meanpupilsize']", self.features['meanpupilsize']) #stddev(self.adjvalidpupilsizes)
        self.features['maxpupilsize'] = maxfeat(segments, "features['maxpupilsize']")
        self.features['minpupilsize'] = minfeat(segments, "features['minpupilsize']", -1)
        self.features['startpupilsize'] = self.firstseg.features['startpupilsize']
        self.features['endpupilsize'] = self.endseg.features['endpupilsize']
    else:
        self.pupilinfo_for_export = []
        self.features['meanpupilsize'] = -1
        self.features['stddevpupilsize'] = -1
        self.features['maxpupilsize'] = -1
        self.features['minpupilsize'] = -1
        self.features['startpupilsize'] = -1
        self.features['endpupilsize'] = -1
    if self.numpupilvelocity > 0: # check if scene has any pupil velocity data
        self.features['meanpupilvelocity'] = weightedmeanfeat(segments, 'numpupilvelocity', "features['meanpupilvelocity']")
        self.features['stddevpupilvelocity'] = aggregatestddevfeat(segments, 'numpupilvelocity', "features['stddevpupilvelocity']", "features['meanpupilvelocity']", self.features['meanpupilvelocity']) #stddev(self.valid_pupil_velocity)
        self.features['maxpupilvelocity'] = maxfeat(segments, "features['maxpupilvelocity']")
        self.features['minpupilvelocity'] = minfeat(segments, "features['minpupilvelocity']", -1)
    else:
        self.features['meanpupilvelocity'] = -1
        self.features['stddevpupilvelocity'] = -1
        self.features['maxpupilvelocity'] = -1
        self.features['minpupilvelocity'] = -1
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.merge_saccade_data">
    <p>def <span class="ident">merge_saccade_data</span>(</p><p>self, saccade_data, segments)</p>
    </div>
    

    
  
    <div class="desc"><p>Merge saccade features such as
    numsaccades:              number of saccades in the segment
    sumsaccadedistance:       sum of distances during each saccade
    meansaccadedistance:      mean of distances during each saccade
    stddevsaccadedistance:    standard deviation of distances during each saccade
    longestsaccadedistance:   distance of longest saccade
    sumsaccadeduration:       total time spent on saccades in this segment
    meansaccadeduration:      average saccade duration
    stddevsaccadeduration:    standard deviation of saccade durations
    longestsaccadeduration:   longest duration of saccades in this segment
    meansaccadespeed:         average speed of saccades in this segment
    stddevsaccadespeed:       standard deviation of speed of saccades in this segment
    maxsaccadespeed:          highest saccade speed in this segment
    minsaccadespeed:          lowest saccade speed in this  segment
    fixationsaccadetimeratio: fixation to saccade time ratio for this segment
Args:
    saccade_data: The list of saccade datapoints for this Scene
    segments: The list of Segments for this Scene with pre-calculated features</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.merge_saccade_data', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.merge_saccade_data" class="source">
    <pre><code>def merge_saccade_data(self, saccade_data, segments):
    """ Merge saccade features such as
            numsaccades:              number of saccades in the segment
            sumsaccadedistance:       sum of distances during each saccade
            meansaccadedistance:      mean of distances during each saccade
            stddevsaccadedistance:    standard deviation of distances during each saccade
            longestsaccadedistance:   distance of longest saccade
            sumsaccadeduration:       total time spent on saccades in this segment
            meansaccadeduration:      average saccade duration
            stddevsaccadeduration:    standard deviation of saccade durations
            longestsaccadeduration:   longest duration of saccades in this segment
            meansaccadespeed:         average speed of saccades in this segment
            stddevsaccadespeed:       standard deviation of speed of saccades in this segment
            maxsaccadespeed:          highest saccade speed in this segment
            minsaccadespeed:          lowest saccade speed in this  segment
            fixationsaccadetimeratio: fixation to saccade time ratio for this segment
        Args:
            saccade_data: The list of saccade datapoints for this Scene
            segments: The list of Segments for this Scene with pre-calculated features
    """
    if saccade_data != None:
        self.features['numsaccades'] = sumfeat(segments,'numsaccades')
        self.features['sumsaccadedistance'] = sumfeat(segments, "features['sumsaccadedistance']")
        self.features['meansaccadedistance'] = weightedmeanfeat(self.segments,'numsaccades',"features['meansaccadedistance']")
        self.features['stddevsaccadedistance'] = aggregatestddevfeat(segments, 'numsaccades', "features['stddevsaccadedistance']", "features['meansaccadedistance']", self.features['meansaccadedistance'])
        self.features['longestsaccadedistance'] = maxfeat(segments, "features['longestsaccadedistance']")
        self.features['sumsaccadeduration'] = sumfeat(segments,"features['sumsaccadeduration']")
        self.features['meansaccadeduration'] = weightedmeanfeat(self.segments,'numsaccades',"features['meansaccadeduration']")
        self.features['stddevsaccadeduration'] = aggregatestddevfeat(segments, 'numsaccades', "features['stddevsaccadeduration']", "features['meansaccadeduration']", self.features['meansaccadeduration'])
        self.features['longestsaccadeduration'] = maxfeat(segments, "features['longestsaccadeduration']")
        self.features['meansaccadespeed'] = weightedmeanfeat(self.segments,'numsaccades',"features['meansaccadespeed']")
        self.features['stddevsaccadespeed'] = aggregatestddevfeat(segments, 'numsaccades', "features['stddevsaccadespeed']", "features['meansaccadespeed']", self.features['meansaccadespeed'])
        self.features['maxsaccadespeed'] = maxfeat(segments, "features['maxsaccadespeed']")
        self.features['minsaccadespeed'] = minfeat(segments, "features['minsaccadespeed']", -1)
        self.features['fixationsaccadetimeratio'] = sumfeat(segments, "features['fixationsaccadetimeratio']") / float(len(segments))
    else:
        self.features['numsaccades'] = 0
        self.features['sumsaccadedistance'] = -1
        self.features['meansaccadedistance'] = -1
        self.features['stddevsaccadedistance'] = -1
        self.features['longestsaccadedistance'] = -1
        self.features['sumsaccadeduration'] = -1
        self.features['meansaccadeduration'] = -1
        self.features['stddevsaccadeduration'] = -1
        self.features['longestsaccadeduration'] = -1
        self.features['meansaccadespeed'] = -1
        self.features['stddevsaccadespeed'] = -1
        self.features['maxsaccadespeed'] = -1
        self.features['minsaccadespeed'] = -1
        self.features['fixationsaccadetimeratio'] = -1
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.print_">
    <p>def <span class="ident">print_</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Ourputs all feature names and their values for this Segment on the console</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.print_', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.print_" class="source">
    <pre><code>def print_(self):
    """Ourputs all feature names and their values for this Segment on the console
    """
    print("ID", self.getid())
    print("start",self.start)
    print("end",self.end)
    print("is_valid",self.is_valid)
    print
     featurelist =["completion_time","numfixations","length","numsamples"]
     if self.features['numfixations'] > 0:
         featurelist.extend(["meanfixationduration","stddevfixationduration","sumfixationduration","fixationrate"])
     featurelist.extend(["meanpathdistance","sumpathdistance","stddevpathdistance","sumabspathangles","meanabspathangles","stddevabspathangles","sumrelpathangles","meanrelpathangles","stddevrelpathangles"])
    fn,fv = self.get_features()
    for i in xrange(len(fn)):
        print(fn[i],':',fv[i])
    print
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.set_aois">
    <p>def <span class="ident">set_aois</span>(</p><p>self, segments, aois)</p>
    </div>
    

    
  
    <div class="desc"><p>Sets the "AOI"s relevant to this Scene</p>
<p>Args:
    segments: a list of "Segment"s which belong to this Scene.</p>
<pre><code>aois: a list of "AOI"s relevant to this Scene
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.set_aois', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.set_aois" class="source">
    <pre><code>def set_aois(self, segments, aois):
    """Sets the "AOI"s relevant to this Scene
    Args:
        segments: a list of "Segment"s which belong to this Scene.
        aois: a list of "AOI"s relevant to this Scene
    """
    if len(aois) == 0 and params.VERBOSE != "QUIET":
        print("No AOI in segment ", self.segid)
    self.aoi_data={}
    for seg in segments:
        for aid in seg.aoi_data.keys():
                if aid in self.aoi_data:
                    if seg.aoi_data[aid].isActive:
                        self.aoi_data[aid] = merge_aoistats(self.aoi_data[aid],seg.aoi_data[aid], self.features['length'], self.numfixations, self.start)
                else:
                    self.aoi_data[aid] = deepcopy(seg.aoi_data[aid])
                    if seg.aoi_data[aid].isActive:
                        self.aoi_data[aid].features['timetofirstfixation'] += self.aoi_data[aid].starttime - self.start
                        self.aoi_data[aid].features['timetolastfixation'] += self.aoi_data[aid].starttime - self.start
                        if self.firstseg.aoi_data[aid].features['timetofirstleftclic'] != -1:
                            self.aoi_data[aid].features['timetofirstleftclic'] += self.aoi_data[aid].starttime - self.start
                        if self.firstseg.aoi_data[aid].features['timetofirstrightclic'] != -1:
                            self.aoi_data[aid].features['timetofirstrightclic'] += self.aoi_data[aid].starttime - self.start
                        if self.firstseg.aoi_data[aid].features['timetofirstdoubleclic'] != -1:
                            self.aoi_data[aid].features['timetofirstdoubleclic'] += self.aoi_data[aid].starttime - self.start
                        if self.firstseg.aoi_data[aid].features['timetolastleftclic'] != -1:
                            self.aoi_data[aid].features['timetolastleftclic'] += self.aoi_data[aid].starttime - self.start
                        if self.firstseg.aoi_data[aid].features['timetolastrightclic'] != -1:
                            self.aoi_data[aid].features['timetolastrightclic'] += self.aoi_data[aid].starttime - self.start
                        if self.firstseg.aoi_data[aid].features['timetolastdoubleclic'] != -1:
                            self.aoi_data[aid].features['timetolastdoubleclic'] += self.aoi_data[aid].starttime - self.start
    #Merge stdev
    #For each seg, compute: T = [(numfix-1) * Variance + numfix * power( meanfixduration_in_seg - meanfixduration_in_scene, 2)]
    #At the Scene level: [ SQRT( SUM(T_seg1...Tsegn) / (numfix-1) ]
    for aid in self.aoi_data.keys():
        temp = 0
        numdata = 0
        for seg in segments:
                temp += (seg.aoi_data[aid].features['numfixations']-1) * seg.aoi_data[aid].variance + seg.aoi_data[aid].features['numfixations'] * math.pow(seg.aoi_data[aid].features['meanfixationduration'] - self.aoi_data[aid].features['meanfixationduration'], 2)
                numdata += seg.aoi_data[aid].features['numfixations']
        self.aoi_data[aid].features['stddevfixationduration'] = math.sqrt(temp / (numdata-1) ) if numdata > 1 else 0
    """
    firstsegaois = self.firstseg.aoi_data.keys()
    for aid in self.aoi_data.keys():
        if aid in firstsegaois:
            self.aoi_data[aid].features['timetofirstfixation'] = deepcopy(self.firstseg.aoi_data[aid].features['timetofirstfixation'])
            if self.firstseg.aoi_data[aid].features['timetofirstleftclic'] != -1:
                self.aoi_data[aid].features['timetofirstleftclic'] = deepcopy(self.firstseg.aoi_data[aid].features['timetofirstleftclic'])
                self.aoi_data[aid].features['timetofirstrightclic'] = deepcopy(self.firstseg.aoi_data[aid].features['timetofirstrightclic'])
                self.aoi_data[aid].features['timetofirstdoubleclic'] = deepcopy(self.firstseg.aoi_data[aid].features['timetofirstdoubleclic'])
        else:
            self.aoi_data[aid].features['timetofirstfixation'] = float('inf')
            self.aoi_data[aid].features['timetofirstleftclic'] = float('inf')
            self.aoi_data[aid].features['timetofirstrightclic'] = float('inf')
            self.aoi_data[aid].features['timetofirstdoubleclic'] = float('inf')
    """
    if len(self.aoi_data) > 0:
        self.has_aois = True
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Scene.Scene.set_indices">
    <p>def <span class="ident">set_indices</span>(</p><p>self, sample_st, sample_end, fix_st, fix_end, sac_st=None, sac_end=None, event_st=None, event_end=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Sets the index features</p>
<p>Args:
    sample_st: An integer indicating the index of the first Datapoint for this Segment in the Participant's list of all "Datapoint"s (all_data)
    sample_end: An integer indicating the index of the last Datapoint for this Segment in the Participant's list of all "Datapoint"s (all_data)
    fix_st: An integer indicating the index of the first Fixation for this Segment in the Participant's list of all "Fixation"s (fixation_data)
    fix_end: An integer indicating the index of the last Fixation for this Segment in the Participant's list of all "Fixation"s (fixation_data)
    sac_st: An integer indicating the index of the first Saccade for this Segment in the Participant's list of all "Saccade"s (saccade_data)
    sac_end: An integer indicating the index of the last Saccade for this Segment in the Participant's list of all "Saccade"s (saccade_data)
    event_st: An integer indicating the index of the first Event for this Segment in the Participant's list of all "Event"s (event_data)
    event_end: An integer indicating the index of the last Event for this Segment in the Participant's list of all "Event"s (event_data)</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Scene.Scene.set_indices', this);">Show source &equiv;</a></p>
  <div id="source-Scene.Scene.set_indices" class="source">
    <pre><code>def set_indices(self,sample_st,sample_end,fix_st,fix_end,sac_st=None,sac_end=None,event_st=None,event_end=None):
    """Sets the index features
    Args:
        sample_st: An integer indicating the index of the first Datapoint for this Segment in the Participant's list of all "Datapoint"s (all_data)
        sample_end: An integer indicating the index of the last Datapoint for this Segment in the Participant's list of all "Datapoint"s (all_data)
        fix_st: An integer indicating the index of the first Fixation for this Segment in the Participant's list of all "Fixation"s (fixation_data)
        fix_end: An integer indicating the index of the last Fixation for this Segment in the Participant's list of all "Fixation"s (fixation_data)
        sac_st: An integer indicating the index of the first Saccade for this Segment in the Participant's list of all "Saccade"s (saccade_data)
        sac_end: An integer indicating the index of the last Saccade for this Segment in the Participant's list of all "Saccade"s (saccade_data)
        event_st: An integer indicating the index of the first Event for this Segment in the Participant's list of all "Event"s (event_data)
        event_end: An integer indicating the index of the last Event for this Segment in the Participant's list of all "Event"s (event_data)
    """
    self.sample_start_ind = sample_st
    self.sample_end_ind = sample_end
    self.fixation_start_ind = fix_st
    self.fixation_end_ind = fix_end
    self.saccade_start_ind = sac_st
    self.saccade_end_ind = sac_end
    self.event_start_ind = event_st
    self.event_end_ind = event_end
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
